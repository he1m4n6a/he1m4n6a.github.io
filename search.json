[{"title":"art1","url":"/2019/11/29/art1/"},{"title":"JAVA安全教程系列-基础篇","url":"/2019/11/29/test/","content":"# 简介\n\n本篇是整个java安全学习系列的基础篇，这个系列篇章我会把我的整个java安全学习过程进行一个总结。至于为什么想写这个系列文章，是因为当时听了小伙伴的分享中提到“21小时可以入门任何课程”，看了他整理的学习导图，深受启发。所以，我打算把过去的和新学习的东西，完整的、系统的归纳总结出来，做到温故而知新。\n\n# 学习流程\n\n![](/images/a1/1.png)\n\n这个是我整理的java的学习路线图，每个人可能有不同的理解，大家可以自己动手进行自己的学习规划。并且学习过程是动态的，可能在学习总结过程中，我会修增某些模块。本篇我将对第一部分-基础，进行讲解。\n\n# java基础\n\n这边讨论的基础，不是java的基础语法，这部分自己可以快速入门学习。我要讲的部分，是java的一些特性，或者比较重要的语法，在看代码中或者分析payload经常用到的。这部分是我在实践过程中觉得难点和重点，每个人的理解方法不同，所以并不适用所有人的学习，不过理解以下概念方法对于java安全学习是有帮助的，这点可以肯定。\n\n## 基本语法\n\n### 泛类型\n\n泛型，即“参数化类型”。一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢？\n\n顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。\n\n泛型的本质是为了参数化类型（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型）。也就是说在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。\n\n最典型的泛型类应用就是各种容器类，如：List、Set、Map。自己定义的泛型类形式如下：\n\n```java\n//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型\n//在实例化泛型类时，必须指定T的具体类型\npublic class Generic<T>{ \n    //key这个成员变量的类型为T,T的类型由外部指定  \n    private T key;\n\n    public Generic(T key) { //泛型构造方法形参key的类型也为T，T的类型由外部指定\n        this.key = key;\n    }\n\n    public T getKey(){ //泛型方法getKey的返回值类型为T，T的类型由外部指定\n        return key;\n    }\n}\n```\n\n更多泛型基本知识内容可参考：[https://www.cnblogs.com/coprince/p/8603492.html](https://www.cnblogs.com/coprince/p/8603492.html)\n\n### 对象类型、基本类型\n\nJava中的对象分两种类型：**基本类型和非基本类型（对象类型）。**\n\n基本类型就是那些最常用的类型，例如：boolean/char/byte/short/int/long/float/double，这些类型有个特点，就是变量直接存储值。\n\n除了基本类型之外的都是非基本类型了。非基本类型有个显著特点就是初始化的时候一般需要使用new来创建一个对象，所以非基本类型也叫非基本类型。例如:String name=new String(Tom);。非基本类型跟基本类型的本质区别，在于**非基本类型变量存储的不是值，而是引用。**\n\n## 命令执行的方法\n\njava命令执行，主要有两种方法Runtime.getRuntime().exec(cmd) 和ProcessBuilder(cmd).start，实例如下：\n\n```java\npackage com.manba.demo;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class CmdTest {\n    public static void rexec() throws IOException {\n        String cmds = \"/bin/sh -c pwd\"; // 也可以数组形式\n        Process process = Runtime.getRuntime().exec(cmds);\n        BufferedReader Reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n        String line;\n        while ((line = Reader.readLine()) != null) System.out.println(line);\n    }\n\n    public static void pexexc() throws IOException {\n        String[] cmds = {\"/bin/sh\", \"-c\", \"ls\"}; // 只能数组形式\n        Process pb = new ProcessBuilder(cmds).start();\n        BufferedReader Reader = new BufferedReader(new InputStreamReader(pb.getInputStream()));\n        String line;\n        while ((line = Reader.readLine()) != null) System.out.println(line);\n    }\n\n    public static void main(String[] args) throws IOException {\n        rexec();\n        pexexc();\n    }\n\n}\n```\n\n这两个方法的主要区别在于Runtime.getRuntime.exec是静态方法，而ProcessBuilder().start不是静态方法，这在strust2中构造payload，是很有用的。\n\n## Java Bean和Factory概念\n\n**JavaBeans**：Java中一种**特殊的类**，可以将多个对象封装到一个对象（bean）中。特点是可序列化，提供无参构造器，提供getter方法和setter方法访问对象的属性。名称中的“Bean”是用于Java的可重用软件组件的惯用叫法。\n\n```java\npackage com.manba.demo; \npublic class SimpleBean{  \n    private String name;  \n    private int age;  \n    public void setName(String name){  \n        this.name = name;  \n    }  \n    public void setAge(int age){  \n        this.age = age;  \n    }  \n    public String getName(){  \n        return this.name;  \n    }  \n    public int getAge(){  \n        return this.age;  \n    }  \n}  \n```\n\n**总结如下：**\n\n1. 所有的类必须声明为public \n\n2. 所有属性为private\n3. 提供默认构造方法\n4. 提供getter和setter\n5. 实现serializable接口\n\n**Java Factory定义**：定义一个创建对象的接口，但让实现这个接口的类来决定实例化哪个类，工厂方法让类的实例化推迟到了子类中进行，它属于创建类型。\n\n```\n通俗理解与做法：\n\t\t定义一个抽象类或者接口来当规范工厂，它是一个只声明方法叫什么名字不实现方法的内容的一个规范类；\n  \t定义具体工厂实现或者继承规范工厂，然后重写规范工厂中定义的方法，在该方法中生产属于自己工厂的对象;\n  \t使用的时候，new工厂的时候是具体工厂给规范工厂进行赋值。即=号左边是规范工厂类型，右边是具体工厂类型，想获哪个具体工厂生产的对象就使用哪个具体工厂类型，最后利用对象调用方法来获取具体工厂生产的;\n\n注意点：\n\t\t要有一个规范工厂，该工厂只负责声明方法叫什么名字，不实现方法的内容;\n    每一个具体工厂都要继承或者实现规范工厂，重写它的方法，在方法中生产自己工厂的对象;\n    使用的时候一定要具体工厂给规范工厂进行赋值;\n```\n\n代码案例：\n\n```java\n//StandardFactory----规范工厂      \n//SpecificFactory----具体工厂       \npackage com.manba.demo;\n\npublic class Product {\n    interface StandardFactory {\n        public Product createProduct();\t\t//声明了方法叫这个名字\n    }\n\n    static class SpecificFactory implements StandardFactory {\n        @Override\n        public Product createProduct() {\t//具体工厂实现规范工厂并重写它的方法生产属于工厂的对象\n            return new Product();         //这是属于该具体工厂生产的对象\n        }\n    }\n\n    public static class Client {\n        public static void main(String[] args) {\n            StandardFactory factory = new SpecificFactory();\n            Product prodect = factory.createProduct();\n        }\n    }\n}\n```\n\n## Java Maven\n\nMaven 翻译为\"专家\"、\"内行\"，是 Apache 下的一个纯 Java 开发的开源项目。基于项目对象模型（缩写：POM）概念，Maven利用一个中央信息片断能管理一个项目的构建、报告和文档等步骤。Maven 是一个项目管理工具，可以对 Java 项目进行构建、依赖管理。\n\nPOM( Project Object Model，项目对象模型 ) 是 Maven 工程的基本工作单元，是一个XML文件，包含了项目的基本信息，用于描述项目如何构建，声明项目依赖，等等。执行任务或目标时，Maven 会在当前目录中查找 POM。它读取 POM，获取所需的配置信息，然后执行目标。\n\nPOM 中可以指定以下配置：\n\n- 项目依赖\n- 插件\n- 执行目标\n- 项目构建 profile\n- 项目版本\n- 项目开发者列表\n- 相关邮件列表信息\n\n**Maven 参数**\n\n-D 传入属性参数 \n-P 使用pom中指定的配置 \n-e 显示maven运行出错的信息 \n-o 离线执行命令,即不去远程仓库更新包 \n-X 显示maven允许的debug信息 \n-U 强制去远程参考更新snapshot包 \n其他参数可以通过mvn help 获取\n\n**1、mvn clean** \n\n说明: 清理项目生产的临时文件,一般是模块下的target目录\n\n**2、mvn package** \n\n说明: 项目打包工具,会在模块下的target目录生成jar或war等文件，如下运行结果\n\n**3、mvn test** \n\n说明: 测试命令,或执行src/test/java/下junit的测试用例\n\n**4、mvn install** \n\n说明: 模块安装命令 将打包的的jar/war文件复制到你的本地仓库中，供其他模块使用。 -Dmaven.test.skip=true 跳过测试(同时会跳过test compile)\n\n**5、mvn deploy** \n\n说明: 发布命令 将打包的文件发布到远程参考,提供其他人员进行下载依赖 ,一般是发布到公司的私服\n\n**mvn 快速构建java项目命令**\n\n```xml\nmvn archetype:generate -DgroupId=com.companyname.bank -DartifactId=consumerBanking -DarchetypeArtifactId=maven-archetype-quickstart -DinteractiveMode=false\n```\n\n**mvn 快速构建web项目**\n\n```xml\nmvn archetype:generate -DgroupId=com.companyname.automobile -DartifactId=trucks -DarchetypeArtifactId=maven-archetype-webapp  -DinteractiveMode=false\n```\n\nMaven内容很多，这边给大家介绍下概念，以及最基本用法，详细知识点大家可以移步到https://www.runoob.com/maven/maven-tutorial.html学习。\n\n## IDEA调试远程调试\n\n**配置tomcat调试模式**\n\ndockerfile配置样例，tomcat以调试模式打开\n\n```dockerfile\nFROM vulhub/tomcat:8.5\n\nMAINTAINER phithon <root@leavesongs.com>\n\nUSER root\nRUN set -ex \\\n    && rm -rf /usr/local/tomcat/webapps/* \\\n    && chmod a+x /usr/local/tomcat/bin/*.sh\nCOPY S2-001.war /usr/local/tomcat/webapps/ROOT.war\nENV JPDA_ADDRESS 5005\nENV JPDA_TRANSPORT dt_socket\nCMD [\"catalina.sh\", \"jpda\", \"run\"]\nEXPOSE 8080\nEXPOSE 5005\n```\n\ndocker-compose.yml配置样例\n\n```dockerfile\nversion: '2'\nservices:\n struts2:\n   build: .\n   ports:\n    - \"8080:8080\"\n    - \"5005:5005\"\n```\n\n然后docker-compose up -d就启动tomcat的调试模式\n\n**配置IDEA，连接远程服务器**\n\n点击Edit Configurations\n\n![](/images/a1/2.png)\n\n配置Remote\n\n![](/images/a1/3.png)\n\n点击debug，连接成功显示如下所示内容\n\n![](/images/a1/4.png)\n\n**参考：**\n\nhttps://www.cnblogs.com/coprince/p/8603492.html\n\nhttps://segmentfault.com/a/1190000020248225?utm_source=tag-newest\n\nhttps://www.runoob.com/maven/maven-tutorial.html\n\nhttps://blog.csdn.net/belvine/article/details/89552524"}]