[{"title":"JAVA反射与动态代理","url":"/2019/11/28/JAVA反射与动态代理/","content":"# JAVA反射\n\n## 什么是Java反射\n\n反射是Java的特征之一，是一种**间接操作目标对象的机制**，核心是JVM在运行的时候才动态加载类，并且对于任意一个类，都能够知道这个类的所有属性和方法，调用方法/访问属性，不需要提前在编译期知道运行的对象是谁，他允许运行中的Java程序获取类的信息，并且可以操作类或对象内部属性。程序中对象的类型一般都是在编译期就确定下来的，而当我们的程序在运行时，可能需要动态的加载一些类，这些类因为之前用不到，所以没有加载到jvm，这时，使用Java反射机制可以在**运行期动态的创建对象并调用其属性**，它是在运行时根据需要才加载。\n\n## 反射的原理\n\n![](/images/a2/1.png)\n\n## 反射的优缺点\n\n**优点：**使用反射，我们就可以在运行时获得类的各种内容，进行反编译，对于Java这种先编译再运行的语言，能够让我们很方便的创建灵活的代码，这些代码可以在运行时装配，无需在组件之间进行源代码的链接，更加容易实现面向对象。\n\n**缺点：**\n\n1. 反射会消耗一定的系统资源，因此，如果不需要动态地创建一个对象，那么就不需要用反射；\n2. 反射调用方法时可以忽略权限检查，因此可能会破坏封装性而导致安全问题。\n\n## 反射的用途\n\n1. 反编译：.class-->.java\n2. 通过反射机制访问java对象的属性，方法，构造方法等\n3. 当我们在使用IDEA时，当我们输入一个对象或者类，并想调用他的属性和方法是，一按点号，编译器就会自动列出他的属性或者方法，这里就是用到反射。\n4. 反射最重要的用途就是开发各种通用框架。比如很多框架（Spring）都是配置化的（比如通过XML文件配置Bean），为了保证框架的通用性，他们可能需要根据配置文件加载不同的类或者对象，调用不同的方法，这个时候就必须使用到反射了，运行时动态加载需要的加载的对象。\n\n## 反射机制常用的类\n\n```Java\nJava.lang.reflect.Constructor;\nJava.lang.reflect.Field;\nJava.lang.reflect.Method;\nJava.lang.reflect.Modifier;\n```\n\n## 反射的基本使用\n\n- Object.getclass()   //需要创建对象\n\n- Object.class    //需要导入对应的类包\n\n- Class.forName    //最常用\n\n**代码实例：**\n\n1、创建一个需要被反射的测试类\n\n```java\nimport static java.lang.System.out;\nimport java.lang.String;\n\npublic class User {\n    private String username;\n    public String interest;\n\n    public User() {\n        ;\n    }\n\n    private User(String name) {\n        System.out.println(\"init.\");\n    }\n\n    public String getUsername(){\n        return username;\n    }\n\n    public void setUsername(String username){\n        this.username = username;\n    }\n\n    public String getInterest(){\n        return interest;\n    }\n\n    public void setInterest(String interest){\n        this.interest = interest;\n    }\n\n    public static void main(String args[]) {\n        User userinfo = new User();\n        userinfo.setUsername(\"xiaoming\");\n        out.println(userinfo.getUsername());\n    }\n}\n```\n\n2、反射调用User类\n\n```java\nimport java.lang.reflect.*;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.System;\nimport java.lang.String;\n\npublic class Reflect {\n    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {\n        Class clazz = Class.forName(\"User\"); //包路径，这里测试写在同目录\n\n        System.out.println(\"===获取公共的构造函数===\");\n        Constructor[] constructors = clazz.getConstructors();\n        for (Constructor constructor: constructors)\n            System.out.println(constructor);\n\n        System.out.println(\"===获取所有的构造函数===\");\n        Constructor[] declaredConstructors = clazz.getDeclaredConstructors();\n        for (Constructor constructor: declaredConstructors)\n            System.out.println(constructor);\n\n        System.out.println(\"===获取公共的属性===\");\n        Field[] fields = clazz.getFields();\n        for (Field field: fields)\n            System.out.println(field);\n\n        System.out.println(\"===获取所有的属性===\");\n        Field[] declaredFields = clazz.getDeclaredFields();\n        for (Field field: declaredFields)\n            System.out.println(\"ALL: \" + field);\n        \n        System.out.println(\"===获取特定的函数===\");\n        Method method = clazz.getDeclaredMethod(\"setUsername\", String.class);\n        System.out.println(method);\n\n        //赋值操作\n        Object obj = clazz.getConstructor().newInstance();\n        Object invoke = method.invoke(obj, new String[]{\"我是科比\"});\n\n        System.out.println(\"===测试===\");\n        String name= (String) clazz.getDeclaredMethod(\"getUsername\").invoke(obj);\n        System.out.println(name);\n    }\n}\n```\n\n![](/images/a2/2.png)\n\n这个只做了部分的测试，get\\_系列方法的是获取公用，getDeclared\\_系列方法获取所有，get_(参数)系列获取特定的。如果需要查看所有的方法，可以查看官方文档，或者IDEA跟进Class.java文件查看。这边需要注意的是 method.invoke(obj, args) ，**如果method是静态方法，obj是可以省略的。**\n\n# JAVA动态代理\n\n## 代理模式简介\n\n代理模式是一种常用的设计模式。代理模式为其对象提供了一种代理以控制对这个对象的访问。代理模式可以将主要业务与次要业务进行松耦合的组装。根据代理类的创建时机和创建方式的不同，可以将其分为静态代理和动态代理两种形式：\n\n- 在程序运行前就已经存在的编译好的代理类是为静态代理，\n- 在程序运行期间根据需要动态创建代理类及其实例来完成具体的功能是为动态代理。\n\n## 动态代理简介\n\n对代理模式而言，一般来说，具体主题类与其代理类是一一对应的，这也是静态代理的特点。但是，也存在这样的情况：有N个主题类，但是代理类中的“预处理、后处理”都是相同的，仅仅是调用主题不同。那么，若采用静态代理，必然需要手动创建N个代理类，这显然让人相当不爽。动态代理则可以简单地为各个主题类分别生成代理类，**共享“预处理，后处理”功能**，这样可以大大减小程序规模，这也是动态代理的一大亮点。\n\n在动态代理中，代理类是在运行时期生成的。因此，相比静态代理，动态代理可以很方便地对委托类的相关方法进行统一增强处理，如添加方法调用次数、添加日志功能等等。\n\n### JDK动态代理机制的相关类与接口\n\n**java.lang.reflect.Proxy：**该类用于动态生成代理类，只需传入被监控对象隶属的类文件在内存中真实地址、被监控对象隶属的类文件实现接口以及InvocationHandler通知对象便可为目标接口生成代理类及代理对象。\n\n```\n// 方法 1: 该方法用于获取指定代理对象所关联的InvocationHandler static InvocationHandler\ngetInvocationHandler(Object proxy)\n\n// 方法 2：该方法用于获取关联于指定类装载器和一组接口的动态代理类的类对象 static Class\ngetProxyClass(ClassLoader loader, Class[] interfaces)\n\n// 方法 3：该方法用于判断指定类是否是一个动态代理类 static boolean isProxyClass(Class cl)\n\n// 方法 4：该方法用于为指定类装载器、一组接口及调用处理器生成动态代理类实例 static Object\nnewProxyInstance(ClassLoader loader, Class[] interfaces,\nInvocationHandler h)\n```\n\n**java.lang.reflect.InvocationHandler：**该接口包含一个invoke方法，通过该方法实现对委托类的代理的访问，是代理类完整逻辑的集中体现，包括要切入的增强逻辑和进行反射执行的真实业务逻辑。\n\n```\nObject invoke(Object proxy, Method method, Object[] args)\n```\n\n该方法是代理类完整逻辑的集中体现。在被监控行为将要执行时，会被JVM拦截。被监控行为和行为实现方法会被作为参数输送invoke，通常通过反射完成对具体角色业务逻辑的调用，并对其进行增强。\n\n- 第一个参数既是代理类实例。\n- 第二个参数是被调用的方法对象。\n- 第三个方法是调用参数。\n\n**java.lang.ClassLoader：**类加载器类，负责将类的字节码装载到Java虚拟机中并为其定义类对象，然后该类才能被使用。Proxy静态方法生成动态代理类同样需要通过类加载器来进行加载才能使用，它与普通类的唯一区别就是其字节码是由JVM在运行时动态生成的而非预存在于任何一个.class 文件中。JDK动态代理使用步骤\n\n### JDK动态代理的一般步骤\n\n1、创建被代理的接口和类；\n\n2、实现InvocationHandler接口，对目标接口中声明的所有方法进行统一处理；\n\n3、调用Proxy的静态方法，创建代理类并生成相应的代理对象；\n\n4、使用代理。\n\n### 生活案例\n\n**饭前便后要洗手**\n一、分析出主要业务和次要业务\n【主要业务】：吃饭，上厕所\n【次要业务】：洗手\n\n二、JDK代理模式实现\n\n1. 接口角色： 定义所有需要被监听行为\n2. 接口实现类：中国人、印度人\n3. 通知类：\n   - 次要业务进行具体实现\n   - 通知JVM，当前被拦截的主要业务方法与次要业务方法应该如何绑定执行\n\n4. 监控对象（代理对象）\n   - 被监控实例对象 需要被监控的行为\n   - 具体通知类实例对象\n\n### 代码实现\n\n1、定义接口类\n\n```java\npublic interface BaseService {\n    void eat();\n    void wc();\n}\n```\n\n2、编写接口的实现类，即具有某些行为的实体\n\n```java\npublic class Person implements BaseService {\n\n    @Override\n    public void eat() { //主要业务，代理模式要求开发人员只关心主要业务\n        System.out.println(\"吃饭.\");\n    }\n\n    @Override\n    public void wc() {\n        System.out.println(\"上厕所.\");\n    }\n}\n```\n\n3、创建通知类\n\n```java\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\n\npublic class Invocation implements InvocationHandler {\n\n    private BaseService obj;//具体被监控对象\n\n    public Invocation(BaseService param){\n        this.obj = param;\n    }\n\n    /*\n     *\n     *  invoke方法：在被监控行为将要执行时，会被JVM拦截\n     *             被监控行为和行为实现方会被作为参数输送invoke\n     *             ****\n     *             通知JVM,这个被拦截方法是如何与当前次要业务方法绑定实现\n     *  invoke方法三个参数\n     *\n     *           int v= 小明.eat();//JVM拦截\n     *            eat方法封装为Mehtod类型对象\n     *            eat方法运行时接受所有的实参封装到Object[]\n     *            将负责监控小明的代理对象作为invoke方法第一个参数\n     *\n     */\n    @Override\n    public Object invoke(Object proxy, Method method, Object[] params) throws Throwable {\n        //1.局部变量，接受主要业务方法执行完毕后返回值\n        Object value;\n        //2.确认当前被拦截行为\n        String methodName= method.getName();\n        //3.根据被拦截行为不同，决定主要业务和次要业务如何绑定执行\n        if(\"eat\".equals(methodName)){//饭前要洗手\n            wash();                            //洗手\n            value=method.invoke(this.obj, params);   //吃饭\n        }else{//便后要洗手\n            value=method.invoke(this.obj, params);\n            wash();\n        }\n        return value; //返回被拦截方法，需要调用地方\n    }\n\n    //次要业务\n    public void wash(){\n        System.out.println(\"-----洗手----\");\n    }\n}\n```\n\n4、创建监控对象，通过Proxy类的静态方法newProxyInstance创建代理对象\n\n```java\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Proxy;\n\nclass ProxyFactory {\n    /*\n     *\n     *  JDK动态代理模式下，代理对象的数据类型\n     *  应该由监控行为来描述\n     *  参数： Class文件，监控类\n     */\n    public static BaseService Builder(Class classFile) throws Exception {\n\n        //1.创建被监控实例对象\n        BaseService obj = (BaseService) classFile.newInstance();\n        //2.创建一个通知对象 用接口来描述\n        InvocationHandler adviser = new Invocation(obj);\n        //3.向JVM申请负责监控obj对象指定行为的监控对象（代理对象）\n        /*\n         *  loader:被监控对象隶属的类文件在内存中真实地址\n         *  interfaces:被监控对象隶属的类文件实现接口\n         *  adviser：监控对象发现小明要执行被监控行为，应该由哪一个通知对象进行辅助\n         */\n        BaseService $proxy = (BaseService) Proxy.newProxyInstance(\n                obj.getClass().getClassLoader(),\n                obj.getClass().getInterfaces(),\n                adviser);\n        return $proxy;\n    }\n}\n```\n\n5、测试\n\n```java\nimport java.lang.*;\n\npublic class Test {\n    public static void main(String[] args) throws Exception {\n        BaseService mike= ProxyFactory.Builder(Person.class);\n        mike.eat();\n        System.out.println(\"================\");\n        mike.wc();\n    }\n}\n```\n\n![](/images/a2/3.png)\n\n\n\n**参考：**\n\nhttps://blog.csdn.net/a745233700/article/details/82893076\n\nhttps://blog.csdn.net/vae1314chuanchen/article/details/87974728\n\nhttps://blog.csdn.net/justloveyou_/article/details/79407248\n\nhttps://blog.csdn.net/vae1314chuanchen/article/details/78266299","tags":["JAVA","安全"],"categories":["JAVA安全教程"]},{"title":"JAVA基础","url":"/2019/11/27/JAVA基础/","content":"# 简介\n\n本篇是整个java安全学习系列的基础篇，这个系列篇章我会把我的整个java安全学习过程进行一个总结。至于为什么想写这个系列文章，是因为当时听了小伙伴的分享中提到“21小时可以入门任何课程”，看了他整理的学习导图，深受启发。所以，我打算把过去的和新学习的东西，完整的、系统的归纳总结出来，做到温故而知新。\n\n# 学习流程\n\n![](/images/a1/1.png)\n\n这个是我整理的java的学习路线图，每个人可能有不同的理解，大家可以自己动手进行自己的学习规划。并且学习过程是动态的，可能在学习总结过程中，我会修增某些模块。本篇我将对第一部分-基础，进行讲解。\n\n# java基础\n\n这边讨论的基础，不是java的基础语法，这部分自己可以快速入门学习。我要讲的部分，是java的一些特性，或者比较重要的语法，在看代码中或者分析payload经常用到的。这部分是我在实践过程中觉得难点和重点，每个人的理解方法不同，所以并不适用所有人的学习，不过理解以下概念方法对于java安全学习是有帮助的，这点可以肯定。\n\n## 基本语法\n\n### 泛类型\n\n泛型，即“参数化类型”。一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢？\n\n顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。\n\n泛型的本质是为了参数化类型（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型）。也就是说在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。\n\n最典型的泛型类应用就是各种容器类，如：List、Set、Map。自己定义的泛型类形式如下：\n\n```java\n//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型\n//在实例化泛型类时，必须指定T的具体类型\npublic class Generic<T>{ \n    //key这个成员变量的类型为T,T的类型由外部指定  \n    private T key;\n\n    public Generic(T key) { //泛型构造方法形参key的类型也为T，T的类型由外部指定\n        this.key = key;\n    }\n\n    public T getKey(){ //泛型方法getKey的返回值类型为T，T的类型由外部指定\n        return key;\n    }\n}\n```\n\n更多泛型基本知识内容可参考：[https://www.cnblogs.com/coprince/p/8603492.html](https://www.cnblogs.com/coprince/p/8603492.html)\n\n### 对象类型、基本类型\n\nJava中的对象分两种类型：**基本类型和非基本类型（对象类型）。**\n\n基本类型就是那些最常用的类型，例如：boolean/char/byte/short/int/long/float/double，这些类型有个特点，就是变量直接存储值。\n\n除了基本类型之外的都是非基本类型了。非基本类型有个显著特点就是初始化的时候一般需要使用new来创建一个对象，所以非基本类型也叫非基本类型。例如:String name=new String(Tom);。非基本类型跟基本类型的本质区别，在于**非基本类型变量存储的不是值，而是引用。**\n\n## 命令执行的方法\n\njava命令执行，主要有两种方法Runtime.getRuntime().exec(cmd) 和ProcessBuilder(cmd).start，实例如下：\n\n```java\npackage com.manba.demo;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class CmdTest {\n    public static void rexec() throws IOException {\n        String cmds = \"/bin/sh -c pwd\"; // 也可以数组形式\n        Process process = Runtime.getRuntime().exec(cmds);\n        BufferedReader Reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n        String line;\n        while ((line = Reader.readLine()) != null) System.out.println(line);\n    }\n\n    public static void pexexc() throws IOException {\n        String[] cmds = {\"/bin/sh\", \"-c\", \"ls\"}; // 只能数组形式\n        Process pb = new ProcessBuilder(cmds).start();\n        BufferedReader Reader = new BufferedReader(new InputStreamReader(pb.getInputStream()));\n        String line;\n        while ((line = Reader.readLine()) != null) System.out.println(line);\n    }\n\n    public static void main(String[] args) throws IOException {\n        rexec();\n        pexexc();\n    }\n\n}\n```\n\n这两个方法的主要区别在于Runtime.getRuntime.exec是静态方法，而ProcessBuilder().start不是静态方法，这在strust2中构造payload，是很有用的。\n\n## Java Bean和Factory概念\n\n**JavaBeans**：Java中一种**特殊的类**，可以将多个对象封装到一个对象（bean）中。特点是可序列化，提供无参构造器，提供getter方法和setter方法访问对象的属性。名称中的“Bean”是用于Java的可重用软件组件的惯用叫法。\n\n```java\npackage com.manba.demo; \npublic class SimpleBean{  \n    private String name;  \n    private int age;  \n    public void setName(String name){  \n        this.name = name;  \n    }  \n    public void setAge(int age){  \n        this.age = age;  \n    }  \n    public String getName(){  \n        return this.name;  \n    }  \n    public int getAge(){  \n        return this.age;  \n    }  \n}  \n```\n\n**总结如下：**\n\n1. 所有的类必须声明为public \n\n2. 所有属性为private\n3. 提供默认构造方法\n4. 提供getter和setter\n5. 实现serializable接口\n\n**Java Factory定义**：定义一个创建对象的接口，但让实现这个接口的类来决定实例化哪个类，工厂方法让类的实例化推迟到了子类中进行，它属于创建类型。\n\n```\n通俗理解与做法：\n        定义一个抽象类或者接口来当规范工厂，它是一个只声明方法叫什么名字不实现方法的内容的一个规范类；\n    定义具体工厂实现或者继承规范工厂，然后重写规范工厂中定义的方法，在该方法中生产属于自己工厂的对象;\n    使用的时候，new工厂的时候是具体工厂给规范工厂进行赋值。即=号左边是规范工厂类型，右边是具体工厂类型，想获哪个具体工厂生产的对象就使用哪个具体工厂类型，最后利用对象调用方法来获取具体工厂生产的;\n\n注意点：\n        要有一个规范工厂，该工厂只负责声明方法叫什么名字，不实现方法的内容;\n    每一个具体工厂都要继承或者实现规范工厂，重写它的方法，在方法中生产自己工厂的对象;\n    使用的时候一定要具体工厂给规范工厂进行赋值;\n```\n\n代码案例：\n\n```java\n//StandardFactory----规范工厂      \n//SpecificFactory----具体工厂       \npackage com.manba.demo;\n\npublic class Product {\n    interface StandardFactory {\n        public Product createProduct();     //声明了方法叫这个名字\n    }\n\n    static class SpecificFactory implements StandardFactory {\n        @Override\n        public Product createProduct() {    //具体工厂实现规范工厂并重写它的方法生产属于工厂的对象\n            return new Product();         //这是属于该具体工厂生产的对象\n        }\n    }\n\n    public static class Client {\n        public static void main(String[] args) {\n            StandardFactory factory = new SpecificFactory();\n            Product prodect = factory.createProduct();\n        }\n    }\n}\n```\n\n## Java Maven\n\nMaven 翻译为\"专家\"、\"内行\"，是 Apache 下的一个纯 Java 开发的开源项目。基于项目对象模型（缩写：POM）概念，Maven利用一个中央信息片断能管理一个项目的构建、报告和文档等步骤。Maven 是一个项目管理工具，可以对 Java 项目进行构建、依赖管理。\n\nPOM( Project Object Model，项目对象模型 ) 是 Maven 工程的基本工作单元，是一个XML文件，包含了项目的基本信息，用于描述项目如何构建，声明项目依赖，等等。执行任务或目标时，Maven 会在当前目录中查找 POM。它读取 POM，获取所需的配置信息，然后执行目标。\n\nPOM 中可以指定以下配置：\n\n- 项目依赖\n- 插件\n- 执行目标\n- 项目构建 profile\n- 项目版本\n- 项目开发者列表\n- 相关邮件列表信息\n\n**Maven 参数**\n\n-D 传入属性参数 \n-P 使用pom中指定的配置 \n-e 显示maven运行出错的信息 \n-o 离线执行命令,即不去远程仓库更新包 \n-X 显示maven允许的debug信息 \n-U 强制去远程参考更新snapshot包 \n其他参数可以通过mvn help 获取\n\n**1、mvn clean** \n\n说明: 清理项目生产的临时文件,一般是模块下的target目录\n\n**2、mvn package** \n\n说明: 项目打包工具,会在模块下的target目录生成jar或war等文件，如下运行结果\n\n**3、mvn test** \n\n说明: 测试命令,或执行src/test/java/下junit的测试用例\n\n**4、mvn install** \n\n说明: 模块安装命令 将打包的的jar/war文件复制到你的本地仓库中，供其他模块使用。 -Dmaven.test.skip=true 跳过测试(同时会跳过test compile)\n\n**5、mvn deploy** \n\n说明: 发布命令 将打包的文件发布到远程参考,提供其他人员进行下载依赖 ,一般是发布到公司的私服\n\n**mvn 快速构建java项目命令**\n\n```xml\nmvn archetype:generate -DgroupId=com.companyname.bank -DartifactId=consumerBanking -DarchetypeArtifactId=maven-archetype-quickstart -DinteractiveMode=false\n```\n\n**mvn 快速构建web项目**\n\n```xml\nmvn archetype:generate -DgroupId=com.companyname.automobile -DartifactId=trucks -DarchetypeArtifactId=maven-archetype-webapp  -DinteractiveMode=false\n```\n\nMaven内容很多，这边给大家介绍下概念，以及最基本用法，详细知识点大家可以移步到https://www.runoob.com/maven/maven-tutorial.html学习。\n\n## IDEA调试远程调试\n\n**配置tomcat调试模式**\n\ndockerfile配置样例，tomcat以调试模式打开\n\n```dockerfile\nFROM vulhub/tomcat:8.5\n\nMAINTAINER phithon <root@leavesongs.com>\n\nUSER root\nRUN set -ex \\\n    && rm -rf /usr/local/tomcat/webapps/* \\\n    && chmod a+x /usr/local/tomcat/bin/*.sh\nCOPY S2-001.war /usr/local/tomcat/webapps/ROOT.war\nENV JPDA_ADDRESS 5005\nENV JPDA_TRANSPORT dt_socket\nCMD [\"catalina.sh\", \"jpda\", \"run\"]\nEXPOSE 8080\nEXPOSE 5005\n```\n\ndocker-compose.yml配置样例\n\n```dockerfile\nversion: '2'\nservices:\n struts2:\n   build: .\n   ports:\n    - \"8080:8080\"\n    - \"5005:5005\"\n```\n\n然后docker-compose up -d就启动tomcat的调试模式\n\n**配置IDEA，连接远程服务器**\n\n点击Edit Configurations\n\n![](/images/a1/2.png)\n\n配置Remote\n\n![](/images/a1/3.png)\n\n点击debug，连接成功显示如下所示内容\n\n![](/images/a1/4.png)\n\n**参考：**\n\nhttps://www.cnblogs.com/coprince/p/8603492.html\n\nhttps://segmentfault.com/a/1190000020248225?utm_source=tag-newest\n\nhttps://www.runoob.com/maven/maven-tutorial.html\n\nhttps://blog.csdn.net/belvine/article/details/89552524\n","tags":["JAVA","安全"],"categories":["JAVA安全教程"]}]