<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>JAVA框架介绍 | he1m4n6a blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="什么是框架在编程领域，软件框架是指一种抽象形式，它提供了一个具有通用功能的软件，这些功能可以由使用者编写代码来有选择的进行更改，从而提供服务于特定应用的软件。软件框架提供了一种标准的方式来构建并部署应用。">
<meta name="keywords" content="JAVA,安全">
<meta property="og:type" content="article">
<meta property="og:title" content="JAVA框架介绍">
<meta property="og:url" content="https:&#x2F;&#x2F;he1m4n6a.git.io&#x2F;2019&#x2F;12&#x2F;04&#x2F;JAVA%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D&#x2F;index.html">
<meta property="og:site_name" content="he1m4n6a blog">
<meta property="og:description" content="什么是框架在编程领域，软件框架是指一种抽象形式，它提供了一个具有通用功能的软件，这些功能可以由使用者编写代码来有选择的进行更改，从而提供服务于特定应用的软件。软件框架提供了一种标准的方式来构建并部署应用。">
<meta property="og:locale" content="zh">
<meta property="og:image" content="https:&#x2F;&#x2F;he1m4n6a.git.io&#x2F;images&#x2F;a3&#x2F;1.png">
<meta property="og:image" content="https:&#x2F;&#x2F;he1m4n6a.git.io&#x2F;images&#x2F;a3&#x2F;2.png">
<meta property="og:image" content="https:&#x2F;&#x2F;he1m4n6a.git.io&#x2F;images&#x2F;a3&#x2F;3.png">
<meta property="og:image" content="https:&#x2F;&#x2F;he1m4n6a.git.io&#x2F;images&#x2F;a3&#x2F;4.png">
<meta property="og:image" content="https:&#x2F;&#x2F;he1m4n6a.git.io&#x2F;images&#x2F;a3&#x2F;5.png">
<meta property="og:image" content="https:&#x2F;&#x2F;he1m4n6a.git.io&#x2F;images&#x2F;a3&#x2F;6.png">
<meta property="og:updated_time" content="2019-12-04T12:58:24.447Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https:&#x2F;&#x2F;he1m4n6a.git.io&#x2F;images&#x2F;a3&#x2F;1.png">
  
    <link rel="alternate" href="/atom.xml" title="he1m4n6a blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">
  
  <link rel="stylesheet" href="/css/style.css">
  
    <link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">
  
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">he1m4n6a blog</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">路漫漫其修远兮，吾将上下而求索</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
          <a class="main-nav-link" href="/about">About</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://he1m4n6a.git.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-JAVA框架介绍" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/12/04/JAVA%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D/" class="article-date">
  <time class="dt-published" datetime="2019-12-04T12:54:28.000Z" itemprop="datePublished">2019-12-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/JAVA%E5%AE%89%E5%85%A8%E6%95%99%E7%A8%8B/">JAVA安全教程</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      JAVA框架介绍
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="什么是框架"><a href="#什么是框架" class="headerlink" title="什么是框架"></a>什么是框架</h1><p>在编程领域，软件框架是指一种抽象形式，它提供了一个具有通用功能的软件，这些功能可以由使用者编写代码来有选择的进行更改，从而提供服务于特定应用的软件。软件框架提供了一种标准的方式来构建并部署应用。</p>
<a id="more"></a>
<h1 id="Struts2框架介绍"><a href="#Struts2框架介绍" class="headerlink" title="Struts2框架介绍"></a>Struts2框架介绍</h1><p>直接上图</p>
<p><img src="/images/a3/1.png" alt=""></p>
<p>Struts2框架最主要的两个组件就是过滤器和拦截器，其中用到的思想就是上一章的反射和动态代理。</p>
<p><strong>工作流程：</strong></p>
<ol>
<li>客户端浏览器发送HTTP请求到Web应用</li>
<li>Web容器将请求传递到标准ActionContextCleanUp过滤器以消除属性，而不让后续过滤器清楚，以延长Action中属性（包括自定义属性）的生命周期。</li>
<li>再经过如stimesh等其他过滤器后，请求传递给StrutsPrepareAndExecuteFilter核心控制器</li>
<li>StrutsPrepareAndExecuteFilter调用ActionMapper（Action映射器）确定调用哪个Action，再将控制权转移给ActionProxy代理</li>
<li>ActionProxy代理调用配置管理器ConfigurationManager从配置文件struts.xml中读取配置信息，然后创建ActionInvocation对象</li>
<li>ActionInvocation在调用拦截器链中的拦截器后再调用Action，根据Action返回的结果字符串查找对应的Result</li>
<li>Result调用视图模板，再以相反的顺序执行拦截器链，返回HTTP响应</li>
<li>HTTP响应以相反的顺序返回给核心控制器StrutsPrepareAndExecuteFilter以及其他web.xml中定义的过滤器，最终返回给客户端</li>
</ol>
<p>struts2可以说是上一代的web框架，现在基本很少互联网会使用strust2，一来安全问题较多，二来现在有更方便的springboot框架，基本可以说被遗弃了。但是作为安全学习，我们还是有必要了解下基本的框架体系，如果想要深入的学习，可以网上自己搜索，作为曾经火遍大江南北的web框架，网上资料还是很多的。</p>
<h1 id="Spring框架介绍"><a href="#Spring框架介绍" class="headerlink" title="Spring框架介绍"></a>Spring框架介绍</h1><p>spring是一个一站式开发框架集，功能十分强大，就像一个大家族，有众多衍生产品，例如：springboot、springcloud、springsecurity等等。但他们都是基于spring的ioc和aop，<strong>ioc提供了依赖注入的容器，aop解决了面向切面的编程</strong>，然后在这两者的基础上实现了其他衍生产品的高级功能。</p>
<h2 id="什么是IOC"><a href="#什么是IOC" class="headerlink" title="什么是IOC"></a>什么是IOC</h2><p>控制反转（Inversion of Control）不是技术，是一种<strong>设计思想</strong>。所谓控制反转是指，本来被调用者的实例是由调用者来创建的，这样的缺点是耦合性太强，IOC则是统一交给spring来管理创建，将对象交给容器管理，你只需要在spring配置文件总配置相应的bean，以及设置相关的属性，让spring容器来生成类的实例对象以及管理对象。在spring容器启动的时候，spring会把你在配置文件中配置的bean都初始化好，然后在你需要调用的时候，就把它已经初始化好的那些bean分配给你需要调用这些bean的类。 </p>
<p>传统设计</p>
<p><img src="/images/a3/2.png" alt=""></p>
<p>ioc思想</p>
<p><img src="/images/a3/3.png" alt=""></p>
<h2 id="什么是AOP"><a href="#什么是AOP" class="headerlink" title="什么是AOP"></a>什么是AOP</h2><p>面向切面编程（Aspect Oriented Programming）它与 OOP( Object-Oriented Programming, 面向对象编程) 相辅相成，提供了与 OOP 不同的抽象软件结构的视角来思考程序的结构，通过这种方式弥补面向对象编程(Object Oriented Programming)的不足。除了类以外，AOP提供了切面，切面对关注点进行模块化，例如横切多个类型和对象的事务管理（这些关注点术语通常称作横切(crosscutting)关注点）。Spring AOP是Spring的一个重要组件，但是Spring IOC并不依赖于Spring AOP，这意味着你可以自由选择是否使用AOP，AOP提供了强大的中间件解决方案，这使得Spring IOC更加完善。我们可以通过AOP来实现<strong>日志监听，事务管理，权限控制</strong>等等。</p>
<p><strong>概念：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">切面（Aspect）：一个关注点的模块化，这个关注点可能会横切多个对象。事务管理是J2EE应用中一个关于横切关注点的很好的例子。在Spring AOP中，切面可以使用基于模式）或者基于@Aspect注解的方式来实现。</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">连接点（Joinpoint）：在程序执行过程中某个特定的点，比如某方法调用的时候或者处理异常的时候。在Spring</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">AOP中，一个连接点总是表示一个方法的执行。</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">通知（Advice）：在切面的某个特定的连接点上执行的动作。其中包括了“around”、“before”和“after”等不同类型的通知（通知的类型将在后面部分进行讨论）。许多AOP框架（包括Spring）都是以拦截器做通知模型，并维护一个以连接点为中心的拦截器链。</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">切入点（Pointcut）：匹配连接点的断言。通知和一个切入点表达式关联，并在满足这个切入点的连接点上运行（例如，当执行某个特定名称的方法时）。切入点表达式如何和连接点匹配是AOP的核心：Spring缺省使用AspectJ切入点语法。</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">引入（Introduction）：用来给一个类型声明额外的方法或属性（也被称为连接类型声明（inter-type</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">declaration））。Spring允许引入新的接口（以及一个对应的实现）到任何被代理的对象。例如，你可以使用引入来使一个bean实现IsModified接口，以便简化缓存机制。</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">目标对象（Target Object）： 被一个或者多个切面所通知的对象。也被称做被通知（advised）对象。 既然Spring</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">AOP是通过运行时代理实现的，这个对象永远是一个被代理（proxied）对象。</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">AOP代理（AOP Proxy）：AOP框架创建的对象，用来实现切面契约（例如通知方法执行等等）。在Spring中，AOP代理可以是JDK动态代理或者CGLIB代理。</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">织入（Weaving）：把切面连接到其它的应用程序类型或者对象上，并创建一个被通知的对象。这些可以在编译时（例如使用AspectJ编译器），类加载时和运行时完成。Spring和其他纯Java AOP框架一样，在运行时完成织入。</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">通知类型：</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">前置通知（Before advice）：在某连接点之前执行的通知，但这个通知不能阻止连接点之前的执行流程（除非它抛出一个异常）。</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">后置通知（After returning advice）：在某连接点正常完成后执行的通知：例如，一个方法没有抛出任何异常，正常返回。</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">异常通知（After throwing advice）：在方法抛出异常退出时执行的通知。</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">最终通知（After (finally) advice）：当某连接点退出的时候执行的通知（不论是正常返回还是异常退出）。</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">环绕通知（Around Advice）：包围一个连接点的通知，如方法调用。这是最强大的一种通知类型。环绕通知可以在方法调用前后完成自定义的行为。它也会选择是否继续执行连接点或直接返回它自己的返回值或抛出异常来结束执行。</span></pre></td></tr></table></figure>

<p>看完了上面的理论部分知识, 相信大家还是对AOP 的概念云里雾里的, 因为 AOP 中的概念是在是太多了, 我们也不必理解的那么透彻，直接从网上找个例子说明一下 AOP 中 Aspect，Joint point，Point cut 与 Advice之间的关系。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">让我们来假设一下，从前有一个叫爪哇的小县城，在一个月黑风高的晚上，这个县城中发生了命案。 作案的凶手十分狡猾，现场没有留下什么有价值的线索。不过万幸的是，刚从隔壁回来的老王恰好在这时候无意中发现了凶手行凶的过程，但是由于天色已晚，加上凶手蒙着面，老王并没有看清凶手的面目，只知道凶手是个男性，身高约七尺五寸。 爪哇县的县令根据老王的描述，对守门的士兵下命令说: 凡是发现有身高七尺五寸的男性，都要抓过来审问。 士兵当然不敢违背县令的命令，只好把进出城的所有符合条件的人都抓了起来。</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">来让我们看一下上面的一个小故事和 AOP 到底有什么对应关系。</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">首先我们知道，在 Spring AOP 中 Joint point 指代的是所有方法的执行点，而 point cut 是一个描述信息，它修饰的是 Joint point，通过 point cut，我们就可以确定哪些 Joint point 可以被织入 Advice。 对应到我们在上面举的例子，我们可以做一个简单的类比，Joint point 就相当于 爪哇的小县城里的百姓,pointcut 就相当于 老王所做的指控，即凶手是个男性，身高约七尺五寸，而 Advice 则是施加在符合老王所描述的嫌疑人的动作: 抓过来审问。</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">为什么可以这样类比呢?</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">Joint point ： 爪哇的小县城里的百姓: 因为根据定义，Joint point 是所有可能被织入 Advice 的候选的点，在 Spring AOP中，则可以认为所有方法执行点都是 Joint point。 而在我们上面的例子中，命案发生在小县城中，按理说在此县城中的所有人都有可能是嫌疑人。</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">Pointcut ：男性，身高约七尺五寸: 我们知道，所有的方法(joint point) 都可以织入 Advice，但是我们并不希望在所有方法上都织入 Advice，而 Pointcut 的作用就是提供一组规则来匹配join point，给满足规则的 join point 添加 Advice。 同理，对于县令来说，他再昏庸，也知道不能把县城中的所有百姓都抓起来审问，而是根据凶手是个男性，身高约七尺五寸，把符合条件的人抓起来。 在这里 凶手是个男性，身高约七尺五寸 就是一个修饰谓语，它限定了凶手的范围，满足此修饰规则的百姓都是嫌疑人，都需要抓起来审问。</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">Advice ：抓过来审问，Advice 是一个动作，即一段 Java 代码，这段 Java 代码是作用于 point cut 所限定的那些 Joint point 上的。 同理，对比到我们的例子中，抓过来审问 这个动作就是对作用于那些满足 男性，身高约七尺五寸 的爪哇的小县城里的百姓。</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">Aspect:：Aspect 是 point cut 与 Advice 的组合，因此在这里我们就可以类比: “根据老王的线索，凡是发现有身高七尺五寸的男性，都要抓过来审问” 这一整个动作可以被认为是一个 Aspect。</span></pre></td></tr></table></figure>

<p>说完AOP专业名词的概念，再来说下AOP具体的。相信大家对于OOP的理解不难，就以人（people）来说，我们就可以把它看做一类对象，people有身高、体重、年龄等属性，也有跑步、吃饭、睡觉、娱乐等行为，把这些属于people的属性和行为封装在people类中，然后以统一调用的方式（创建一个people类实例对象，通过这个对象实例来调用这些属性和行为）就叫做OOP思想。</p>
<p>OOP给我们的感觉就是结构清晰，高内聚，易维护等。这些属于一种从上到下的关系（即这个类封装的所有属性和方法都是属于people的），而我们的AOP思想就是一种从左到右的关系，以切入的方式将业务逻辑功能应用到每一层结构中（可以理解为类方法，类方法也是一种对象的行为实现）。</p>
<p>举个例子，people也可以分为少年、青年、中年、和老年，这几类人除了拥有自己的属性和行为外，生活中，或许还需要去医院看病，但是医院看病这一个逻辑业务功能并不是属于哪一类，而是谁生病了，才需要到医院看病，而基于面向对象编程的思想，我们是不可能把这一个业务逻辑行为加到每一个类中的，这不符合OOP思想，而这个就是AOP所做也可以做到事情了，AOP就是把医院看病这一个业务逻辑功能抽取出来，然后动态把这个功能注入到需要的方法（或行为）中，以后，不管是谁需要看病，就到医院这个第三方机构看病（AOP就是相当于把这个第三方机构独立出来），<strong>这样从业务逻辑角度上，AOP达到了更近一步的的解耦，所以我们也称AOP是对OOP的完善和增强。</strong></p>
<p>而我们的编程中，常用到AOP的就是安全校验、日志操作、事务操作等，接下来一张图认识AOP思想：</p>
<p><img src="/images/a3/4.png" alt=""></p>
<p> AOP就是使用上图所示的“横切”技术，AOP把软件系统分为两个部分：<strong>核心关注点和横切关注点</strong>。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的一个特点是，他们经常发生在核心关注点的多处，而各处都基本相似。比如权限认证、日志、事务处理。Aop 的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。正如Avanade公司的高级方案构架师Adam Magee所说，AOP的核心思想就是<strong>“将应用程序中的商业逻辑同对其提供支持的通用服务进行分离。”</strong></p>
<h2 id="SpringMVC框架"><a href="#SpringMVC框架" class="headerlink" title="SpringMVC框架"></a>SpringMVC框架</h2><p><strong>SpringMVC</strong> 是基于 Java 语言实现 MVC 设计模式的请求驱动类型的轻量级 Web 框架，目的是将 Web 开发模块化及代码简化。其提供了 DispatcherServlet 前端控制器分派请求，同时提供灵活的配置处理程序映射、视图解析，并支持文件上传。</p>
<p><img src="/images/a3/5.png" alt=""></p>
<h2 id="MyBatis框架"><a href="#MyBatis框架" class="headerlink" title="MyBatis框架"></a>MyBatis框架</h2><p>MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生类型、接口和 Java 的 POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。</p>
<p><img src="/images/a3/6.png" alt=""></p>
<p><strong>MyBatis 的优点如下：</strong></p>
<ul>
<li>封装了 JDBC 大部分操作，减少开发人员工作量；</li>
<li>相比一些自动化的 ORM 框架，“半自动化”使得开发人员可以自由的编写 SQL 语句，灵活度更高；</li>
<li>Java 代码与 SQL 语句分离，降低维护难度；</li>
<li>自动映射结果集，减少重复的编码工作；</li>
<li>开源社区十分活跃，文档齐全，学习成本不高。</li>
</ul>
<h2 id="SpringBoot框架"><a href="#SpringBoot框架" class="headerlink" title="SpringBoot框架"></a>SpringBoot框架</h2><h3 id="什么是SpringBoot"><a href="#什么是SpringBoot" class="headerlink" title="什么是SpringBoot"></a>什么是SpringBoot</h3><p>Spring Boot 是所有基于 Spring 开发的项目的起点。Spring Boot 的设计是为了让你尽可能快的跑起来 Spring 应用程序并且尽可能减少你的配置文件。简单来说就是SpringBoot其实不是什么新的框架，它默认配置了很多框架的使用方式，就像maven整合了所有的jar包，spring boot整合了所有的框架（不知道这样比喻是否合适）。</p>
<h3 id="SpringBoot四个主要特性"><a href="#SpringBoot四个主要特性" class="headerlink" title="SpringBoot四个主要特性"></a>SpringBoot四个主要特性</h3><ol>
<li><p>SpringBoot Starter：他将常用的依赖分组进行了整合，将其合并到一个依赖中，这样就可以一次性添加到项目的Maven或Gradle构建中；</p>
</li>
<li><p>自动配置：SpringBoot的自动配置特性利用了Spring4对条件化配置的支持，合理地推测应用所需的bean并自动化配置他们；</p>
</li>
<li><p>命令行接口：（Command-line-interface, CLI）：SpringBoot的CLI发挥了Groovy编程语言的优势，并结合自动配置进一步简化Spring应用的开发；</p>
</li>
<li><p>Actuatir：它为SpringBoot应用的所有特性构建一个小型的应用程序。</p>
</li>
</ol>
<p><strong>简单来说，springboot也是属于spring框架中的一种，但是springboot”约定大于配置“的丽娘，极大简化了spring应用的初始搭建以及开发过程</strong></p>
<h1 id="框架比较"><a href="#框架比较" class="headerlink" title="框架比较"></a>框架比较</h1><p><strong>struts2 和 springMvc：</strong></p>
<ol>
<li><p>springmvc入口是一个servlet前端控制器(DispatcherServlet)，struts2入口是一filter过滤器(StrutsPrepareAndExecuteFilter)。</p>
</li>
<li><p>struts2通过在action类中定义成员变量接收参数，(属性驱动和模型驱动)，它只能使用多例模式管理action。springmvc通过在coontroller方法中定义形参接收参数，springmvc可以使用单例模式管理controller。 </p>
</li>
<li><p>springmvc是基于方法开发的，注解开发中使用requestMapping将url和方法进行映射，如果根据url找到controller类的方法生成一个handler处理器对象(只包括一个method)。struts2是基于类开发的，每个请求过来创建一个action实例，实例对象中有若干个方法。开发中建议使用springmvc，springmvc方法更类似service业务方法。</p>
</li>
<li><p>struts2采用值栈存储请求和相应的数据,通过OGNL存取数据，springmvc通过参数绑定期将request请求内容解析，并给方法形参赋值。</p>
</li>
<li><p>struts2和springmvc的速度是相当的，由于struts2的漏洞较多，更多企业使用springmvc。</p>
</li>
</ol>
<p><strong>springMvc和springBoot：</strong></p>
<ol>
<li>springMvc属于一个企业WEB开发的MVC框架，涵盖面包括前端视图开发、文件配置、后台接口逻辑开发等，XML、config等配置相对比较繁琐复杂。</li>
<li>springBoot框架相对于springMvc框架来说，更专注于开发微服务后台接口，不开发前端视图。</li>
</ol>
<p><strong>参考：</strong></p>
<p><a href="https://mybatis.org/mybatis-3/zh/index.html" target="_blank" rel="noopener">https://mybatis.org/mybatis-3/zh/index.html</a></p>
<p><a href="https://blog.csdn.net/qq_42494445/article/details/83926216" target="_blank" rel="noopener">https://blog.csdn.net/qq_42494445/article/details/83926216</a></p>
<p><a href="https://blog.csdn.net/qq_41701956/article/details/81215309" target="_blank" rel="noopener">https://blog.csdn.net/qq_41701956/article/details/81215309</a></p>
<p><a href="https://blog.csdn.net/wangzhidong_java/article/details/82974503" target="_blank" rel="noopener">https://blog.csdn.net/wangzhidong_java/article/details/82974503</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://he1m4n6a.git.io/2019/12/04/JAVA%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D/" data-id="ck3rasa5j000bvl8z7ru1b7q7" data-title="JAVA框架介绍" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JAVA/" rel="tag">JAVA</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AE%89%E5%85%A8/" rel="tag">安全</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2019/11/28/JAVA%E5%8F%8D%E5%B0%84%E4%B8%8E%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">JAVA反射与动态代理</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/JAVA%E5%AE%89%E5%85%A8%E6%95%99%E7%A8%8B/">JAVA安全教程</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/JAVA/" rel="tag">JAVA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AE%89%E5%85%A8/" rel="tag">安全</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/JAVA/" style="font-size: 10px;">JAVA</a> <a href="/tags/%E5%AE%89%E5%85%A8/" style="font-size: 10px;">安全</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/12/04/JAVA%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D/">JAVA框架介绍</a>
          </li>
        
          <li>
            <a href="/2019/11/28/JAVA%E5%8F%8D%E5%B0%84%E4%B8%8E%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/">JAVA反射与动态代理</a>
          </li>
        
          <li>
            <a href="/2019/11/26/JAVA%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/">JAVA基础教程</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 he1m4n6a<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/about" class="mobile-nav-link">About</a>
  
</nav>
    

<script src="/js/jquery-3.4.1.min.js"></script>


  <script src="/fancybox/jquery.fancybox.min.js"></script>


<script src="/js/script.js"></script>




  </div>
</body>
</html>